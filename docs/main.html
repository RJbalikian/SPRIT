<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sprit API documentation</title>
<meta name="description" content="This module analysis ambient seismic data using the Horizontal to Vertical Spectral Ratio (HVSR) technique" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>sprit</code></h1>
</header>
<section id="section-intro">
<p>This module analysis ambient seismic data using the Horizontal to Vertical Spectral Ratio (HVSR) technique</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#__init__.py
&#34;&#34;&#34;
This module analysis ambient seismic data using the Horizontal to Vertical Spectral Ratio (HVSR) technique
&#34;&#34;&#34;
try:
    import sprit.sprit_utils as sprit_utils
    import sprit.sprit_gui as sprit_gui
    import sprit.sprit_hvsr as sprit_hvsr
    import sprit.sprit_jupyter_UI as sprit_jupyter_UI
except:
    import sprit_utils
    import sprit_gui
    import sprit_hvsr
    import sprit_jupyter_UI

from sprit.sprit_hvsr import(
    run,
    azimuth,
    export_data,
    export_settings,
    import_data,
    import_settings,
    input_params,
    gui,
    get_metadata,
    fetch_data,
    batch_data_read,
    generate_ppsds,
    process_hvsr,
    plot_hvsr,
    read_tromino_files,
    remove_noise,
    remove_outlier_curves,
    check_peaks,
    get_report,
    HVSRData,
    HVSRBatch,
)

from sprit.sprit_utils import(
    check_gui_requirements,
    checkifpath,
    check_mark,
    check_tsteps,
    check_xvalues,
    format_time,
    get_char,
    has_required_channels,
    make_it_classy,
    read_from_RS,
    time_it,
    x_mark
)

from sprit.sprit_gui import(
    catch_errors
)

from sprit.sprit_jupyter_UI import(
    create_jupyter_ui
    )

__all__ =(&#39;sprit_hvsr&#39;,
            &#39;run&#39;,
            &#39;azimuth&#39;,
            &#39;check_mark&#39;,
            &#39;get_char&#39;,
            &#39;time_it&#39;,
            &#39;checkifpath&#39;,
            &#39;export_data&#39;,
            &#39;export_settings&#39;,
            &#39;import_data&#39;,
            &#39;import_settings&#39;,
            &#39;input_params&#39;,
            &#39;gui&#39;,
            &#39;get_metadata&#39;,
            &#39;has_required_channels&#39;,
            &#39;fetch_data&#39;,
            &#39;batch_data_read&#39;,
            &#39;generate_ppsds&#39;,
            &#39;process_hvsr&#39;,
            &#39;plot_hvsr&#39;,
            &#39;read_tromino_files&#39;,
            &#39;remove_noise&#39;,
            &#39;remove_outlier_curves&#39;,
            &#39;check_peaks&#39;,
            &#39;get_report&#39;,
            &#39;HVSRData&#39;,
            &#39;HVSRBatch&#39;,
        &#39;sprit_utils&#39;,
            &#39;check_gui_requirements&#39;,
            &#39;checkifpath&#39;,
            &#39;check_mark&#39;,
            &#39;check_tsteps&#39;,
            &#39;check_xvalues&#39;,
            &#39;format_time&#39;,
            &#39;get_char&#39;,
            &#39;has_required_channels&#39;,
            &#39;make_it_classy&#39;,
            &#39;read_from_RS&#39;,
            &#39;time_it&#39;,
            &#39;x_mark&#39;,
        &#39;sprit_gui&#39;,
            &#39;catch_errors&#39;,
        &#39;sprit_jupyter_UI&#39;,
            &#39;create_jupyter_ui&#39;
            )

__author__ = &#39;Riley Balikian&#39;</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="sprit.sprit_cli" href="sprit_cli.html">sprit.sprit_cli</a></code></dt>
<dd>
<div class="desc"><p>This module/script is used to run sprit from the command line …</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_gui" href="sprit_gui.html">sprit.sprit_gui</a></code></dt>
<dd>
<div class="desc"><p>This script contains all the functions, classes, etc. to create a tkinter app for graphical user interface.</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_hvsr" href="sprit_hvsr.html">sprit.sprit_hvsr</a></code></dt>
<dd>
<div class="desc"><p>This module is the main SpRIT module that contains all the functions needed to run HVSR analysis …</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_jupyter_UI" href="sprit_jupyter_UI.html">sprit.sprit_jupyter_UI</a></code></dt>
<dd>
<div class="desc"><p>Functions to create jupyter notebook widget UI</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_utils" href="sprit_utils.html">sprit.sprit_utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sprit.azimuth"><code class="name flex">
<span>def <span class="ident">azimuth</span></span>(<span>hvsr_data, azimuth_angle=10, azimuth_type='multiple', azimuth_unit='degrees', show_az_plot=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate azimuthal horizontal component at specified angle(s). Adds each new horizontal component as a radial component to obspy.Stream object at hvsr_data['stream']</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>Input HVSR data</dd>
<dt><strong><code>azimuth_angle</code></strong> :&ensp;<code>int</code>, default=<code>10</code></dt>
<dd>If <code>azimuth_type='multiple'</code>, this is the angular step (in unit <code>azimuth_unit</code>) of each of the azimuthal measurements.
If <code>azimuth_type='single'</code> this is the angle (in unit <code>azimuth_unit</code>) of the single calculated azimuthal measruement. By default 10.</dd>
<dt><strong><code>azimuth_type</code></strong> :&ensp;<code>str</code>, default=<code>'multiple'</code></dt>
<dd>What type of azimuthal measurement to make, by default 'multiple'.
If 'multiple' (or {'multi', 'mult', 'm'}), will take a measurement at each angular step of azimuth_angle of unit azimuth_unit.
If 'single' (or {'sing', 's'}), will take a single azimuthal measurement at angle specified in azimuth_angle.</dd>
<dt><strong><code>azimuth_unit</code></strong> :&ensp;<code>str</code>, default=<code>'degrees'</code></dt>
<dd>Angular unit used to specify <code>azimuth_angle</code> parameter. By default 'degrees'.
If 'degrees' (or {'deg', 'd'}), will use degrees.
If 'radians' (or {'rad', 'r'}), will use radians.</dd>
<dt><strong><code>show_az_plot</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show azimuthal plot, by default False.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print terminal output, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>Updated HVSRData object specified in hvsr_data with hvsr_data['stream'] attribute containing additional components (EHR-***),
with *** being zero-padded (3 digits) azimuth angle in degrees.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def azimuth(hvsr_data, azimuth_angle=10, azimuth_type=&#39;multiple&#39;, azimuth_unit=&#39;degrees&#39;, show_az_plot=False, verbose=False):
    &#34;&#34;&#34;Function to calculate azimuthal horizontal component at specified angle(s). Adds each new horizontal component as a radial component to obspy.Stream object at hvsr_data[&#39;stream&#39;]

    Parameters
    ----------
    hvsr_data : HVSRData
        Input HVSR data
    azimuth_angle : int, default=10
        If `azimuth_type=&#39;multiple&#39;`, this is the angular step (in unit `azimuth_unit`) of each of the azimuthal measurements.
        If `azimuth_type=&#39;single&#39;` this is the angle (in unit `azimuth_unit`) of the single calculated azimuthal measruement. By default 10.
    azimuth_type : str, default=&#39;multiple&#39;
        What type of azimuthal measurement to make, by default &#39;multiple&#39;.
        If &#39;multiple&#39; (or {&#39;multi&#39;, &#39;mult&#39;, &#39;m&#39;}), will take a measurement at each angular step of azimuth_angle of unit azimuth_unit.
        If &#39;single&#39; (or {&#39;sing&#39;, &#39;s&#39;}), will take a single azimuthal measurement at angle specified in azimuth_angle.
    azimuth_unit : str, default=&#39;degrees&#39;
        Angular unit used to specify `azimuth_angle` parameter. By default &#39;degrees&#39;.
        If &#39;degrees&#39; (or {&#39;deg&#39;, &#39;d&#39;}), will use degrees.
        If &#39;radians&#39; (or {&#39;rad&#39;, &#39;r&#39;}), will use radians.
    show_az_plot : bool, default=False
        Whether to show azimuthal plot, by default False.
    verbose : bool, default=False
        Whether to print terminal output, by default False

    Returns
    -------
    HVSRData
        Updated HVSRData object specified in hvsr_data with hvsr_data[&#39;stream&#39;] attribute containing additional components (EHR-***),
        with *** being zero-padded (3 digits) azimuth angle in degrees.
    &#34;&#34;&#34;
          
    degList = [&#39;degrees&#39;, &#39;deg&#39;, &#39;d&#39;]
    radList = [&#39;radians&#39;, &#39;rad&#39;, &#39;r&#39;]
    if azimuth_unit.lower() in degList:
        az_angle_rad = np.deg2rad(azimuth_angle)
        az_angle_deg = azimuth_angle
    elif azimuth_unit.lower() in radList:
        az_angle_rad = azimuth_angle
        az_angle_deg = np.rad2deg(azimuth_angle)
    else:
        warnings.warn(f&#34;azimuth_unit={azimuth_unit} not supported. Try &#39;degrees&#39; or &#39;radians&#39;. No azimuthal analysis run.&#34;)
        return hvsr_data
    
    #Limit to 
    if az_angle_deg &lt;= 1:
        if verbose:
            warnings.warn(f&#34;Minimum azimuth rotation is 1 degree (max. is 180). You have selected {az_angle_deg} degrees ({az_angle_rad} radians). Converting to azimuth_angle=1 degree ({np.round(np.pi/180,3)} radians) &#34;)
        az_angle_deg = 1
        az_angle_rad = np.pi/180
    elif az_angle_deg &gt;= 180:
        if verbose:
            warnings.warn(f&#34;Maximum azimuth value is azimuth_angle=180 degrees (min. is 1). You have selected {az_angle_deg} degrees ({az_angle_rad} radians). Converting to azimuth_angle=180 degrees ({np.round(np.pi,3)} radians) &#34;)
        az_angle_deg = 180
        az_angle_rad = np.pi

    multAzList = [&#39;multiple&#39;, &#39;multi&#39;, &#39;mult&#39;, &#39;m&#39;]
    singleAzList = [&#39;single&#39;, &#39;sing&#39;, &#39;s&#39;]
    if azimuth_type.lower() in multAzList:
        azimuth_list = list(np.arange(0, np.pi, az_angle_rad))
        azimuth_list_deg = list(np.arange(0, 180, az_angle_deg))
    elif azimuth_type.lower() in singleAzList:
        azimuth_list = [az_angle_rad]
        azimuth_list_deg = [az_angle_deg]
    else:
        warnings.warn(f&#34;azimuth_type={azimuth_type} not supported. Try &#39;multiple&#39; or &#39;single&#39;. No azimuthal analysis run.&#34;)
        return hvsr_data

    eComp = hvsr_data[&#39;stream&#39;].select(component=&#39;E&#39;).merge()
    nComp = hvsr_data[&#39;stream&#39;].select(component=&#39;N&#39;).merge()

    statsDict = {}
    for key, value in eComp[0].stats.items():
        statsDict[key] = value
    
    for i, az in enumerate(azimuth_list):
        az_rad = az
        az_deg = azimuth_list_deg[i]
        statsDict[&#39;channel&#39;] = f&#34;EHR-{str(round(az_deg,0)).zfill(3)}&#34; #Change channel name
        statsDict[&#39;azimuth_deg&#39;] = az_rad
        statsDict[&#39;azimuth_rad&#39;] = az_deg
        
        hasMask = [False, False]
        if np.ma.is_masked(nComp[0].data):
            nData = nComp[0].data.data
            nMask = nComp[0].data.mask
            hasMask[0] = True
        else:
            nData = nComp[0].data        
            nMask = [True] * len(nData)
        
        if np.ma.is_masked(eComp[0].data):
            eData = eComp[0].data.data
            eMask = eComp[0].data.mask
            hasMask[1] = True
        else:
            eData = eComp[0].data
            eMask = [True] * len(eData)

        print(az_angle_rad, az)

        if True in hasMask:
            radial_comp_data = np.ma.array(np.add(nData * np.cos(az), eData * np.sin(az_angle_rad)), mask=list(map(operator.and_, nMask, eMask)))
        else:
            radial_comp_data = np.add(nData * np.cos(az), eData * np.sin(az))
        #From hvsrpy
        # horizontal = self.ns._amp * math.cos(az_rad) + self.ew._amp*math.sin(az_rad)
        
        radial_trace = obspy.Trace(data=radial_comp_data, header=statsDict)
        hvsr_data[&#39;stream&#39;].append(radial_trace)
    
    return hvsr_data</code></pre>
</details>
</dd>
<dt id="sprit.batch_data_read"><code class="name flex">
<span>def <span class="ident">batch_data_read</span></span>(<span>input_data, batch_type='table', param_col=None, batch_params=None, verbose=False, **readcsv_getMeta_fetch_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read data in data as a batch of multiple data files. This is best used through sprit.fetch_data(<em>args, source='batch', </em>*other_kwargs).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_data</code></strong> :&ensp;<code>filepath</code> or <code>list</code></dt>
<dd>Input data information for how to read in data as batch</dd>
<dt><strong><code>batch_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of batch read, only 'table' and 'filelist' accepted. If 'table', will read data from a file read in using pandas.read_csv(), by default 'table'</dd>
<dt><strong><code>param_col</code></strong> :&ensp;<code>None</code> or <code>str</code>, optional</dt>
<dd>Name of parameter column from batch information file. Only used if a batch_type='table' and single parameter column is used, rather than one column per parameter (for single parameter column, parameters are formatted with = between keys/values and , between item pairs), by default None</dd>
<dt><strong><code>batch_params</code></strong> :&ensp;<code>list, dict,</code> or <code>None</code>, default <code>= None</code></dt>
<dd>Parameters to be used if batch_type='filelist'. If it is a list, needs to be the same length as input_data. If it is a dict, will be applied to all files in input_data and will combined with extra keyword arguments caught by **readcsv_getMeta_fetch_kwargs.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal during batch read, by default False</dd>
<dt><strong><code>**readcsv_getMeta_fetch_kwargs</code></strong></dt>
<dd>Keyword arguments that will be read into pandas.read_csv(), sprit.input_params, sprit.get_metadata(), and/or sprit.fetch_data()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary with each item representing a different file read in, and which consists of its own parameter dictionary to be used by the rest of the processing steps</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def batch_data_read(input_data, batch_type=&#39;table&#39;, param_col=None, batch_params=None, verbose=False, **readcsv_getMeta_fetch_kwargs):
    &#34;&#34;&#34;Function to read data in data as a batch of multiple data files. This is best used through sprit.fetch_data(*args, source=&#39;batch&#39;, **other_kwargs).

    Parameters
    ----------
    input_data : filepath or list
        Input data information for how to read in data as batch
    batch_type : str, optional
        Type of batch read, only &#39;table&#39; and &#39;filelist&#39; accepted. If &#39;table&#39;, will read data from a file read in using pandas.read_csv(), by default &#39;table&#39;
    param_col : None or str, optional
        Name of parameter column from batch information file. Only used if a batch_type=&#39;table&#39; and single parameter column is used, rather than one column per parameter (for single parameter column, parameters are formatted with = between keys/values and , between item pairs), by default None
    batch_params : list, dict, or None, default = None
        Parameters to be used if batch_type=&#39;filelist&#39;. If it is a list, needs to be the same length as input_data. If it is a dict, will be applied to all files in input_data and will combined with extra keyword arguments caught by **readcsv_getMeta_fetch_kwargs.
    verbose : bool, optional
        Whether to print information to terminal during batch read, by default False
    **readcsv_getMeta_fetch_kwargs
        Keyword arguments that will be read into pandas.read_csv(), sprit.input_params, sprit.get_metadata(), and/or sprit.fetch_data()

    Returns
    -------
    dict
        Dictionary with each item representing a different file read in, and which consists of its own parameter dictionary to be used by the rest of the processing steps

    Raises
    ------
    IndexError
        _description_
    &#34;&#34;&#34;
    #First figure out columns
    input_params_params = input_params.__code__.co_varnames
    get_metadata_params = get_metadata.__code__.co_varnames
    fetch_data_params = fetch_data.__code__.co_varnames

    if batch_type==&#39;sample&#39;:
        sample_data=True
        batch_type=&#39;table&#39;
    else:
        sample_data = False
    # Dictionary to store the stream objects
    stream_dict = {}
    data_dict = {}
    if batch_type == &#39;table&#39;:
        if isinstance(input_data, pd.DataFrame):
            dataReadInfoDF = input_data
        elif isinstance(input_data, dict):
            #For params input
            pass
        else:#Read csv
            read_csv_kwargs = {k: v for k, v in locals()[&#39;readcsv_getMeta_fetch_kwargs&#39;].items() if k in pd.read_csv.__code__.co_varnames}
            dataReadInfoDF = pd.read_csv(input_data, **read_csv_kwargs)
            if &#39;datapath&#39; in dataReadInfoDF.columns:
                filelist = list(dataReadInfoDF[&#39;datapath&#39;])
            #dataReadInfoDF = dataReadInfoDF.replace(np.nan, None)

        #If this is sample data, we need to create absolute paths to the filepaths
        if sample_data:
            sample_data_dir = pathlib.Path(pkg_resources.resource_filename(__name__, &#39;resources/sample_data/&#39;))
            for index, row in dataReadInfoDF.iterrows():
                dataReadInfoDF.loc[index, &#39;datapath&#39;] = sample_data_dir.joinpath(row.loc[&#39;datapath&#39;])

        default_dict = {&#39;site&#39;:&#39;HVSR Site&#39;,
                    &#39;network&#39;:&#39;AM&#39;, 
                    &#39;station&#39;:&#39;RAC84&#39;, 
                    &#39;loc&#39;:&#39;00&#39;, 
                    &#39;channels&#39;:[&#39;EHZ&#39;, &#39;EHN&#39;, &#39;EHE&#39;],
                    &#39;acq_date&#39;:str(datetime.datetime.now().date()),
                    &#39;starttime&#39; : &#39;00:00:00.00&#39;,
                    &#39;endtime&#39; : &#39;23:59:59.999&#39;,
                    &#39;tzone&#39; : &#39;UTC&#39;,
                    &#39;xcoord&#39; : -88.2290526,
                    &#39;ycoord&#39; :  40.1012122,
                    &#39;elevation&#39; : 755,
                    &#39;input_crs&#39;:&#39;EPSG:4326&#39;,#4269 is NAD83, defautling to WGS
                    &#39;output_crs&#39;:&#39;EPSG:4326&#39;,
                    &#39;elev_unit&#39; : &#39;feet&#39;,
                    &#39;depth&#39; : 0,
                    &#39;instrument&#39; : &#39;Raspberry Shake&#39;,
                    &#39;metapath&#39; : &#39;&#39;,
                    &#39;hvsr_band&#39; : [1, 40],
                    &#39;write_path&#39;:&#39;&#39;,
                    &#39;source&#39;:&#39;file&#39;, 
                    &#39;export_format&#39;:&#39;mseed&#39;, 
                    &#39;detrend&#39;:&#39;spline&#39;, 
                    &#39;detrend_order&#39;:2, 
                    &#39;verbose&#39;:False}

        print(f&#34;\t{dataReadInfoDF.shape[0]} sites found: {list(dataReadInfoDF[&#39;site&#39;])}&#34;)
        if verbose:
            maxLength = 25
            maxColWidth = 12
            if dataReadInfoDF.shape[0] &gt; maxLength:
                print(f&#39;\t Showing information for first {maxLength} files only:&#39;)
            print()
            #Print nicely formated df
            #Print column names
            print(&#39;\t&#39;, end=&#39;&#39;)
            for col in dataReadInfoDF.columns:
                print(str(col)[:maxColWidth].ljust(maxColWidth), end=&#39;  &#39;)
            print(&#39;\n\t&#39;, end=&#39;&#39;)

            #Print separator
            tableLen = (maxColWidth+2)*len(dataReadInfoDF.columns)
            for r in range(tableLen):
                print(&#39;-&#39;, end=&#39;&#39;)
            print()

            #Print columns/rows
            for index, row in dataReadInfoDF.iterrows():
                print(&#39;\t&#39;, end=&#39;&#39;)
                for col in row:
                    if len(str(col)) &gt; maxColWidth:
                        print((str(col)[:maxColWidth-3]+&#39;...&#39;).ljust(maxColWidth), end=&#39;  &#39;)
                    else:
                        print(str(col)[:maxColWidth].ljust(maxColWidth), end=&#39;  &#39;)
                print()
            if dataReadInfoDF.shape[0] &gt; maxLength:
                endline = f&#39;\t...{dataReadInfoDF.shape[0]-maxLength} more rows in file.\n&#39;
            else:
                endline = &#39;\n&#39;
            print(endline)

            print(&#39;Fetching the following files:&#39;)
        param_dict_list = []
        verboseStatement = []
        if param_col is None: #Not a single parameter column, each col=parameter
            for row_ind in range(dataReadInfoDF.shape[0]):
                param_dict = {}
                verboseStatement.append([])
                for col in dataReadInfoDF.columns:
                    if col in input_params_params or col in get_metadata_params or col in fetch_data_params:
                        currParam = dataReadInfoDF.loc[row_ind, col]
                        if pd.isna(currParam) or currParam == &#39;nan&#39;:
                            if col in default_dict.keys():
                                param_dict[col] = default_dict[col] #Get default value
                                if verbose:
                                    if type(default_dict[col]) is str:
                                        verboseStatement[row_ind].append(&#34;\t\t&#39;{}&#39; parameter not specified in batch file. Using {}=&#39;{}&#39;&#34;.format(col, col, default_dict[col]))
                                    else:
                                        verboseStatement[row_ind].append(&#34;\t\t&#39;{}&#39; parameter not specified in batch file. Using {}={}&#34;.format(col, col, default_dict[col]))
                            else:
                                param_dict[col] = None
                        else:
                            param_dict[col] = dataReadInfoDF.loc[row_ind, col]
                param_dict_list.append(param_dict)
        else:
            if param_col not in dataReadInfoDF.columns:
                raise IndexError(&#39;{} is not a column in {} (columns are: {})&#39;.format(param_col, input_data, dataReadInfoDF.columns))
            for row in dataReadInfoDF[param_col]:
                param_dict = {}
                splitRow = str(row).split(&#39;,&#39;)
                for item in splitRow:
                    param_dict[item.split(&#39;=&#39;)[0]] = item.split(&#39;=&#39;)[1]
                param_dict_list.append(param_dict)
        #input_params(datapath,site,network,station,loc,channels, acq_date,starttime, endtime, tzone, xcoord, ycoord, elevation, depth, instrument, metapath, hvsr_band)
        #fetch_data(params, inv, source, trim_dir, export_format, detrend, detrend_order, verbose)
        #get_metadata(params, write_path)
    elif batch_type == &#39;filelist&#39;:
        if isinstance(batch_params, list):
            if len(batch_params) != len(input_data):
                raise RuntimeError(&#39;If batch_params is list, it must be the same length as input_data. len(batch_params)={} != len(input_data)={}&#39;.format(len(batch_params), len(input_data)))
            param_dict_list = batch_params
        elif isinstance(batch_params, dict):
            batch_params.update(readcsv_getMeta_fetch_kwargs)
            param_dict_list = []
            for i in range(len(input_data)):
                param_dict_list.append(batch_params)
        
        # Read and process each MiniSEED file
        for i, file in enumerate(input_data):
            if isinstance(file, obspy.core.stream.Stream):
                warnings.warn(&#39;Reading in a list of Obspy streams is not currently supported, but may be implemented in the future&#39;, FutureWarning)
                pass 
            else:
                param_dict_list[i][&#39;datapath&#39;] = file

    hvsr_metaDict = {}
    zfillDigs = len(str(len(param_dict_list))) #Get number of digits of length of param_dict_list
    i=0
    for i, param_dict in enumerate(param_dict_list):
        # Read the data file into a Stream object
        input_params_kwargs = {k: v for k, v in locals()[&#39;readcsv_getMeta_fetch_kwargs&#39;].items() if k in input_params.__code__.co_varnames}
        input_params_kwargs2 = {k: v for k, v in param_dict.items() if k in input_params.__code__.co_varnames}
        input_params_kwargs.update(input_params_kwargs2)

        params = input_params(**input_params_kwargs)

        fetch_data_kwargs = {k: v for k, v in locals()[&#39;readcsv_getMeta_fetch_kwargs&#39;].items() if k in fetch_data.__code__.co_varnames}
        fetch_data_kwargs2 = {k: v for k, v in param_dict.items() if k in fetch_data.__code__.co_varnames[0:7]}
        fetch_data_kwargs.update(fetch_data_kwargs2)
        
        try:
            params = fetch_data(params=params, **fetch_data_kwargs)
        except:
            params[&#39;ProcessingStatus&#39;][&#39;FetchDataStatus&#39;]=False
            params[&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False            
        
        if verbose and params[&#39;ProcessingStatus&#39;][&#39;FetchDataStatus&#39;]:
            print(&#34;\t  {}&#34;.format(params[&#39;site&#39;]))
            if verboseStatement !=[]:
                for item in verboseStatement[i]:
                    print(item)
        elif verbose and not params[&#39;ProcessingStatus&#39;][&#39;FetchDataStatus&#39;]:
            print(&#34;\t  {} not read correctly. Processing will not be carried out.&#34;.format(params[&#39;site&#39;]))
                
        params[&#39;batch&#39;] = True

        if params[&#39;site&#39;] == default_dict[&#39;site&#39;]: #If site was not designated
            params[&#39;site&#39;] = &#34;{}_{}&#34;.format(params[&#39;site&#39;], str(i).zfill(zfillDigs))
            i+=1
        hvsr_metaDict[params[&#39;site&#39;]] = params

    hvsr_metaDict = HVSRBatch(hvsr_metaDict)

    return hvsr_metaDict</code></pre>
</details>
</dd>
<dt id="sprit.catch_errors"><code class="name flex">
<span>def <span class="ident">catch_errors</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def catch_errors(func):
    #Define a local function to get a list of warnings that we&#39;ll use in the output
    def get_warning_msg_list(w):
        messageList = []
        #Collect warnings that happened before we got to the error
        if w:
            hasWarnings = True
            for wi in w:
                warning_category = type(wi.message).__name__.title().replace(&#39;warning&#39;,&#39;Warning&#39;)
                #if w.line is None:
                #    w.line = linecache.getline(wi.filename, wi.lineno)
                warning_lineNo = wi.lineno
                warning_message = str(wi.message)
                # append the warning category and message to messageList so we get all warnings
                messageList.append(f&#39;{warning_category} ({warning_lineNo}): {warning_message}&#39;)
        return messageList
    
    # use functools.wraps to preserve the original function&#39;s metadata
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        result = None
        # use the global keyword to access the error_message and error_category variables
        global error_message
        global error_category

        messageList = []
        hasWarnings = False
        # use a try-except block to catch any exceptions
        #result = func(*args, **kwargs)
        try:
            # use a context manager to catch any warnings
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter(&#39;always&#39;)
                # call the original function with the given arguments
                result = func(*args, **kwargs)
                
                #Get message list, [] if no messages, doesn&#39;t run at all if Error/exception in func
                messageList = get_warning_msg_list(w)
                if messageList == []:
                    return result
                else:
                    warningMessage = &#34;WARNING:&#34;
                    for msg in messageList:
                        warningMessage = &#34;\n {}&#34;.format(msg)

                    messagebox.showwarning(title=&#39;WARNINGS&#39;, message=warningMessage)
                    
        except Exception as e:
            messageList = get_warning_msg_list(w)
            errorObj = sys.exc_info()[2]

            mainErrText = sys.exc_info()[1]

            mainErrTb = traceback.extract_tb(sys.exc_info()[2])[-1]
            mainErrFilePath = pathlib.Path(mainErrTb[0])
            
            mainErrFileName = mainErrFilePath.stem
            mainErrLineNo = mainErrTb[1]
            mainErrFunc = mainErrTb[2]
            mainErrCodeLine = mainErrTb[3]

            errLineNo1 = str(traceback.extract_tb(sys.exc_info()[2])[-1].lineno)
            error_category = type(e).__name__.title().replace(&#39;error&#39;, &#39;Error&#39;)
            error_message = f&#34;{e} ({errLineNo1})&#34;
            
            #Get message list, [] if no messages, doesn&#39;t run at all if Error/exception in func
            warningMessageList = get_warning_msg_list(w)

            #Build error messages
            tbTuple0 = sys.exc_info()[0]
            tbTuple1 = sys.exc_info()[1]
            tbTuple2 = traceback.extract_tb(sys.exc_info()[2])
            
            logMsg = f&#34;**ERROR**\n{tbTuple0.__name__}: {tbTuple1}&#34;
            dialogErrMsg = logMsg.split(&#39;:&#39;)[1]
            for tb in tbTuple2:
                logMsg = logMsg + &#39;\n\t&#39;
                logMsg = logMsg + f&#34;{pathlib.Path(tb[0]).stem}.{tb[2]}(): {tb[3]} (Line {tb[1]})&#34;
                dialogErrMsg = dialogErrMsg + f&#34;\n{pathlib.Path(tb[0]).stem}.{tb[2]}(), Line {tb[1]}&#34;
            logMsg = logMsg + &#39;\n\n&#39;

            #fullErrorMessage = f&#39;ERROR {mainErrFileName}.{mainErrFunc} ({mainErrLineNo}): {mainErrText} \n\n {mainErrFileName} Line {mainErrLineNo}: {mainErrCodeLine}.&#39;
            if messageList == []:
                pass
            else:
                dialogErrMsg = dialogErrMsg+&#34;\n\n  Additional Warnings along the way. See Log for more information.&#34;
                logMsg = logMsg + &#34;\n\n\t  *WARNING(S)*\n\tAdditional Warnings along the way:&#34;
                for addMsg in warningMessageList:
                    logMsg = logMsg+&#34;\n\t\t{}&#34;.format(addMsg)


            SPRIT_App.log_errorMsg(spritApp, logMsg)

            messagebox.showerror(title=f&#39;ERROR ({error_category})&#39;,
                                    message=dialogErrMsg)
            update_progress_bars(100)

        # return the result of the function or the error/warning messages and categories
        return result
    # return the wrapper function
    return wrapper</code></pre>
</details>
</dd>
<dt id="sprit.check_gui_requirements"><code class="name flex">
<span>def <span class="ident">check_gui_requirements</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_gui_requirements():
    #First, check requirements
    # Define a command that tries to open a window
    command = &#34;python -c \&#34;import tkinter; tkinter.Tk()\&#34;&#34;

    # Run the command and get the exit code
    exit_code = os.system(command)
    
    # Check if tkinter gui could be created
    if exit_code == 0:
        #Tkinter 
        oktoproceed=True
    else:
        oktoproceed=False
        print(&#34;GUI window cannot be created.&#34;)

    return oktoproceed

    #if sys.platform == &#39;linux&#39;:
    #    # Check if qtwayland5 is installed
    #    output = subprocess.run([&#34;dpkg&#34;, &#34;-s&#34;, &#34;qtwayland5&#34;], capture_output=True, text=True)
    #    if &#34;Status: install ok installed&#34; in output.stdout:
    #        print(&#34;qtwayland5 is already installed&#34;)
    #    else:
    #        print(&#34;qtwayland5 is not installed&#34;)
    #        # Install qtwayland5
    #        os.system(&#34;sudo apt install qtwayland5&#34;)</code></pre>
</details>
</dd>
<dt id="sprit.check_mark"><code class="name flex">
<span>def <span class="ident">check_mark</span></span>(<span>incolor=False, interminal=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The default Windows terminal is not able to display the check mark character correctly.
This function returns another displayable character if platform is Windows</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_mark(incolor=False, interminal=False):
    &#34;&#34;&#34;The default Windows terminal is not able to display the check mark character correctly.
       This function returns another displayable character if platform is Windows&#34;&#34;&#34;
    if incolor:
        try:
            check = get_char(u&#39;\u2705&#39;)
        except:
            check = get_char(u&#39;\u2714&#39;)
    else:
        check = get_char(u&#39;\u2714&#39;)

    if sys.platform==&#39;win32&#39; and interminal:
        check = get_char(u&#39;\u039E&#39;)
    return check</code></pre>
</details>
</dd>
<dt id="sprit.check_peaks"><code class="name flex">
<span>def <span class="ident">check_peaks</span></span>(<span>hvsr_data, hvsr_band=[1, 40], peak_selection='max', peak_freq_range=[1, 20], verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to run tests on HVSR peaks to find best one and see if it passes quality checks</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the calculated information about the HVSR data (i.e., hvsr_out returned from process_hvsr)</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>tuple</code> or <code>list</code>, default=<code>[1, 40]</code></dt>
<dd>2-item tuple or list with lower and upper limit of frequencies to analyze</dd>
<dt><strong><code>peak_selection</code></strong> :&ensp;<code>str</code> or <code>numeric</code>, default=<code>'max'</code></dt>
<dd>How to select the "best" peak used in the analysis. For peak_selection="max" (default value), the highest peak within peak_freq_range is used.
For peak_selection='scored', an algorithm is used to select the peak based in part on which peak passes the most SESAME criteria.
If a numeric value is used (e.g., int or float), this should be a frequency value to manually select as the peak of interest.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>tuple</code> or <code>list</code>, default=<code>[1, 20];</code></dt>
<dd>The frequency range within which to check for peaks. If there is an HVSR curve with multiple peaks, this allows the full range of data to be processed while limiting peak picks to likely range.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print results and inputs to terminal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hvsr_data
: HVSRData</code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Object containing previous input data, plus information about peak tests</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_peaks(hvsr_data, hvsr_band=[1, 40], peak_selection=&#39;max&#39;, peak_freq_range=[1, 20], verbose=False):
    &#34;&#34;&#34;Function to run tests on HVSR peaks to find best one and see if it passes quality checks

        Parameters
        ----------
        hvsr_data : dict
            Dictionary containing all the calculated information about the HVSR data (i.e., hvsr_out returned from process_hvsr)
        hvsr_band : tuple or list, default=[1, 40]
            2-item tuple or list with lower and upper limit of frequencies to analyze
        peak_selection : str or numeric, default=&#39;max&#39;
            How to select the &#34;best&#34; peak used in the analysis. For peak_selection=&#34;max&#34; (default value), the highest peak within peak_freq_range is used.
            For peak_selection=&#39;scored&#39;, an algorithm is used to select the peak based in part on which peak passes the most SESAME criteria.
            If a numeric value is used (e.g., int or float), this should be a frequency value to manually select as the peak of interest.
        peak_freq_range : tuple or list, default=[1, 20];
            The frequency range within which to check for peaks. If there is an HVSR curve with multiple peaks, this allows the full range of data to be processed while limiting peak picks to likely range.
        verbose : bool, default=False
            Whether to print results and inputs to terminal.
        
        Returns
        -------
        hvsr_data   : HVSRData or HVSRBatch object
            Object containing previous input data, plus information about peak tests
    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;check_peaks&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;check_peaks&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(check_peaks).args[1:], 
                                        inspect.getfullargspec(check_peaks).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    orig_args[k] = v

    hvsr_band = orig_args[&#39;hvsr_band&#39;]
    peak_selection = orig_args[&#39;peak_selection&#39;]
    peak_freq_range = orig_args[&#39;peak_freq_range&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    if (verbose and &#39;input_params&#39; not in hvsr_data.keys()) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nChecking peaks in the H/V Curve (check_peaks())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key==&#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))
            print()
  
    #First, divide up for batch or not
    if isinstance(hvsr_data, HVSRBatch):
        if verbose:
            print(&#39;\t  Running in batch mode&#39;)
        #If running batch, we&#39;ll loop through each site
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] =  hvsr_data[site_name] #Get what would normally be the &#34;params&#34; variable for each site
            if hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
                try:
                    hvsr_data[site_name] = _check_peaks_batch(**args) #Call another function, that lets us run this function again
                except:
                    if verbose:
                        print(f&#34;\t{site_name}: check_peaks() unsuccessful. Peaks not checked.&#34;)
                    else:
                        warnings.warn(f&#34;\t{site_name}: check_peaks() unsuccessful. Peaks not checked.&#34;, RuntimeWarning)
                
        hvsr_data = HVSRBatch(hvsr_data)
    else:
        if hvsr_data[&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
            if not hvsr_band:
                hvsr_band = [1,40]
            
            hvsr_data[&#39;hvsr_band&#39;] = hvsr_band

            anyK = list(hvsr_data[&#39;x_freqs&#39;].keys())[0]

            x = hvsr_data[&#39;x_freqs&#39;][anyK] #Consistent for all curves
            y = hvsr_data[&#39;hvsr_curve&#39;] #Calculated based on &#34;Use&#34; column

            scorelist = [&#39;score&#39;, &#39;scored&#39;, &#39;best&#39;, &#39;s&#39;]
            maxlist = [&#39;max&#39;, &#39;highest&#39;, &#39;m&#39;]
            # Convert peak_selection to numeric, get index of nearest value as list item for __init_peaks()
            try:
                peak_val = float(peak_selection)
                index_list = [np.argmin(np.abs(x - peak_val))]        
            except:
                # If score method is being used, get index list for __init_peaks()
                if peak_selection in scorelist:
                    index_list = hvsr_data[&#39;hvsr_peak_indices&#39;] #Calculated based on hvsr_curve
                elif peak_selection in maxlist:
                    #Get max index as item in list for __init_peaks()
                    startInd = np.argmin(np.abs(x - peak_freq_range[0]))
                    endInd = np.argmin(np.abs(x - peak_freq_range[1]))
                    if startInd &gt; endInd:
                        holder = startInd
                        startInd = endInd
                        endInd = holder
                    subArrayMax = np.argmax(y[startInd:endInd])

                    # If max val is in subarray, this will be the same as the max of curve
                    # Otherwise, it will be the index of the value that is max within peak_freq_range
                    index_list = [subArrayMax+startInd]
            
            hvsrp = hvsr_data[&#39;hvsrp&#39;] #Calculated based on &#34;Use&#34; column
            hvsrm = hvsr_data[&#39;hvsrm&#39;] #Calculated based on &#34;Use&#34; column

            hvsrPeaks = hvsr_data[&#39;hvsr_df&#39;][hvsr_data[&#39;hvsr_df&#39;][&#39;Use&#39;]][&#39;CurvesPeakIndices&#39;]
            #hvsrPeaks = hvsr_data[&#39;ind_hvsr_peak_indices&#39;] #Original calculation

            hvsr_log_std = hvsr_data[&#39;hvsr_log_std&#39;]
            peak_freq_range = hvsr_data[&#39;peak_freq_range&#39;]

            #Do for hvsr
            peak = __init_peaks(x, y, index_list, hvsr_band, peak_freq_range)

            peak = __check_curve_reliability(hvsr_data, peak)
            peak = __check_clarity(x, y, peak, do_rank=True)

            #Do for hvsrp
            # Find  the relative extrema of hvsrp (hvsr + 1 standard deviation)
            if not np.isnan(np.sum(hvsrp)):
                index_p = __find_peaks(hvsrp)
            else:
                index_p = list()

            peakp = __init_peaks(x, hvsrp, index_p, hvsr_band, peak_freq_range)
            peakp = __check_clarity(x, hvsrp, peakp, do_rank=True)

            # Do for hvsrm
            # Find  the relative extrema of hvsrm (hvsr - 1 standard deviation)
            if not np.isnan(np.sum(hvsrm)):
                index_m = __find_peaks(hvsrm)
            else:
                index_m = list()

            peakm = __init_peaks(x, hvsrm, index_m, hvsr_band, peak_freq_range)
            peakm = __check_clarity(x, hvsrm, peakm, do_rank=True)

            # Get standard deviation of time peaks
            stdf = __get_stdf(x, index_list, hvsrPeaks)

            peak = __check_freq_stability(peak, peakm, peakp)
            peak = __check_stability(stdf, peak, hvsr_log_std, rank=True)

            hvsr_data[&#39;PeakReport&#39;] = peak

            #Iterate through peaks and 
            #   Get the BestPeak based on the peak score
            #   Calculate whether each peak passes enough tests
            curveTests = [&#39;WindowLengthFreq.&#39;,&#39;SignificantCycles&#39;, &#39;LowCurveStDevOverTime&#39;]
            peakTests = [&#39;PeakProminenceBelow&#39;, &#39;PeakProminenceAbove&#39;, &#39;PeakAmpClarity&#39;, &#39;FreqStability&#39;, &#39;PeakStability_FreqStD&#39;, &#39;PeakStability_AmpStD&#39;]
            bestPeakScore = 0

            for p in hvsr_data[&#39;PeakReport&#39;]:
                #Get BestPeak
                if p[&#39;Score&#39;] &gt; bestPeakScore:
                    bestPeakScore = p[&#39;Score&#39;]
                    bestPeak = p

                #Calculate if peak passes criteria
                cTestsPass = 0
                pTestsPass = 0
                for testName in p[&#39;PassList&#39;].keys():
                    if testName in curveTests:
                        if p[&#39;PassList&#39;][testName]:
                            cTestsPass += 1
                    elif testName in peakTests:
                        if p[&#39;PassList&#39;][testName]:
                            pTestsPass += 1

                if cTestsPass == 3 and pTestsPass &gt;= 5:
                    p[&#39;PeakPasses&#39;] = True
                else:
                    p[&#39;PeakPasses&#39;] = False
                
            #Designate BestPeak in output dict
            if len(hvsr_data[&#39;PeakReport&#39;]) == 0:
                bestPeak={}
                print(f&#34;No Best Peak identified for {hvsr_data[&#39;site&#39;]}&#34;)

            hvsr_data[&#39;BestPeak&#39;] = bestPeak
        else:
            hvsr_data[&#39;BestPeak&#39;] = {}
            print(f&#34;Processing Errors: No Best Peak identified for {hvsr_data[&#39;site&#39;]}&#34;)
            try:
                hvsr_data.plot()
            except:
                pass

        hvsr_data[&#39;processing_parameters&#39;][&#39;check_peaks&#39;] = {}
        for key, value in orig_args.items():
            hvsr_data[&#39;processing_parameters&#39;][&#39;check_peaks&#39;][key] = value


    return hvsr_data</code></pre>
</details>
</dd>
<dt id="sprit.check_tsteps"><code class="name flex">
<span>def <span class="ident">check_tsteps</span></span>(<span>hvsr_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Check time steps of PPSDS to make sure they are all the same length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_tsteps(hvsr_data):
    &#34;&#34;&#34;Check time steps of PPSDS to make sure they are all the same length&#34;&#34;&#34;
    ppsds = hvsr_data[&#39;ppsds&#39;]
    tSteps = []
    for k in ppsds.keys():
        tSteps.append(np.array(ppsds[k][&#39;psd_values&#39;]).shape[0])
    if len(set(tSteps)) &lt;= 1:
        pass #This means all channels have same number of period_bin_centers
        minTStep=tSteps[0]
    else:
        print(&#39;There is a different number of time-steps used to calculate HVSR curves. \n This may result in computational errors. Trimming longest.&#39;)
        minTStep = min(tSteps)
    return minTStep</code></pre>
</details>
</dd>
<dt id="sprit.check_xvalues"><code class="name flex">
<span>def <span class="ident">check_xvalues</span></span>(<span>ppsds)</span>
</code></dt>
<dd>
<div class="desc"><p>Check x_values of PPSDS to make sure they are all the same length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_xvalues(ppsds):
    &#34;&#34;&#34;Check x_values of PPSDS to make sure they are all the same length&#34;&#34;&#34;
    xLengths = []
    for k in ppsds.keys():
        xLengths.append(len(ppsds[k][&#39;period_bin_centers&#39;]))
    if len(set(xLengths)) &lt;= 1:
        pass #This means all channels have same number of period_bin_centers
    else:
        print(&#39;X-values (periods or frequencies) do not have the same values. \n This may result in computational errors&#39;)
        #Do stuff to fix it?
    return ppsds</code></pre>
</details>
</dd>
<dt id="sprit.checkifpath"><code class="name flex">
<span>def <span class="ident">checkifpath</span></span>(<span>filepath, sample_list='', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Support function to check if a filepath is a pathlib.Path object and tries to convert if not</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path,</code> or <code>anything</code></dt>
<dd>Filepath to check. If not a valid filepath, will not convert and raises error</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>pathlib.Path</code></dt>
<dd>pathlib.Path of filepath</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkifpath(filepath, sample_list=&#39;&#39;, verbose=False):
    &#34;&#34;&#34;Support function to check if a filepath is a pathlib.Path object and tries to convert if not

    Parameters
    ----------
    filepath : str or pathlib.Path, or anything
        Filepath to check. If not a valid filepath, will not convert and raises error

    Returns
    -------
    filepath : pathlib.Path
        pathlib.Path of filepath
    &#34;&#34;&#34;
    if sample_list==&#39;&#39;:
        sample_list = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;sample&#39;, &#39;batch&#39;, &#39;sample&#39;, &#39;sample_batch&#39;]
        for s in range(1, 7):
            sample_list.append(f&#34;sample{s}&#34;)
            sample_list.append(f&#34;sample_{s}&#34;)

    # checks if the variable is any instance of pathlib
    if isinstance(filepath, pathlib.PurePath):
        pass
    elif str(filepath) in sample_list:
        pass
    else:
        try:
            filepath = pathlib.Path(filepath)
        except:
            if verbose:
                warnings.warn(&#39;Filepath cannot be converted to pathlib path: {}&#39;.format(filepath))
        if not filepath.exists():
            raise RuntimeError(&#39;File does not exist: {}&#39;.format(filepath))
    return filepath</code></pre>
</details>
</dd>
<dt id="sprit.create_jupyter_ui"><code class="name flex">
<span>def <span class="ident">create_jupyter_ui</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_jupyter_ui():
    global hvsr_data

    ui_width = 20
    ui_height= 12
    global results_fig
    global log_textArea
    log_textArea = widgets.Textarea(value=&#34;SESSION LOG&#34;, disabled=True, layout={&#39;height&#39;: &#39;300px&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    # INPUT TAB
    # Create a VBox for the accordions
    input_HBox = widgets.HBox()
    input_accordion_label_box = widgets.VBox()
    input_accordion_box = widgets.VBox()
    input_accordion = widgets.Accordion()

    # Metadata accordion
    metadata_grid = widgets.GridspecLayout(7, 10)
    network_textbox = widgets.Text(description=&#39;Network:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;network&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;network&#39;),
                                    tooltip=&#34;input_params(network)&#34;)

    station_textbox = widgets.Text(description=&#39;Station:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;station&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;station&#39;))

    location_textbox = widgets.Text(description=&#39;Location:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;loc&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;loc&#39;))

    z_channel_textbox = widgets.Text(description=&#39;Z Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[0],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[0])

    e_channel_textbox = widgets.Text(description=&#39;E Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[2],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[2])

    n_channel_textbox = widgets.Text(description=&#39;N Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[1],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[1])


    # Instrument Settings
    inst_settings_text = widgets.Text(placeholder=&#39;Instrument Settings Filepath&#39;, layout=widgets.Layout(width=&#39;55%&#39;))
    instrument_read_button = widgets.Button(icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;4%&#39;))
    instrument_settings_button = widgets.Button(description=&#39;Select .inst file&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    inst_settings_hbox = widgets.HBox([inst_settings_text,instrument_read_button, instrument_settings_button])
    
    def select_inst(event):
        try:
            if event.description == &#39;Select .inst file&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                inst_files = filedialog.askopenfilenames(defaultextension=&#39;.inst&#39;, filetypes=[(&#39;Inst&#39;, &#39;.inst&#39;)],
                                                                    title=&#34;Select Instrument Settings File&#34;)
                if isinstance(inst_files, tuple):
                    pass
                else:
                    inst_files = tuple(inst_files)
                root.destroy()
            else:
                inst_files = tuple([inst_settings_text.value])

            for i, inst_f in enumerate(inst_files):
                inst_settings_text.value = pathlib.Path(inst_f).as_posix()
                inst_settings = sprit_hvsr.import_settings(settings_import_path=pathlib.Path(inst_f).as_posix(), settings_import_type=&#39;instrument&#39;)
                
                # Go through all items and add them
                if &#39;instrument&#39; in inst_settings.keys():
                    if inst_settings[&#39;instrument&#39;] not in instrument_dropdown.options:
                        instrument_dropdown.options.append(inst_settings[&#39;instrument&#39;])
                    instrument_dropdown.value = inst_settings[&#39;instrument&#39;]
                
                if &#39;net&#39; in inst_settings.keys():
                    network_textbox.value = inst_settings[&#39;net&#39;]

                if &#39;sta&#39; in inst_settings.keys():
                    station_textbox.value = inst_settings[&#39;sta&#39;]

                if &#39;loc&#39; in inst_settings.keys():
                    location_textbox.value = inst_settings[&#39;loc&#39;]

                if &#39;cha&#39; in inst_settings.keys():
                    for c in inst_settings[&#39;cha&#39;]:
                        if c.lower()[2]==&#39;z&#39;:
                            z_channel_textbox.value = c
                        if c.lower()[2]==&#39;e&#39;:
                            e_channel_textbox.value = c
                        if c.lower()[2] ==&#39;n&#39;:
                            n_channel_textbox.value = c
                
                if &#39;metapath&#39; in inst_settings.keys():
                    metadata_filepath.value = inst_settings[&#39;metapath&#39;]

                if &#39;hvsr_band&#39; in inst_settings.keys():
                    hvsr_band_min_box.value = inst_settings[&#39;hvsr_band&#39;][0]
                    hvsr_band_max_box.value = inst_settings[&#39;hvsr_band&#39;][1]

        except Exception as e:
            print(e)
            instrument_settings_button.disabled=True
            instrument_settings_button.description=&#39;Use Text Field&#39;
    
    instrument_settings_button.on_click(select_inst)
    instrument_read_button.on_click(select_inst)

    metadata_grid[0,:] = inst_settings_hbox
    metadata_grid[1,0] = network_textbox
    metadata_grid[2,0] = station_textbox
    metadata_grid[3,0] = location_textbox
    metadata_grid[4,0] = z_channel_textbox
    metadata_grid[5,0] = e_channel_textbox
    metadata_grid[6,0] = n_channel_textbox

    # Acquisition Accordion
    instrument_grid = widgets.GridspecLayout(5, 10)
    # Date Picker labelled &#34;Acquisition Date&#34;
    acquisition_date_picker = widgets.DatePicker(description=&#39;Acq.Date:&#39;,
                                            placeholder=datetime.datetime.today().date(),
                                            value=datetime.datetime.today().date())

    # Label that shows the Date currently selected in the Date Picker
    acquisition_doy = widgets.IntText(description=&#39;DOY&#39;,
                                                placeholder=f&#34;{acquisition_date_picker.value.timetuple().tm_yday}&#34;,
                                                value=f&#34;{acquisition_date_picker.value.timetuple().tm_yday}&#34;,
                                                layout=widgets.Layout(width=&#39;auto&#39;))

    def on_acq_date_change(change):
        acquisition_doy.value = acquisition_date_picker.value.timetuple().tm_yday
    acquisition_date_picker.observe(on_acq_date_change)

    def on_doy_change(change):
        curr_year = datetime.datetime.today().year
        if acquisition_doy.value &gt; datetime.datetime.today().timetuple().tm_yday:
            curr_year -= 1
        acquisition_date_picker.value = (datetime.datetime(curr_year, 1, 1) + datetime.timedelta(days = acquisition_doy.value-1)).date()
    acquisition_doy.observe(on_doy_change)

    # Time selector (hour and minute) labelled &#34;Start Time&#34;.
    try:
        start_time_picker = widgets.TimePicker(description=&#39;Start Time:&#39;,
                                            placeholder=datetime.time(0,0,0),
                                            value=datetime.time(0,0,0),
                                            layout=widgets.Layout(width=&#39;auto&#39;))
    except Exception as e:
        start_time_picker = widgets.Text(description=&#39;Start Time:&#39;,
                                        placeholder=&#39;00:00&#39;,
                                        value=&#39;00:00&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;))

    # Time selector (hour and minute) labelled &#34;End Time&#34;. Same as Start Time otherwise.
    try:
        end_time_picker = widgets.TimePicker(description=&#39;End Time:&#39;,
                                        placeholder=datetime.time(23,59),
                                        value=datetime.time(23,59),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    except Exception as e:
        end_time_picker = widgets.Text(description=&#39;End Time:&#39;,
                                        placeholder=&#39;23:59:59.999999&#39;,
                                        value=&#39;23:59:59.999999&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;))

    tzlist = list(available_timezones())
    tzlist.sort()
    tzlist.remove(&#39;UTC&#39;)
    tzlist.remove(&#39;US/Central&#39;)
    tzlist.insert(0, &#39;US/Central&#39;)
    tzlist.insert(0, &#39;UTC&#39;)
    # A dropdown list with all the items from zoneinfo.available_timezones(), default &#39;UTC&#39;
    time_zone_dropdown = widgets.Dropdown(options=tzlist,value=get_default(sprit_hvsr.input_params, &#39;tzone&#39;),
                                            description=&#39;Time Zone:&#39;,layout=widgets.Layout(width=&#39;fill&#39;))

    instrument_grid[0,0] = acquisition_date_picker
    instrument_grid[0,1] = acquisition_doy
    instrument_grid[1,0] = start_time_picker
    instrument_grid[2,0] = end_time_picker
    instrument_grid[3,0] = time_zone_dropdown

    # LOCATION ACCORDION
    location_grid = widgets.GridspecLayout(4, 10)
    # X coordinate input
    xcoord_textbox = widgets.FloatText(description=&#39;X Coordinate:&#39;, tooltip=&#39;xcoord&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;xcoord&#39;), 
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;xcoord&#39;),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[0, 0] = xcoord_textbox

    # Y coordinate input
    ycoord_textbox = widgets.FloatText(description=&#39;Y Coordinate&#39;, tooltip=&#39;ycoord:&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;ycoord&#39;), 
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;ycoord&#39;),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[1, 0] = ycoord_textbox

    # Z coordinate input
    zcoord_textbox = widgets.FloatText(description=&#39;Z Coordinate&#39;, tooltip=&#39;elevation:&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;elevation&#39;),
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;elevation&#39;),                                     
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[2, 0] = zcoord_textbox

    # Z coordinate unit input
    elevation_unit_textbox = widgets.Dropdown(options=[(&#39;Feet&#39;, &#39;feet&#39;), (&#39;Meters&#39;, &#39;meters&#39;)],
                                                value=get_default(sprit_hvsr.input_params, &#39;elev_unit&#39;),
                                                description=&#39;Z Unit:&#39;, tooltip=&#39;elev_unit&#39;,
                                                layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[2, 1] = elevation_unit_textbox

    # Input CRS input
    input_crs_textbox = widgets.Text(description=&#39;Input CRS:&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;),
                                        placholder=get_default(sprit_hvsr.input_params, &#39;input_crs&#39;),
                                        value=get_default(sprit_hvsr.input_params, &#39;input_crs&#39;))
    location_grid[3, 0] = input_crs_textbox

    # Output CRS input
    output_crs_textbox = widgets.Text(description=&#39;Output CRS:&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;),
                                        placholder=get_default(sprit_hvsr.input_params, &#39;output_crs&#39;),
                                        value=get_default(sprit_hvsr.input_params, &#39;output_crs&#39;))
    location_grid[3, 1] = output_crs_textbox

    # IO PARAMS ACCORDION
    ioparam_grid = widgets.GridspecLayout(6, 10)

    # Data format (for obspy format to use to read in)
    data_format_dropdown = widgets.Dropdown(
            options=OBSPY_FORMATS,
            value=&#39;MSEED&#39;,
            description=&#39;Data Formats:&#39;, layout=widgets.Layout(width=&#39;auto&#39;))

    hvsr_band_min_box = widgets.FloatText(description=&#39;HVSR Band [Hz]&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                          placeholder=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[0],
                                          value=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[0])
    hvsr_band_max_box = widgets.FloatText(placeholder=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[1],
                                          value=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[1])
    hvsr_band_hbox = widgets.HBox([hvsr_band_min_box, hvsr_band_max_box],layout=widgets.Layout(width=&#39;auto&#39;))


    peak_freq_range_min_box = widgets.FloatText(description=&#39;Peak Range [Hz]&#39;,placeholder=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[0], 
                                                value=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[0],
                                                style={&#39;description_width&#39;: &#39;initial&#39;}, layout=widgets.Layout(width=&#39;auto&#39;))
    peak_freq_range_max_box = widgets.FloatText(placeholder=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[1], 
                                                value=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[1],layout=widgets.Layout(width=&#39;auto&#39;))
    peak_freq_range_hbox = widgets.HBox([peak_freq_range_min_box, peak_freq_range_max_box],layout=widgets.Layout(width=&#39;auto&#39;))


    # A dropdown labeled &#34;Detrend type&#34; with &#34;Spline&#34;, &#34;Polynomial&#34;, or &#34;None&#34;
    detrend_type_dropdown = widgets.Dropdown(options=[(&#39;Spline&#39;, &#39;spline&#39;), (&#39;Polynomial&#39;, &#39;polynomial&#39;), (&#39;None&#39;, &#39;none&#39;)],
                            description=&#39;Detrend Type:&#39;,  layout=widgets.Layout(width=&#39;auto&#39;))
    detrend_order = widgets.FloatText(description=&#39;Order:&#39;, tooltip=&#39;detrend_order&#39;, placeholder=get_default(sprit_hvsr.fetch_data, &#39;detrend_order&#39;), 
                                      value=get_default(sprit_hvsr.fetch_data, &#39;detrend_order&#39;),layout=widgets.Layout(width=&#39;auto&#39;))

    # A text to specify the trim directory
    trim_directory = widgets.Text(description=&#39;Trim Dir.:&#39;, value=&#34;None&#34;,#pathlib.Path().home().as_posix(),
                                    layout=widgets.Layout(width=&#39;auto&#39;))
    trim_export_dropdown = widgets.Dropdown(
                options=OBSPY_FORMATS,
                value=&#39;MSEED&#39;,
                description=&#39;Trim Format:&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    trim_directory_upload = widgets.FileUpload(
                            accept=&#39;&#39;, 
                            multiple=False, layout=widgets.Layout(width=&#39;auto&#39;))

    # Processing Settings
    proc_settings_text = widgets.Text(placeholder=&#39;Instrument Settings Filepath&#39;, layout=widgets.Layout(width=&#39;55%&#39;))
    proc_settings_read_button = widgets.Button(icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;4%&#39;))
    proc_settings_browse_button = widgets.Button(description=&#39;Select .proc file&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    proc_settings_hbox = widgets.HBox([proc_settings_text, proc_settings_read_button, proc_settings_browse_button])
    
    excluded_params = [&#39;hvsr_data&#39;, &#39;params&#39;, &#39;hvsr_results&#39;]
    funcList = [sprit_hvsr.fetch_data, sprit_hvsr.remove_noise,
                sprit_hvsr.generate_ppsds, sprit_hvsr.process_hvsr,
                sprit_hvsr.remove_outlier_curves, sprit_hvsr.check_peaks,
                sprit_hvsr.get_report]

    def select_proc(event):
        try:
            if event.description == &#39;Select .proc file&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                proc_files = filedialog.askopenfilenames(defaultextension=&#39;.proc&#39;, filetypes=[(&#39;PROC&#39;, &#39;.proc&#39;)],
                                                                    title=&#34;Select Processing Settings File&#34;)
                if isinstance(proc_files, tuple):
                    pass
                else:
                    proc_files = tuple(proc_files)
                root.destroy()
            else:
                proc_files = tuple([proc_settings_text.value])

            for i, proc_f in enumerate(proc_files):
                proc_settings_text.value = pathlib.Path(proc_f).as_posix()
                proc_settings = sprit_hvsr.import_settings(settings_import_path=pathlib.Path(proc_f).as_posix(), settings_import_type=&#39;processing&#39;)
                
                for func, params in proc_settings.items():
                    if func in widget_param_dict.keys():
                        for prm, val in params.items():
                            if prm in widget_param_dict[func].keys():
                                print(prm, &#39;:&#39;, widget_param_dict[func][prm],&#39; |  &#39;, val)
                                if val is None or val==&#39;None&#39;:
                                    val=&#39;none&#39;
                                if prm == &#39;export_format&#39;:
                                    val = val.upper()
                                if prm == &#39;smooth&#39;:
                                    if val is True:
                                        val = 51
                                if prm == &#39;resample&#39;:
                                    if val is True:
                                        val = 1000
                                if isinstance(widget_param_dict[func][prm], list):
                                    for i, item in enumerate(widget_param_dict[func][prm]):
                                        item.value = val[i]
                                else:
                                    widget_param_dict[func][prm].value = val
        except Exception as e:
            print(e)
            proc_settings_browse_button.disabled=True
            proc_settings_browse_button.description=&#39;Use Text Field&#39;
    
    proc_settings_read_button.on_click(select_proc)
    proc_settings_browse_button.on_click(select_proc)

    ioparam_grid[0,:] = proc_settings_hbox
    ioparam_grid[1,0] = data_format_dropdown
    ioparam_grid[2,:5] = hvsr_band_hbox
    ioparam_grid[3,:5] = peak_freq_range_hbox
    ioparam_grid[4,:1] = detrend_type_dropdown
    ioparam_grid[4,1] = detrend_order
    ioparam_grid[5,:6] = trim_directory
    ioparam_grid[5, 6:8] = trim_export_dropdown
    ioparam_grid[5, 8] = trim_directory_upload

    # PYTHON API ACCORDION
    inputAPI_grid = widgets.GridspecLayout(2, 10)
    # A text label with &#34;input_params()&#34;
    input_params_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;input_params&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    input_params_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    #input_params_call =  widgets.Label(value=&#39;input_params()&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    inputAPI_grid[0, 0] = input_params_prefix
    inputAPI_grid[0, 1:] = input_params_call

    # A text label with &#34;fetch_data()&#34;
    fetch_data_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;fetch_data&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    fetch_data_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    inputAPI_grid[1, 0] = fetch_data_prefix
    inputAPI_grid[1, 1:] = fetch_data_call

    # Set it all in place
    metaLabel = widgets.Label(&#39;Instrument&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    instLabel = widgets.Label(&#39;Acquisition&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    locLabel = widgets.Label(&#39;Location&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    ioparmLabel = widgets.Label(&#39;IO/Params&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    apiLabel = widgets.Label(&#39;API Call&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    input_accordion_label_box.children = [metaLabel, instLabel, locLabel, ioparmLabel, apiLabel]
    input_accordion_label_box.layout = widgets.Layout(align_content=&#39;space-between&#39;, width=&#39;5%&#39;)

    input_accordion.children = [metadata_grid, instrument_grid, location_grid, ioparam_grid, inputAPI_grid]
    input_accordion.titles = [&#34;Instrument Metadata&#34;, &#34;Acquisition Information&#34;, &#34;Location Information&#34;, &#34;I/O and Parameters&#34;, &#34;See Python API Call&#34;]
    input_accordion_box.layout = widgets.Layout(align_content=&#39;space-between&#39;, width=&#39;99%&#39;)
    
    input_accordion.layout = widgets.Layout(width=&#39;99%&#39;)

    # ADD THE REST OF THE WIDGETS AROUND THE ACCORDIONS
    # A text box for the site name
    site_name = widgets.Text(description=&#39;Site Name:&#39;,
                            value=&#39;HVSR_Site&#39;,
                            placeholder=&#39;HVSR_Site&#39;,
                            style={&#39;description_width&#39;: &#39;initial&#39;}, layout=widgets.Layout(width=&#39;30%&#39;))

    tenpct_spacer = widgets.Button(description=&#39;&#39;, layout=widgets.Layout(width=&#39;20%&#39;, visibility=&#39;hidden&#39;))

    # Dropdown with different source types 
    data_source_type = widgets.Dropdown(options=[(&#39;File&#39;, &#39;file&#39;), (&#39;Raw&#39;, &#39;raw&#39;), (&#39;Batch&#39;, &#39;batch&#39;), (&#39;Directory&#39;, &#39;dir&#39;)],
                                            description=&#39;Data Source type:&#39;,
                                            value=&#39;file&#39;,orientation=&#39;horizontal&#39;, 
                                            style={&#39;description_width&#39;: &#39;initial&#39;},
                                            layout=widgets.Layout(width=&#39;20%&#39;))
    def on_ds_change(event):
        if data_source_type.value == &#39;file&#39; or data_source_type.value== &#39;batch&#39;:
            browse_data_button.description = &#39;Select Files&#39;
        else:
            browse_data_button.description = &#39;Select Folders&#39;
    data_source_type.observe(on_ds_change)
    # Dropdown labeled &#34;Instrument&#34; with options &#34;Raspberry Shake&#34;, &#34;Tromino&#34;, &#34;Other&#34;
    instrument_dropdown = widgets.Dropdown(options=[&#39;Raspberry Shake&#39;, &#39;Tromino&#39;, &#39;Other&#39;],
                                        style={&#39;description_width&#39;: &#39;initial&#39;},
                                        description=&#39;Instrument:&#39;,layout=widgets.Layout(width=&#39;20%&#39;))

    # Processing Settings
    processing_settings_button = widgets.FileUpload(accept=&#39;.proc&#39;, description=&#39;Processing Settings&#39;,
                                            multiple=False,layout=widgets.Layout(width=&#39;10%&#39;))

    # Whether to show plots outside of widget
    show_plot_check =  widgets.Checkbox(description=&#39;Print Plots&#39;, value=False, disabled=False, indent=False,
                                    layout=widgets.Layout(width=&#39;10%&#39;, justify_content=&#39;flex-end&#39;))


    # Whether to print to terminal
    verbose_check = widgets.Checkbox(description=&#39;Verbose&#39;, value=False, disabled=False, indent=False,
                                    layout=widgets.Layout(width=&#39;10%&#39;, justify_content=&#39;flex-end&#39;))

    # A text box labeled Data Filepath
    data_filepath = widgets.Text(description=&#39;Data Filepath:&#39;,
                                    placeholder=&#39;sample&#39;, value=&#39;sample&#39;,
                                    style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;70%&#39;))

    # A button next to it labeled &#34;Browse&#34;
    browse_data_button = widgets.Button(description=&#39;Select Files&#39;, layout=widgets.Layout(width=&#39;10%&#39;))
    def select_datapath(event):
        try:
            root = tk.Tk()
            root.wm_attributes(&#39;-topmost&#39;, True)
            root.withdraw()
            if data_source_type.value==&#39;file&#39; or data_source_type.value==&#39;batch&#39;:
                data_filepath.value = str(filedialog.askopenfilenames(defaultextension=&#39;.MSEED&#39;, title=&#39;Select Data File&#39;))
            else:
                data_filepath.value = str(filedialog.askdirectory(mustexist=True, title=&#34;Select Data Directory&#34;))
            root.destroy()
        except Exception as e:
            print(e)
            browse_data_button.disabled=True
            browse_data_button.description=&#39;Use Text Field&#39;
    browse_data_button.on_click(select_datapath)

    # A text box labeled Metadata Filepath
    metadata_filepath = widgets.Text(description=&#39;Metadata Filepath:&#39;,
                                        style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;70%&#39;))

    # A button next to it labeled &#34;Browse&#34;
    browse_metadata_button = widgets.Button(description=&#39;Select File(s)&#39;, layout=widgets.Layout(width=&#39;10%&#39;))
    def select_metapath(event):
        try:
            root = tk.Tk()
            root.wm_attributes(&#39;-topmost&#39;, True)
            root.withdraw()
            metadata_filepath.value = str(filedialog.askopenfilenames(title=&#39;Select Metadata File(s)&#39;))
            root.destroy()
        except Exception as e:
            print(e)
            browse_metadata_button.disabled=True
            browse_metadata_button.description=&#39;Use Text Field&#39;
    browse_metadata_button.on_click(select_metapath)

    # A progress bar
    progress_bar = widgets.FloatProgress(value=0.0,min=0.0,max=1.0,
                                    bar_style=&#39;info&#39;,
                                    orientation=&#39;horizontal&#39;,layout=widgets.Layout(width=&#39;85%&#39;))

    # A dark yellow button labeled &#34;Read Data&#34;
    read_data_button = widgets.Button(description=&#39;Read Data&#39;,
                                    button_style=&#39;warning&#39;,layout=widgets.Layout(width=&#39;10%&#39;))


    # A forest green button labeled &#34;Process HVSR&#34;
    process_hvsr_button = widgets.Button(description=&#39;Run&#39;,
                                            button_style=&#39;success&#39;,layout=widgets.Layout(width=&#39;5%&#39;))

    # Update input_param call
    def update_input_param_call():
        input_param_text = f&#34;&#34;&#34;(datapath=&#39;{data_filepath.value}&#39;, metapath=&#39;{metadata_filepath.value}&#39;, site=&#39;{site_name.value}&#39;, network=&#39;{network_textbox.value}&#39;,
                    station=&#39;{station_textbox.value}&#39;, loc=&#39;{location_textbox.value}&#39;, channels={[z_channel_textbox.value, e_channel_textbox.value, n_channel_textbox.value]},
                    acq_date=&#39;{acquisition_date_picker.value}&#39;, starttime=&#39;{start_time_picker.value}&#39;, endtime=&#39;{end_time_picker.value}&#39;, tzone=&#39;{time_zone_dropdown.value}&#39;,
                    xcoord={xcoord_textbox.value}, ycoord={ycoord_textbox.value}, elevation={zcoord_textbox.value}, depth=0
                    input_crs=&#39;{input_crs_textbox.value}&#39;, output_crs=&#39;{output_crs_textbox.value}&#39;, elev_unit=&#39;{elevation_unit_textbox.value}&#39;,
                    instrument=&#39;{instrument_dropdown.value}&#39;, hvsr_band={[hvsr_band_min_box.value, hvsr_band_max_box.value]}, 
                    peak_freq_range={[peak_freq_range_min_box.value, peak_freq_range_max_box.value]}, verbose={verbose_check.value})&#34;&#34;&#34;
        input_params_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + input_param_text + &#39;&lt;/p&gt;&#39;
    update_input_param_call()
    
    # Update fetch_data call
    def update_fetch_data_call():
        fetch_data_text = f&#34;&#34;&#34;(params=hvsr_data, source={data_source_type.value}, trim_dir={trim_directory.value},
                            export_format={trim_export_dropdown.value}, detrend={detrend_type_dropdown.value}, detrend_order={detrend_order.value}, verbose={verbose_check.value})&#34;&#34;&#34;
        fetch_data_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + fetch_data_text + &#39;&lt;/p&gt;&#39;
    update_fetch_data_call()

    site_hbox = widgets.HBox()
    site_hbox.children = [site_name, tenpct_spacer, tenpct_spacer, tenpct_spacer, tenpct_spacer, tenpct_spacer, show_plot_check, verbose_check]
    datapath_hbox = widgets.HBox()
    datapath_hbox.children = [data_filepath, browse_data_button, data_source_type]
    metadata_hbox = widgets.HBox()
    metadata_hbox.children = [metadata_filepath, browse_metadata_button, instrument_dropdown]
    progress_hbox = widgets.HBox()
    progress_hbox.children = [progress_bar, read_data_button, process_hvsr_button]

    input_params_vbox = widgets.VBox()
    input_params_vbox.children = [site_hbox,datapath_hbox,metadata_hbox,progress_hbox]

    input_accordion_box.children = [input_accordion]
    #input_HBox.children = [input_accordion_label_box, input_accordion_box]
    #input_HBox.layout= widgets.Layout(align_content=&#39;space-between&#39;)

    # Create a GridBox with 12 rows and 20 columns
    input_tab = widgets.GridBox(layout=widgets.Layout(grid_template_columns=&#39;repeat(10, 1)&#39;,
                                                grid_template_rows=&#39;repeat(12, 1)&#39;))

    # Add the VBox to the GridBox
    input_tab.children = [site_hbox,
                            datapath_hbox,
                            metadata_hbox,
                            input_accordion_box,
                            progress_hbox]

    def get_input_params():
        input_params_kwargs={
            &#39;datapath&#39;:data_filepath.value,
            &#39;metapath&#39;:metadata_filepath.value,
            &#39;site&#39;:site_name.value,
            &#39;instrument&#39;:instrument_dropdown.value,
            &#39;network&#39;:network_textbox.value, &#39;station&#39;:station_textbox.value, &#39;loc&#39;:location_textbox.value, 
            &#39;channels&#39;:[z_channel_textbox.value, e_channel_textbox.value, n_channel_textbox.value],
            &#39;starttime&#39;:start_time_picker.value,
            &#39;endtime&#39;:end_time_picker.value,
            &#39;tzone&#39;:time_zone_dropdown.value,
            &#39;xcoord&#39;:xcoord_textbox.value,
            &#39;ycoord&#39;:ycoord_textbox.value,
            &#39;elevation&#39;:zcoord_textbox.value, &#39;elev_unit&#39;:elevation_unit_textbox.value,&#39;depth&#39;:0,
            &#39;input_crs&#39;:input_crs_textbox.value,&#39;output_crs&#39;:output_crs_textbox.value,
            &#39;hvsr_band&#39;:[hvsr_band_min_box.value, hvsr_band_max_box.value],
            &#39;peak_freq_range&#39;:[peak_freq_range_min_box.value, peak_freq_range_max_box.value]}
        return input_params_kwargs

    def get_fetch_data_params():
        fetch_data_kwargs = {
            &#39;source&#39;:data_source_type.value, 
            &#39;trim_dir&#39;:trim_directory.value,
            &#39;export_format&#39;:data_format_dropdown.value,
            &#39;detrend&#39;:detrend_type_dropdown.value,
            &#39;detrend_order&#39;:detrend_order.value}
        if str(fetch_data_kwargs[&#39;detrend&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;detrend&#39;] = None
        
        if str(fetch_data_kwargs[&#39;trim_dir&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;trim_dir&#39;] = None
        return fetch_data_kwargs

    def read_data(button):
        progress_bar.value = 0
        log_textArea.value += f&#34;\n\nREADING DATA [{datetime.datetime.now()}]&#34;

        ip_kwargs = get_input_params()
        hvsr_data = sprit_hvsr.input_params(**ip_kwargs, verbose=verbose_check.value)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ninput_params():\n&#39;{ip_kwargs}&#34;
        if button.description==&#39;Read Data&#39;:
            progress_bar.value=0.333
        else:
            progress_bar.value=0.1
        fd_kwargs = get_fetch_data_params()
        hvsr_data = sprit_hvsr.fetch_data(hvsr_data, **fd_kwargs, verbose=verbose_check.value)
        log_textArea.value += &#39;\n\n&#39;+str(datetime.datetime.now())+&#39;\nfetch_data():\n\t&#39;+str(fd_kwargs)
        if button.description==&#39;Read Data&#39;:
            progress_bar.value=0.666
        else:
            progress_bar.value=0.2
        
        use_hv_curve_rmse.value=False
        use_hv_curve_rmse.disabled=True

        update_preview_fig(hvsr_data, preview_fig)

        if button.description==&#39;Read Data&#39;:
            sprit_tabs.selected_index = 1
            progress_bar.value=0
        return hvsr_data
    
    read_data_button.on_click(read_data)

    def get_remove_noise_kwargs():
        def get_remove_method():
            remove_method_list=[]
            do_stalta = stalta_check.value
            do_sat_pct = max_saturation_check.value
            do_noiseWin=noisy_windows_check.value
            do_warmcool=warmcool_check.value
            
            if auto_remove_check.value:
                remove_method_list=[&#39;stalta&#39;, &#39;saturation&#39;, &#39;noise&#39;, &#39;warmcool&#39;]
            else:
                if do_stalta:
                    remove_method_list.append(&#39;stalta&#39;)
                if do_sat_pct:
                    remove_method_list.append(&#39;saturation&#39;)
                if do_noiseWin:
                    remove_method_list.append(&#39;noise&#39;)
                if do_warmcool:
                    remove_method_list.append(&#39;warmcool&#39;)
            
            if not remove_method_list:
                remove_method_list = None
            return remove_method_list
        
        remove_noise_kwargs = {&#39;remove_method&#39;:get_remove_method(),
                                &#39;sat_percent&#39;:max_saturation_pct.value, 
                                &#39;noise_percent&#39;:max_window_pct.value,
                                &#39;sta&#39;:sta.value,
                                &#39;lta&#39;:lta.value, 
                                &#39;stalta_thresh&#39;:[stalta_thresh_low.value, stalta_thresh_hi.value], 
                                &#39;warmup_time&#39;:warmup_time.value,
                                &#39;cooldown_time&#39;:cooldown_time.value,
                                &#39;min_win_size&#39;:noisy_window_length.value,
                                &#39;remove_raw_noise&#39;:raw_data_remove_check.value,
                                &#39;verbose&#39;:verbose_check.value}
        return remove_noise_kwargs

    def get_generate_ppsd_kwargs():
        ppsd_kwargs = {
            &#39;skip_on_gaps&#39;:skip_on_gaps.value,
            &#39;db_bins&#39;:[db_bins_min.value, db_bins_max.value, db_bins_step.value],
            &#39;ppsd_length&#39;:ppsd_length.value,
            &#39;overlap&#39;:overlap_pct.value,
            &#39;special_handling&#39;:special_handling_dropdown.value,
            &#39;period_smoothing_width_octaves&#39;:period_smoothing_width.value,
            &#39;period_step_octaves&#39;:period_step_octave.value,
            &#39;period_limits&#39;:[period_limits_min.value, period_limits_max.value],
            &#39;verbose&#39;:verbose_check.value
            }

        if str(ppsd_kwargs[&#39;special_handling&#39;]).lower() == &#39;none&#39;:
            ppsd_kwargs[&#39;special_handling&#39;] = None        
        return ppsd_kwargs

    def get_remove_outlier_curve_kwargs():
        roc_kwargs = {
                &#39;use_percentile&#39;:rmse_pctile_check.value,
                &#39;rmse_thresh&#39;:rmse_thresh.value,
                &#39;use_hv_curve&#39;:False,
                &#39;verbose&#39;:verbose_check.value
            }
        return roc_kwargs

    def get_process_hvsr_kwargs():
        if smooth_hv_curve_bool.value:
            smooth_value = smooth_hv_curve.value
        else:
            smooth_value = smooth_hv_curve_bool.value

        if resample_hv_curve_bool.value:
            resample_value = resample_hv_curve.value
        else:
            resample_value = resample_hv_curve_bool.value

        ph_kwargs={&#39;method&#39;:h_combine_meth.value,
                    &#39;smooth&#39;:smooth_value,
                    &#39;freq_smooth&#39;:freq_smoothing.value,
                    &#39;f_smooth_width&#39;:freq_smooth_width.value,
                    &#39;resample&#39;:resample_value,
                    &#39;outlier_curve_rmse_percentile&#39;:use_hv_curve_rmse.value,
                    &#39;verbose&#39;:verbose_check.value}
        return ph_kwargs

    def get_check_peaks_kwargs():
        cp_kwargs = {&#39;hvsr_band&#39;:[hvsr_band_min_box.value, hvsr_band_max_box.value],
                    &#39;peak_freq_range&#39;:[peak_freq_range_min_box.value, peak_freq_range_max_box.value],
                    &#39;peak_selection&#39;:peak_selection_type.value,
                    &#39;verbose&#39;:verbose_check.value}
        return cp_kwargs

    def get_get_report_kwargs():
        def get_formatted_plot_str():
            # Initialize plot string
            hvsr_plot_str = &#39;&#39;
            comp_plot_str = &#39;&#39;
            spec_plot_str = &#39;&#39;

            # Whether to use each plot
            if use_plot_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34;HVSR&#34;
            if use_plot_comp.value:
                comp_plot_str=comp_plot_str + &#34;C&#34;
            if use_plot_spec.value:
                spec_plot_str=spec_plot_str + &#34;SPEC&#34;

            # Whether components be on the same plot as HV curve?
            if not combine_hv_comp.value:
                comp_plot_str=comp_plot_str + &#34;+&#34;
            else:
                comp_plot_str=comp_plot_str.replace(&#39;+&#39;,&#39;&#39;)

            # Whether to show (log) standard deviations
            if not show_std_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; -s&#34;
            if not show_std_comp.value:
                comp_plot_str=comp_plot_str + &#34; -s&#34;                

            # Whether to show all peaks
            if show_all_peaks_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; all&#34;

            # Whether curves from each time window are shown
            if show_all_curves_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; t&#34;
            if show_all_curves_comp.value:
                comp_plot_str=comp_plot_str + &#34; t&#34;

            # Whether the best peak is displayed
            if show_best_peak_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; p&#34;
            if show_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; p&#34;
            if show_best_peak_spec.value:
                spec_plot_str=spec_plot_str + &#34; p&#34;

            # Whether best peak value is annotated
            if ann_best_peak_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; ann&#34;
            if ann_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; ann&#34;
            if ann_best_peak_spec.value:
                spec_plot_str=spec_plot_str + &#34; ann&#34;

            # Whether peaks from individual time windows are shown
            if show_ind_peaks_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; tp&#34;
            if show_ind_peaks_spec.value:
                spec_plot_str=spec_plot_str + &#39; tp&#39;
            
            # Whether to show legend
            if show_legend_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; leg&#34;
            if ann_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; leg&#34;
            if show_legend_spec.value:
                spec_plot_str=spec_plot_str + &#34; leg&#34;            

            # Combine string into one
            plot_str = hvsr_plot_str + &#39; &#39; + comp_plot_str+ &#39; &#39; + spec_plot_str
            return plot_str

        gr_kwargs = {&#39;report_format&#39;:[&#39;print&#39;,&#39;csv&#39;],
                     &#39;plot_type&#39;:get_formatted_plot_str(),
                     &#39;export_path&#39;:None,
                     &#39;csv_overwrite_opt&#39;:&#39;overwrite&#39;,
                     &#39;no_output&#39;:False,
                    &#39;verbose&#39;:verbose_check.value
                     }
        return gr_kwargs

    def process_data(button):
        startProc=datetime.datetime.now()
        progress_bar.value = 0
        log_textArea.value += f&#34;\n\nPROCESSING DATA [{startProc}]&#34;
        global hvsr_data
        # Read data again only if internal hvsr_data datapath variable is different from what is in the gui
        if not &#39;hvsr_data&#39; in globals() or not hasattr(hvsr_data, &#39;datapath&#39;) or \
                (pathlib.Path(hvsr_data.datapath).as_posix() != pathlib.Path(data_filepath.value).as_posix()):
            hvsr_data = read_data(button)

        remove_noise_kwargs = get_remove_noise_kwargs()
        hvsr_data = sprit_hvsr.remove_noise(hvsr_data, **remove_noise_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_noise()\n\t{remove_noise_kwargs}&#34;
        progress_bar.value = 0.3

        generate_ppsd_kwargs = get_generate_ppsd_kwargs()
        hvsr_data = sprit_hvsr.generate_ppsds(hvsr_data, **generate_ppsd_kwargs)
        progress_bar.value = 0.5
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ngenerate_ppsds()\n\t{generate_ppsd_kwargs}&#34;
        
       
        # If this was started by clicking &#34;Generate PPSDs&#34;, stop here
        if button.description == &#39;Generate PPSDs&#39;:
            return

        ph_kwargs = get_process_hvsr_kwargs()
        hvsr_data = sprit_hvsr.process_hvsr(hvsr_data, **ph_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nprocess_hvsr()\n\t{ph_kwargs}&#34;
        progress_bar.value = 0.75
        update_outlier_fig()

        roc_kwargs = get_remove_outlier_curve_kwargs()
        hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves()\n\t{roc_kwargs}&#34;
        progress_bar.value = 0.85
        outlier_fig, hvsr_data = update_outlier_fig()

        use_hv_curve_rmse.value=False
        use_hv_curve_rmse.disabled=False

        def get_rmse_range():
            minRMSE = 10000
            maxRMSE = -1
            if roc_kwargs[&#39;use_hv_curve&#39;]:
                colnames = [&#39;HV_Curves&#39;]
            else:
                colnames = [&#39;psd_values_Z&#39;,
                            &#39;psd_values_E&#39;,
                            &#39;psd_values_N&#39;]
            dataList = []
            for col in colnames:
                dataArr = np.stack(hvsr_data.hvsr_df[col])
                medCurveArr = np.nanmedian(dataArr, axis=0)
                rmse = np.sqrt(((np.subtract(dataArr, medCurveArr)**2).sum(axis=1))/dataArr.shape[1])
                if rmse.min() &lt; minRMSE:
                    minRMSE = rmse.min()
                if rmse.max() &gt; maxRMSE:
                    maxRMSE = rmse.max()
            rmse_thresh_slider.min = minRMSE
            rmse_thresh_slider.max = maxRMSE
            rmse_thresh_slider.step = round((maxRMSE-minRMSE)/100, 2)
            rmse_thresh_slider.value = maxRMSE
        get_rmse_range()

        cp_kwargs = get_check_peaks_kwargs()
        hvsr_data = sprit_hvsr.check_peaks(hvsr_data, **cp_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ncheck_peaks()\n\t{cp_kwargs}&#34;
        progress_bar.value = 0.9

        gr_kwargs = get_get_report_kwargs()
        hvsr_data = sprit_hvsr.get_report(hvsr_data, **gr_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nget_report()\n\t{gr_kwargs}\n\n&#34;
        hvsr_data.get_report(report_format=&#39;print&#39;) # Just in case print wasn&#39;t included
        log_textArea.value += hvsr_data[&#39;Print_Report&#39;]
        printed_results_textArea.value = hvsr_data[&#39;Print_Report&#39;]
        hvsr_data.get_report(report_format=&#39;csv&#39;) 
        results_table.value = hvsr_data[&#39;CSV_Report&#39;].to_html()
        
        log_textArea.value += f&#39;Processing time: {datetime.datetime.now() - startProc}&#39;
        progress_bar.value = 0.95

        update_results_fig(hvsr_data, gr_kwargs[&#39;plot_type&#39;])
        
        progress_bar.value = 1
        global hvsr_results
        hvsr_results = hvsr_data
        return hvsr_results
        
    def parse_plot_string(plot_string):
        plot_list = plot_string.split()

        hvsrList = [&#39;hvsr&#39;, &#39;hv&#39;, &#39;h&#39;]
        compList = [&#39;component&#39;, &#39;comp&#39;, &#39;c&#39;]
        compPlus = [item + &#39;+&#39; for item in compList]
        specList = [&#39;spectrogram&#39;, &#39;specgram&#39;, &#39;spec&#39;,&#39;sg&#39;, &#39;s&#39;]

        hvInd = np.nan
        compInd = np.nan
        specInd = np.nan

        hvIndFound = False
        compIndFound = False
        specIndFound = False

        for i, item in enumerate(plot_list):
            if item.lower() in hvsrList and not hvIndFound:
                # assign the index
                hvInd = i
                hvIndFound = True
            if (item.lower() in compList or item.lower() in compPlus) and not compIndFound:
                # assign the index
                compInd = i
                compIndFound = True
            if item.lower() in specList and not specIndFound:
                # assign the index
                specInd = i
                specIndFound = True

        # Get individual plot lists (should already be correctly ordered)
        if hvInd is np.nan:
            hvsr_plot_list = [&#39;HVSR&#39;]

        if compInd is np.nan:
            comp_plot_list = []
            if specInd is np.nan:
                if hvInd is not np.nan:
                    hvsr_plot_list = plot_list
                spec_plot_list = []
            else:
                if hvInd is not np.nan:
                    hvsr_plot_list = plot_list[hvInd:specInd]
                spec_plot_list = plot_list[specInd:]
        else:
            if hvInd is not np.nan:
                hvsr_plot_list = plot_list[hvInd:compInd]
            
            if specInd is np.nan:
                comp_plot_list = plot_list[compInd:]
                spec_plot_list = []
            else:
                comp_plot_list = plot_list[compInd:specInd]
                spec_plot_list = plot_list[specInd:]

        # Figure out how many subplots there will be
        plot_list_list = [hvsr_plot_list, comp_plot_list, spec_plot_list]

        return plot_list_list

    def parse_hv_plot_list(hv_data, hvsr_plot_list):
        hvsr_data = hv_data
        x_data = hvsr_data.x_freqs[&#39;Z&#39;]
        hvsrDF = hvsr_data.hvsr_df

        if &#39;tp&#39; in hvsr_plot_list:
            allpeaks = []
            for row in hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;CurvesPeakFreqs&#39;].values:
                for peak in row:
                    allpeaks.append(peak)
            allInd = []
            for row, peakList in enumerate(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;CurvesPeakIndices&#39;].values):
                for ind in peakList:
                    allInd.append((row, ind))
            x_vals = []
            y_vals = []
            y_max = np.nanmax(hvsr_data.hvsrp)
            hvCurveInd = list(hvsrDF.columns).index(&#39;HV_Curves&#39;)
            for i, tp in enumerate(allpeaks):
                x_vals.extend([tp, tp, None]) # add two x values and a None
                y_vals.extend([0, hvsrDF.iloc[allInd[i][0], hvCurveInd][allInd[i][1]], None]) # add the first and last y values and a None            

            results_fig.add_trace(go.Scatter(x=x_vals, y=y_vals, mode=&#39;lines&#39;,
                                            line=dict(width=4, dash=&#34;solid&#34;, 
                                            color=&#34;rgba(128,0,0,0.1)&#34;), 
                                            name=&#39;Best Peaks Over Time&#39;),
                                            row=1, col=1)

        if &#39;t&#39; in hvsr_plot_list:
            alltimecurves = np.stack(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;HV_Curves&#39;])
            for i, row in enumerate(alltimecurves):
                if i==0:
                    showLeg = True
                else:
                    showLeg= False
                results_fig.add_trace(go.Scatter(x=x_data[:-1], y=row, mode=&#39;lines&#39;,
                                            line=dict(width=0.5, dash=&#34;solid&#34;, 
                                            color=&#34;rgba(100, 110, 100, 0.8)&#34;), 
                                            showlegend=showLeg, 
                                            name=&#39;Ind. time win. curve&#39;, 
                                            hoverinfo=&#39;none&#39;),
                                            row=1, col=1)

        if &#39;all&#39; in hvsr_plot_list:
            for i, p in enumerate(hvsr_data[&#39;hvsr_peak_freqs&#39;]):
                if i==0:
                    showLeg = True
                else:
                    showLeg= False

                results_fig.add_trace(go.Scatter(
                    x=[p, p, None], # set x to None
                    y=[0, np.nanmax(np.stack(hvsrDF[&#39;HV_Curves&#39;])),None], # set y to None
                    mode=&#34;lines&#34;, # set mode to lines
                    line=dict(width=1, dash=&#34;dot&#34;, color=&#34;gray&#34;), # set line properties
                    name=&#34;All checked peaks&#34;, # set legend name
                    showlegend=showLeg),
                    row=1, col=1)

        if &#39;-s&#39; not in hvsr_plot_list:
            # Show standard deviation
            results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.hvsrp2,
                                    line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.1},marker=None, 
                                    showlegend=False, name=&#39;Log. St.Dev. Upper&#39;,
                                    hoverinfo=&#39;none&#39;),
                                    row=1, col=1)
            
            results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.hvsrm2,
                                    line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.1},marker=None,
                                    fill=&#39;tonexty&#39;, fillcolor=&#34;rgba(128, 128, 128, 0.6)&#34;,
                                    name=&#39;Log. St.Dev.&#39;, hoverinfo=&#39;none&#39;),
                                    row=1, col=1)
                
        if &#39;p&#39; in hvsr_plot_list:
            results_fig.add_trace(go.Scatter(
                x=[hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], None], # set x to None
                y=[0,np.nanmax(np.stack(hvsrDF[&#39;HV_Curves&#39;])),None], # set y to None
                mode=&#34;lines&#34;, # set mode to lines
                line=dict(width=1, dash=&#34;dash&#34;, color=&#34;black&#34;), # set line properties
                name=&#34;Best Peak&#34;),
                row=1, col=1)

        if &#39;ann&#39; in hvsr_plot_list:
            # Annotate best peak
            results_fig.add_annotation(x=np.log10(hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]),
                                    y=0, yanchor=&#39;bottom&#39;, xanchor=&#39;center&#39;,
                                    text=f&#34;{hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                                    bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                                    showarrow=False,
                                    row=1, col=1)
        return results_fig

    def parse_comp_plot_list(hv_data, comp_plot_list):
        
        hvsr_data = hv_data
        # Initial setup
        x_data = hvsr_data.x_freqs[&#39;Z&#39;]
        hvsrDF = hvsr_data.hvsr_df
        same_plot = ((comp_plot_list != []) and (&#39;+&#39; not in comp_plot_list[0]))

        if same_plot:
            yaxis_to_use = &#39;y2&#39;
            use_secondary = True
            transparency_modifier = 0.5
        else:
            yaxis_to_use = &#39;y&#39;
            use_secondary=False
            transparency_modifier = 1

        alpha = 0.4 * transparency_modifier
        components = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
        compColor_semi_light = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;,
                    &#39;E&#39;:f&#39;rgba(0,0,128,{alpha})&#39;,
                    &#39;N&#39;:f&#39;rgba(128,0,0,{alpha})&#39;}

        alpha = 0.7 * transparency_modifier
        compColor_semi = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;, 
                        &#39;E&#39;:f&#39;rgba(100,100,128,{alpha})&#39;, 
                        &#39;N&#39;:f&#39;rgba(128,100,100,{alpha})&#39;}

        compColor = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;, 
                    &#39;E&#39;:f&#39;rgba(100,100,250,{alpha})&#39;, 
                    &#39;N&#39;:f&#39;rgba(250,100,100,{alpha})&#39;}

        # Whether to plot in new subplot or not
        if  comp_plot_list != [] and &#39;+&#39; in comp_plot_list[0]:
            compRow=2
        else:
            compRow=1

        # Whether to plot individual time curves
        if &#39;t&#39; in comp_plot_list:
            for comp in components:
                alltimecurves = np.stack(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;psd_values_&#39;+comp])
                for i, row in enumerate(alltimecurves):
                    if i==0:
                        showLeg = True
                    else:
                        showLeg= False
                    
                    results_fig.add_trace(go.Scatter(x=x_data[:-1], y=row, mode=&#39;lines&#39;,
                                    line=dict(width=0.5, dash=&#34;solid&#34;, 
                                    color=compColor_semi[comp]),
                                    name=&#39;Ind. time win. curve&#39;,
                                    showlegend=False,
                                    hoverinfo=&#39;none&#39;,
                                    yaxis=yaxis_to_use),
                                    secondary_y=use_secondary,
                                    row=compRow, col=1)

        # Code to plot standard deviation windows, if not removed
        if &#39;-s&#39; not in comp_plot_list:
            for comp in components:
                # Show standard deviation
                results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.ppsd_std_vals_p[comp],
                                        line={&#39;color&#39;:compColor_semi_light[comp], &#39;width&#39;:0.1},marker=None, 
                                        showlegend=False, name=&#39;Log. St.Dev. Upper&#39;,
                                        hoverinfo=&#39;none&#39;,    
                                        yaxis=yaxis_to_use),
                                        secondary_y=use_secondary,
                                        row=compRow, col=1)
                
                results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.ppsd_std_vals_m[comp],
                                        line={&#39;color&#39;:compColor_semi_light[comp], &#39;width&#39;:0.1},marker=None,
                                        fill=&#39;tonexty&#39;, fillcolor=compColor_semi_light[comp],
                                        name=f&#39;St.Dev. [{comp}]&#39;, hoverinfo=&#39;none&#39;, showlegend=False, 
                                        yaxis=yaxis_to_use),
                                        secondary_y=use_secondary,
                                        row=compRow, col=1)
                
        # Code to plot location of best peak
        if &#39;p&#39; in comp_plot_list:
            minVal = 10000
            maxVal = -10000
            for comp in components:
                currPPSDCurve = hvsr_data[&#39;psd_values_tavg&#39;][comp]
                if np.nanmin(currPPSDCurve) &lt; minVal:
                    minVal = np.nanmin(currPPSDCurve)
                if np.nanmax(currPPSDCurve) &gt; maxVal:
                    maxVal = np.nanmax(currPPSDCurve)

            results_fig.add_trace(go.Scatter(
                x=[hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], None], # set x to None
                y=[minVal,maxVal,None], # set y to None
                mode=&#34;lines&#34;, # set mode to lines
                line=dict(width=1, dash=&#34;dash&#34;, color=&#34;black&#34;), # set line properties
                name=&#34;Best Peak&#34;,
                yaxis=yaxis_to_use),
                secondary_y=use_secondary,
                row=compRow, col=1)
            
        # Code to annotate value of best peak
        if &#39;ann&#39; in comp_plot_list:
            minVal = 10000
            for comp in components:
                currPPSDCurve = hvsr_data[&#39;psd_values_tavg&#39;][comp]
                if np.nanmin(currPPSDCurve) &lt; minVal:
                    minVal = np.nanmin(currPPSDCurve)
            results_fig.add_annotation(x=np.log10(hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]),
                            y=minVal,
                            text=f&#34;{hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                            bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                            showarrow=False,
                            yref=yaxis_to_use,
                            secondary_y=use_secondary,
                            row=compRow, col=1)

        # Plot the main averaged component PPSDs
        for comp in components:
            results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[comp],
                                            y=hvsr_data[&#39;psd_values_tavg&#39;][comp],
                                            line=dict(width=2, dash=&#34;solid&#34;, 
                                            color=compColor[comp]),marker=None, 
                                            name=&#39;PPSD Curve &#39;+comp,    
                                            yaxis=yaxis_to_use), 
                                            secondary_y=use_secondary,
                                            row=compRow, col=&#39;all&#39;)

        # If new subplot, update accordingly
        if compRow==2:
            results_fig.update_xaxes(type=&#39;log&#39;,
                            range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                            row=compRow, col=1)
        return results_fig

    def parse_spec_plot_list(hv_data, spec_plot_list, subplot_num):
        hvsr_data = hv_data
        # Initial setup
        hvsrDF = hvsr_data.hvsr_df
        specAxisTimes = np.array([dt.isoformat() for dt in hvsrDF.index.to_pydatetime()])
        y_data = hvsr_data.x_freqs[&#39;Z&#39;][1:]
        image_data = np.stack(hvsrDF[&#39;HV_Curves&#39;]).T

        maxZ = np.percentile(image_data, 100)
        minZ = np.percentile(image_data, 0)

        use_mask = hvsr_data.hvsr_df.Use.values
        use_mask = np.tile(use_mask, (image_data.shape[0],1))
        use_mask = np.where(use_mask is False, np.nan, use_mask)

        hmap = go.Heatmap(z=image_data,
                    x=specAxisTimes,
                    y=y_data,
                    colorscale=&#39;Turbo&#39;,
                    showlegend=False,
                    #opacity=0.7,
                    hovertemplate=&#39;Time [UTC]: %{x}&lt;br&gt;Frequency [Hz]: %{y:.2f}&lt;br&gt;H/V Amplitude: %{z:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    zmin=minZ,zmax=maxZ, showscale=False, name=&#39;HV Curve Amp. over Time&#39;)
        results_fig.add_trace(hmap, row=subplot_num, col=1)

        data_used = go.Heatmap(
            x=specAxisTimes,
            y=y_data,
            z=use_mask,
            showlegend=False,
            colorscale=[[0, &#39;rgba(0,0,0,0.66)&#39;], [0.25, &#39;rgba(0,0,0,0.66)&#39;], [1, &#39;rgba(250,250,250,0)&#39;]],
            showscale=False, name=&#39;Used&#39;)
        results_fig.add_trace(data_used, row=subplot_num, col=1)


        # tp currently is not being added to spec_plot_list
        if &#39;tp&#39; in spec_plot_list:
            yvals = []
            for row in hvsrDF[&#39;HV_Curves&#39;].values:
                maxInd = np.argmax(row)
                yvals.append(y_data[maxInd])
            tp_trace = go.Scatter(x=specAxisTimes, y=yvals, mode=&#39;markers&#39;,
                                    line=None, marker=dict(color=&#39;white&#39;, size=2, line=dict(color=&#39;black&#39;, width=0.1)), name=&#39;Individual H/V Peaks&#39;)
            results_fig.add_trace(tp_trace, row=subplot_num, col=&#39;all&#39;)

        if &#39;p&#39; in spec_plot_list:
            results_fig.add_hline(y=hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], line_width=1, line_dash=&#39;dash&#39;, line_color=&#39;black&#39;, row=subplot_num, col=&#39;all&#39;)

        if &#39;ann&#39; in spec_plot_list:
            results_fig.add_annotation(x=specAxisTimes[-1],
                                    y=hvsr_data[&#39;hvsr_band&#39;][1],
                                    text=f&#34;Peak: {hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                                    bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                                    showarrow=False, xanchor=&#39;right&#39;, yanchor=&#39;top&#39;,
                                    row=subplot_num, col=&#39;all&#39;)

        if &#39;leg&#39; in spec_plot_list:
            pass

        results_fig.update_yaxes(type=&#39;log&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        row=subplot_num, col=1)

        results_fig.add_annotation(
            text=f&#34;{hvsrDF[&#39;Use&#39;].sum()}/{hvsrDF.shape[0]} windows used&#34;,
            x=max(specAxisTimes),
            y=np.log10(min(y_data))+(np.log10(max(y_data))-np.log10(min(y_data)))*0.01,
            xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
            showarrow=False,row=subplot_num, col=1)

        return results_fig

    def update_results_fig(hv_data, plot_string):
        global results_fig
        global results_subp
        hvsr_data = hv_data

        if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
            hvsr_data=hvsr_data[0]

        hvsrDF = hvsr_data.hvsr_df

        plot_list = parse_plot_string(plot_string)

        combinedComp=False
        noSubplots = 3 - plot_list.count([])
        if plot_list[1] != [] and &#39;+&#39; not in plot_list[1][0]:
            combinedComp = True
            noSubplots -= 1
        
        # Get all data for each plotted item
        # COMP Plot
        # Figure out which subplot is which
        if combinedComp:
            comp_plot_row = 1
            spec_plot_row = 2
        else:
            comp_plot_row = 2
            spec_plot_row = 3

        # Re-initialize results_fig
        results_fig.data = []
        results_fig.update_layout(grid=None)  # Clear the existing grid layout
        if not combinedComp: 
            results_subp = subplots.make_subplots(rows=3, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                                row_heights=[2, 1.5, 1])
        else:
            results_subp = subplots.make_subplots(rows=2, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                    specs =[[{&#39;secondary_y&#39;: True}],
                                            [{&#39;secondary_y&#39;: False}]],
                                            row_heights=[1, 1])
        results_fig.update_layout(grid={&#39;rows&#39;: noSubplots})
        #del results_fig
        results_fig = go.FigureWidget(results_subp)

        results_fig = parse_comp_plot_list(hvsr_data, comp_plot_list=plot_list[1])

        # HVSR Plot (plot this after COMP so it is on top COMP and to prevent deletion with no C+)
        results_fig = parse_hv_plot_list(hvsr_data, hvsr_plot_list=plot_list[0])
        # Will always plot the HV Curve
        results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[&#39;Z&#39;],y=hvsr_data.hvsr_curve,
                            line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:1.5},marker=None, name=&#39;HVSR Curve&#39;),
                            row=1, col=&#39;all&#39;)

        # SPEC plot
        results_fig = parse_spec_plot_list(hvsr_data, spec_plot_list=plot_list[2], subplot_num=spec_plot_row)

        # Final figure updating
        showtickLabels = (plot_list[1]==[] or &#39;+&#39; not in plot_list[1][0])
        if showtickLabels:
            side=&#39;bottom&#39;
        else:
            side=&#39;top&#39;
        results_fig.update_xaxes(type=&#39;log&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        side=&#39;top&#39;,
                        row=1, col=1)
        
        results_fig.update_xaxes(type=&#39;log&#39;,overlaying=&#39;x&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        side=&#39;bottom&#39;,
                        row=1, col=1)
        if comp_plot_row!=1:
            results_fig.update_xaxes(showticklabels=showtickLabels, row=comp_plot_row, col=1)
        
        if preview_fig.layout.width is None:
            if outlier_fig.layout.width is None:
                chartwidth = 800
            else:
                chartwidth = outlier_fig.layout.width

        else:
            chartwidth = preview_fig.layout.width

        results_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:35, &#39;b&#39;:0},
                                showlegend=False, autosize=True, height = 1.2 * float(chartwidth),
                                title=f&#34;{hvsr_data[&#39;site&#39;]} Results&#34;)
        results_fig.update_yaxes(title_text=&#39;H/V Ratio&#39;, row=1, col=1)
        results_fig.update_yaxes(title_text=&#39;H/V Over Time&#39;, row=noSubplots, col=1)
        if comp_plot_row==1:
            results_fig.update_yaxes(title_text=&#34;PPSD Amp\n[m2/s4/Hz][dB]&#34;, secondary_y=True, row=comp_plot_row, col=1)
        else:
            results_fig.update_yaxes(title_text=&#34;PPSD Amp\n[m2/s4/Hz][dB]&#34;, row=comp_plot_row, col=1)
        
        # Reset results_graph_widget and display 
        with results_graph_widget:
            clear_output(wait=True)
            display(results_fig)

        if show_plot_check.value:
            results_fig.show()


        sprit_tabs.selected_index = 4
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nResults Figure Updated: {plot_string}&#34;
      
    process_hvsr_button.on_click(process_data)

    # PREVIEW TAB
    #Initialize plot
    preview_subp = subplots.make_subplots(rows=4, cols=1, shared_xaxes=True, horizontal_spacing=0.01, vertical_spacing=0.01, row_heights=[3,1,1,1])
    preview_fig = go.FigureWidget(preview_subp)

    def update_preview_fig(hv_data, preview_fig):
        preview_fig.data = []
        
        hvsr_data = hv_data
        if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
            hvsr_data=hvsr_data[0]

        stream_z = hvsr_data[&#39;stream&#39;].select(component=&#39;Z&#39;) #may be np.ma.masked_array
        stream_e = hvsr_data[&#39;stream&#39;].select(component=&#39;E&#39;) #may be np.ma.masked_array
        stream_n = hvsr_data[&#39;stream&#39;].select(component=&#39;N&#39;) #may be np.ma.masked_array

        # Get iso_times and datetime.datetime
        utcdt = stream_z[0].times(type=&#39;utcdatetime&#39;)
        iso_times=[]
        dt_times = []
        for t in utcdt:
            if t is not np.ma.masked:
                iso_times.append(t.isoformat())
                dt_times.append(datetime.datetime.fromisoformat(t.isoformat()))
            else:
                iso_times.append(np.nan)
        iso_times=np.array(iso_times)
        dt_times = np.array (dt_times)

        # Generate spectrogram
        f, t, Sxx = signal.spectrogram(x=stream_z[0].data, fs=stream_z[0].stats.sampling_rate, mode=&#39;magnitude&#39;)
        
        # Get times for the axis (one time per window)
        axisTimes = []
        for tpass in t:
            axisTimes.append((dt_times[0]+datetime.timedelta(seconds=tpass)).isoformat())

        # Add data to preview_fig
        # Add spectrogram of Z component
        minz = np.percentile(Sxx, 1)
        maxz = np.percentile(Sxx, 99)
        hmap = go.Heatmap(z=Sxx,
                    x=axisTimes,
                    y=f,
                    colorscale=&#39;Turbo&#39;,
                    showlegend=False,
                    hovertemplate=&#39;Time [UTC]: %{x}&lt;br&gt;Frequency [Hz]: %{y:.2f}&lt;br&gt;Spectrogram Magnitude: %{z:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    zmin=minz, zmax=maxz, showscale=False, name=&#39;Z Component Spectrogram&#39;)
        preview_fig.add_trace(hmap, row=1, col=1)
        preview_fig.update_yaxes(type=&#39;log&#39;, range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])], row=1, col=1)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;Spectrogram (Z)&#39;}, row=1, col=1)

        # Add raw traces
        dec_factor=5 #This just makes the plotting go faster, by &#34;decimating&#34; the data
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_z[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;Z component data&#39;), row=2, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=2, col=1)
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_e[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;blue&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;E component data&#39;),row=3, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=3, col=1)
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_n[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;red&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;N component data&#39;), row=4, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=4, col=1)
        
        #preview_fig.add_trace(p)
        preview_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=False,
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Data Preview&#34;)

        if show_plot_check.value:
            preview_fig.show()

    # REMOVE NOISE SUBTAB
    # STA/LTA Antitrigger
    stalta_check = widgets.Checkbox(value=False, disabled=False, indent=False, description=&#39;STA/LTA Antitrigger&#39;)
    sta = widgets.FloatText(description=&#39;STA [s]&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=5, value=5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    lta = widgets.FloatText(description=&#39;LTA [s]&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=30, value=30,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    stalta_thresh_low = widgets.FloatText(description=&#39;STA/LTA Thresholds (low, high)&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.5, value=0.5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    stalta_thresh_hi = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=5, value=5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #% Saturation Threshold
    max_saturation_check = widgets.Checkbox(description=&#39;Percentage Threshold (Instantaneous)&#39;, value=False, disabled=False, indent=False)
    max_saturation_pct = widgets.FloatText(description=&#39;Max Saturation %:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.995, value=0.995,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #Noise Windows
    noisy_windows_check = widgets.Checkbox(description=&#39;Noisy Windows&#39;, value=False, disabled=False, indent=False)
    max_window_pct = widgets.FloatText(description=&#39;Max Window %:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.8, value=0.8,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    noisy_window_length = widgets.FloatText(description=&#39;Window Length [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=30, value=30,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #Warmup/cooldown
    warmcool_check = widgets.Checkbox(description=&#39;Warmup &amp; Cooldown Time&#39;, value=False, disabled=False, indent=False)
    warmup_time = widgets.FloatText(description=&#39;Warmup time [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    cooldown_time = widgets.FloatText(description=&#39;Cooldown time [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #STD Ratio
    std_ratio_check = widgets.Checkbox(description=&#39;Standard Deviation Antitrigger (not yet implemented)&#39;, value=False, disabled=True, indent=False)
    std_ratio_text = widgets.FloatText(description=&#39;StdDev Ratio:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=True)
    std_window_length_text = widgets.FloatText(description=&#39;Moving window Length [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),disabled=True)

    #Autoremove
    auto_remove_check = widgets.Checkbox(description=&#39;Use Auto Remove&#39;, value=False, disabled=False, indent=False)

    #Remove from raw data
    raw_data_remove_check = widgets.Checkbox(description=&#39;Remove Noise From Raw Data&#39;, value=False, disabled=False, indent=False)

    #remove_noise call
    remove_noise_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;remove_noise&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    remove_noise_call = widgets.HTML(value=&#39;()&#39;)
    remove_noise_call_hbox = widgets.HBox([remove_noise_prefix, remove_noise_call])

    # Update remove_outlier call
    def update_remove_noise_call():
        rnkwargs = get_remove_noise_kwargs()
        rn_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, remove_method={rnkwargs[&#39;remove_method&#39;]}, 
                    sat_percent={rnkwargs[&#39;sat_percent&#39;]}, 
                    noise_percent={rnkwargs[&#39;noise_percent&#39;]}, 
                    sta={rnkwargs[&#39;sta&#39;]}, 
                    lta={rnkwargs[&#39;lta&#39;]}, 
                    stalta_thresh={rnkwargs[&#39;stalta_thresh&#39;]}, 
                    warmup_time={rnkwargs[&#39;warmup_time&#39;]}, 
                    cooldown_time={rnkwargs[&#39;cooldown_time&#39;]}, 
                    min_win_size={rnkwargs[&#39;min_win_size&#39;]}, 
                    remove_raw_noise={rnkwargs[&#39;remove_raw_noise&#39;]}, 
                    verbose={verbose_check.value})&#34;&#34;&#34;
        remove_noise_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + rn_text + &#39;&lt;/p&gt;&#39;
    update_remove_noise_call()

    #Update noise windows
    update_noise_windows_button = widgets.Button(description=&#39;Update Noise Windows&#39;,button_style=&#39;info&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=True)

    preview_graph_widget = widgets.Output()
    #progress bar (same as above)
    preview_progress_hbox = widgets.HBox(children=[progress_bar, update_noise_windows_button, process_hvsr_button])

    # Add it all in to the tab
    stalta_hbox = widgets.HBox([stalta_check, sta, lta, stalta_thresh_low, stalta_thresh_hi])
    sat_hbox = widgets.HBox([max_saturation_check, max_saturation_pct])
    noise_win_hbox = widgets.HBox([noisy_windows_check, max_window_pct, noisy_window_length])
    warmcool_hbox = widgets.HBox([warmcool_check, warmup_time, cooldown_time])
    std_ratio_hbox = widgets.HBox([std_ratio_check, std_ratio_text, std_window_length_text])
    spacer_hbox = widgets.HBox([tenpct_spacer])

    preview_noise_tab = widgets.VBox([stalta_hbox,
                                      sat_hbox,
                                      noise_win_hbox,
                                      warmcool_hbox,
                                      std_ratio_hbox,
                                      auto_remove_check,
                                      raw_data_remove_check,
                                      spacer_hbox,
                                      remove_noise_call_hbox])

    preview_graph_tab = widgets.VBox(children=[preview_graph_widget])
    preview_subtabs = widgets.Tab([preview_graph_tab, preview_noise_tab])
    preview_tab = widgets.VBox()

    preview_subtabs.set_title(0, &#34;Data Preview&#34;)
    preview_subtabs.set_title(1, &#34;Noise Removal&#34;)

    preview_tab.children = [preview_subtabs, preview_progress_hbox]
    # Initialize tab
    with preview_graph_widget:
        display(preview_fig)

    # SETTINGS TAB
    plot_settings_tab = widgets.GridspecLayout(18, ui_width)
    settings_progress_hbox = widgets.HBox(children=[progress_bar, tenpct_spacer, process_hvsr_button])

    # PPSD SETTINGS SUBTAB
    ppsd_length_label = widgets.Label(value=&#39;Window Length for PPSDs:&#39;)
    ppsd_length = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                    placeholder=20, value=20,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    
    overlap_pct_label = widgets.Label(value=&#39;Overlap %:&#39;)
    overlap_pct = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                    placeholder=0.5, value=0.5, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    period_step_label = widgets.Label(value=&#39;Period Step Octaves:&#39;)
    period_step_octave = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                           placeholder=0.0625, value=0.0625, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    skip_on_gaps_label = widgets.Label(value=&#39;Skip on gaps:&#39;)
    skip_on_gaps = widgets.Checkbox(value=False, disabled=False, indent=False)

    db_step_label = widgets.Label(value=&#39;dB bins:&#39;)
    db_bins_min = widgets.FloatText(description=&#39;Min. dB&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=-200, value=-200, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    db_bins_max = widgets.FloatText(description=&#39;Max. dB&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=-50, value=-50, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    db_bins_step = widgets.FloatText(description=&#39;dB Step&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=1, value=1, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    
    period_limit_label = widgets.Label(value=&#39;Period Limits:&#39;)
    minPLim = round(1/(hvsr_band_max_box.value), 3)
    maxPLim = round(1/(hvsr_band_min_box.value), 3)
    period_limits_min = widgets.FloatText(description=&#39;Min. Period Limit&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=minPLim, value=minPLim, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    period_limits_max = widgets.FloatText(description=&#39;Max. Period Limit&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=maxPLim, value=maxPLim, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    period_smoothing_width = widgets.FloatText(description=&#39;Period Smoothing Width&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=1, value=1, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    special_handling_dropdown = widgets.Dropdown(description=&#39;Special Handling&#39;, value=&#39;none&#39;,
                                                options=[(&#39;None&#39;, &#39;none&#39;), (&#39;Ringlaser&#39;, &#39;ringlaser&#39;), (&#39;Hydrophone&#39;, &#39;hydrophone&#39;)],
                                            style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    #remove_noise call
    generate_ppsd_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;generate_ppsds&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    generate_ppsd_call = widgets.HTML(value=&#39;()&#39;)
    generate_ppsd_call_hbox = widgets.HBox([generate_ppsd_prefix, generate_ppsd_call])

    # Update generate_ppsds() call
    def update_generate_ppsd_call():
        gppsdkwargs = get_generate_ppsd_kwargs()
        gppsd_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        stats=hvsr_data[&#39;stream&#39;].select(component=&#39;*&#39;).traces[0].stats, 
                        metadata=hvsr_data[&#39;paz&#39;][&#39;*&#39;], 
                        skip_on_gaps={gppsdkwargs[&#39;skip_on_gaps&#39;]}, 
                        db_bins={gppsdkwargs[&#39;db_bins&#39;]}, 
                        ppsd_length={gppsdkwargs[&#39;ppsd_length&#39;]}, 
                        overlap={gppsdkwargs[&#39;overlap&#39;]}, 
                        special_handling={gppsdkwargs[&#39;special_handling&#39;]}, 
                        period_smoothing_width_octaves={gppsdkwargs[&#39;period_smoothing_width_octaves&#39;]}, 
                        period_step_octaves={gppsdkwargs[&#39;period_step_octaves&#39;]}, 
                        period_limits={gppsdkwargs[&#39;period_limits&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        generate_ppsd_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + gppsd_text + &#39;&lt;/p&gt;&#39;
    update_generate_ppsd_call()

    ppsd_length_hbox = widgets.HBox([ppsd_length_label, ppsd_length])
    overlap_pct_hbox = widgets.HBox([overlap_pct_label, overlap_pct])
    pstep_hbox = widgets.HBox([period_step_label, period_step_octave])
    skipgaps_hbox = widgets.HBox([skip_on_gaps_label, skip_on_gaps])
    db_bins_hbox = widgets.HBox([db_step_label, db_bins_min, db_bins_max, db_bins_step])
    plim_hbox = widgets.HBox([period_limit_label, period_limits_min, period_limits_max, period_smoothing_width])

    ppsd_settings_tab = widgets.VBox([ppsd_length_hbox,
                                      overlap_pct_hbox,
                                      pstep_hbox,
                                      skipgaps_hbox,
                                      db_bins_hbox,
                                      plim_hbox,
                                      special_handling_dropdown,
                                      generate_ppsd_call_hbox])

    # OUTLIER SETTINGS SUBTAB
    rmse_pctile_check = widgets.Checkbox(description=&#39;Using percentile&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    rmse_thresh = widgets.FloatText(description=&#39;RMSE Threshold&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=98, value=98, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    use_hv_curve_rmse = widgets.Checkbox(description=&#39;Use HV Curve Outliers (may only be used after they have been calculated during the process_hvsr() step))&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=False, disabled=True)

    outlier_threshbox_hbox = widgets.HBox(children=[rmse_thresh, rmse_pctile_check])
    outlier_params_vbox = widgets.VBox(children=[outlier_threshbox_hbox, use_hv_curve_rmse])

    global outlier_fig
    outlier_fig = go.FigureWidget()
    outlier_graph_widget = widgets.Output()

    outlier_thresh_slider_label = widgets.Label(value=&#39;RMSE Thresholds:&#39;)
    rmse_thresh_slider = widgets.FloatSlider(value=0, min=0, max=100, step=0.1,description=&#39;RMSE Value&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),disabled=True)
    rmse_pctile_slider = widgets.FloatSlider(value=get_default(sprit_hvsr.remove_outlier_curves, &#39;rmse_thresh&#39;), min=0, max=100, step=0.1, description=&#34;Percentile&#34;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),)
    
    def calc_rmse(array_2d):
        medArray = np.nanmedian(array_2d, axis=0)
        rmse = np.sqrt(((np.subtract(array_2d, medArray)**2).sum(axis=1))/array_2d.shape[1])
        return rmse
    
    def on_update_rmse_thresh_slider(change):
        if use_hv_curve_rmse.value:
            rmse = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
        else:
            rmsez = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_Z&#39;]))
            rmsee = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_E&#39;]))
            rmsen = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_N&#39;]))

            rmse = np.stack([rmsez, rmsee, rmsen]).flatten()

        if rmse_pctile_check.value:
            rmse_thresh.value = rmse_pctile_slider.value
        else:
            rmse_thresh.value = rmse_thresh_slider.value
            rmse_pctile_slider.value = ((rmse &lt; rmse_thresh_slider.value).sum() / len(rmse)) * 100

    def on_update_rmse_pctile_slider(change):
        if use_hv_curve_rmse.value:
            rmse = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
        else:
            rmsez = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_Z&#39;]))
            rmsee = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_E&#39;]))
            rmsen = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_N&#39;]))

            rmse = np.stack([rmsez, rmsee, rmsen])

        if rmse_pctile_check.value:
            rmse_thresh_slider.value = np.percentile(rmse, rmse_pctile_slider.value)
            rmse_thresh.value = rmse_pctile_slider.value
        else:
            rmse_thresh.value = rmse_thresh_slider.value

    def on_update_rmse_pctile_check(change):
        if rmse_pctile_check.value:
            rmse_pctile_slider.disabled = False
            rmse_thresh_slider.disabled = True
        else:
            rmse_pctile_slider.disabled = True
            rmse_thresh_slider.disabled = False
    
    def on_update_rmse_thresh(change):
        if rmse_pctile_check.value:
            rmse_pctile_slider.value = rmse_thresh.value
        else:
            rmse_thresh_slider.value = rmse_thresh.value

    rmse_pctile_check.observe(on_update_rmse_pctile_check)
    rmse_thresh_slider.observe(on_update_rmse_thresh_slider)
    rmse_pctile_slider.observe(on_update_rmse_pctile_slider)
    rmse_thresh.observe(on_update_rmse_thresh)

    use_hv_curve_label = widgets.Label(value=&#39;NOTE: Outlier curves may only be identified after PPSDs have been calculated (during the generate_ppsds() step)&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;80%&#39;))
    generate_ppsd_button = widgets.Button(description=&#39;Generate PPSDs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;20%&#39;, justify_content=&#39;flex-end&#39;), disabled=False)
    update_outlier_plot_button = widgets.Button(description=&#39;Remove Outliers&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;20%&#39;, justify_content=&#39;flex-end&#39;), disabled=False)
    outlier_ppsd_hbox = widgets.HBox([use_hv_curve_label, generate_ppsd_button, update_outlier_plot_button])
    remove_outlier_curve_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;remove_outlier_curves&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    remove_outlier_curve_call = widgets.HTML(value=&#39;()&#39;)
    remove_outlier_hbox = widgets.HBox([remove_outlier_curve_prefix, remove_outlier_curve_call])

    # Update remove_outlier call
    def update_remove_outlier_curve_call():
        roc_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, rmse_thresh={rmse_thresh.value}, use_percentile={rmse_pctile_check.value},
                            use_hv_curve={use_hv_curve_rmse.value}...verbose={verbose_check.value})&#34;&#34;&#34;
        remove_outlier_curve_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + roc_text + &#39;&lt;/p&gt;&#39;
    update_remove_outlier_curve_call()

    def update_outlier_fig_button(button):
        outlier_fig, hvsr_data = update_outlier_fig(button)

    generate_ppsd_button.on_click(process_data)

    update_outlier_plot_button.on_click(update_outlier_fig_button)

    outlier_settings_tab = widgets.VBox(children=[outlier_params_vbox,
                                                  outlier_graph_widget,
                                                  outlier_thresh_slider_label,
                                                  rmse_thresh_slider,
                                                  rmse_pctile_slider,
                                                  outlier_ppsd_hbox,
                                                  remove_outlier_hbox])

    with outlier_graph_widget:
        display(outlier_fig)

    def update_outlier_fig(input=None, _rmse_thresh=rmse_pctile_slider.value, _use_percentile=True, _use_hv_curve=use_hv_curve_rmse.value, _verbose=verbose_check.value):
        global outlier_fig
        global hvsr_data
        hv_data = hvsr_data

        roc_kwargs = {&#39;rmse_thresh&#39;:rmse_pctile_slider.value,
                        &#39;use_percentile&#39;:True,
                        &#39;use_hv_curve&#39;:use_hv_curve_rmse.value,
                        &#39;show_outlier_plot&#39;:False,
                        &#39;verbose&#39;:verbose_check.value
                      }
        if &#39;PPSDStatus&#39; in hvsr_data.ProcessingStatus.keys() and hvsr_data.ProcessingStatus[&#39;PPSDStatus&#39;]:
            log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves():\n&#39;{roc_kwargs}&#34;    
            hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
        else:
            log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves() attempted, but not completed. hvsr_data.ProcessingStatus[&#39;PPSDStatus&#39;]=False\n&#39;{roc_kwargs}&#34;
            return outlier_fig, hvsr_data

        if roc_kwargs[&#39;use_hv_curve&#39;]:
            no_subplots = 1
            if hasattr(hvsr_data, &#39;hvsr_df&#39;) and &#39;HV_Curves&#39; in hvsr_data.hvsr_df.columns:
                outlier_fig.data = []
                outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
                outlier_subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.1)
                outlier_fig.update_layout(grid={&#39;rows&#39;: 1})
                outlier_fig = go.FigureWidget(outlier_subp)

                x_data = hvsr_data[&#39;x_freqs&#39;]
                curve_traces = []
                for hv in hvsr_data.hvsr_df[&#39;HV_Curves&#39;].iterrows():
                    curve_traces.append(go.Scatter(x=x_data, y=hv[1]))
                outlier_fig.add_traces(curve_traces)
                
                # Calculate a median curve, and reshape so same size as original
                medCurve = np.nanmedian(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]), axis=0)
                outlier_fig.add_trace(go.Scatter(x=x_data, y=medCurve, line=dict(color=&#39;rgba(0,0,0,1)&#39;, width=1.5),showlegend=False))
                
                minY = np.nanmin(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
                maxY = np.nanmax(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
                totalWindows = hvsr_data.hvsr_df.shape[0]
                #medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))

        else:
            no_subplots = 3
            outlier_fig.data = []
            outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
            outlier_subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.02,
                                                    row_heights=[1, 1, 1])
            outlier_fig.update_layout(grid={&#39;rows&#39;: 3})
            outlier_fig = go.FigureWidget(outlier_subp)

            if hasattr(hvsr_data, &#39;hvsr_df&#39;):
                rowDict = {&#39;Z&#39;:1, &#39;E&#39;:2, &#39;N&#39;:3}
                showTLabelsDict={&#39;Z&#39;:False, &#39;E&#39;:False, &#39;N&#39;:True}
                def comp_rgba(comp, a):
                    compstr = &#39;&#39;
                    if comp==&#39;Z&#39;:
                        compstr = f&#39;rgba(0, 0, 0, {a})&#39;
                    if comp==&#39;E&#39;:
                        compstr = f&#39;rgba(50, 50, 250, {a})&#39;
                    if comp==&#39;N&#39;:
                        compstr = f&#39;rgba(250, 50, 50, {a})&#39;
                    return compstr                         
                compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
                rmse_to_plot=[]
                med_traces=[]

                noRemoved = 0
                indRemoved = []
                for i, comp in enumerate(compNames):
                    if hasattr(hvsr_data, &#39;x_freqs&#39;):
                        x_data = hvsr_data[&#39;x_freqs&#39;][comp]
                    else:
                        x_data = [1/p for p in hvsr_data[&#39;ppsds&#39;][comp][&#39;period_xedges&#39;][1:]]                    
                    column = &#39;psd_values_&#39;+comp
                    # Retrieve data from dataframe (use all windows, just in case)
                    curr_data = np.stack(hvsr_data[&#39;hvsr_df&#39;][column])
                    
                    # Calculate a median curve, and reshape so same size as original
                    medCurve = np.nanmedian(curr_data, axis=0)
                    medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))
                    medTrace = go.Scatter(x=x_data, y=medCurve, line=dict(color=comp_rgba(comp, 1), width=1.5), 
                                                 name=f&#39;{comp} Component&#39;, showlegend=True)
                    # Calculate RMSE
                    rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])

                    rmse_threshold = np.percentile(rmse, roc_kwargs[&#39;rmse_thresh&#39;])
                    
                    # Retrieve index of those RMSE values that lie outside the threshold
                    timeIndex = hvsr_data[&#39;hvsr_df&#39;].index
                    for j, curve in enumerate(curr_data):
                        if rmse[j] &gt; rmse_threshold:
                            badTrace = go.Scatter(x=x_data, y=curve,
                                                line=dict(color=comp_rgba(comp, 1), width=1.5, dash=&#39;dash&#39;),
                                                #marker=dict(color=comp_rgba(comp, 1), size=3),
                                                name=str(hvsr_data.hvsr_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(badTrace, row=rowDict[comp], col=1)
                            if j not in indRemoved:
                                indRemoved.append(j)
                            noRemoved += 1
                        else:
                            goodTrace = go.Scatter(x=x_data, y=curve,
                                                  line=dict(color=comp_rgba(comp, 0.01)), name=str(hvsr_data.hvsr_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(goodTrace, row=rowDict[comp], col=1)

                    timeIndRemoved = pd.DatetimeIndex([timeIndex[ind] for ind in indRemoved])
                    hvsr_data[&#39;hvsr_df&#39;].loc[timeIndRemoved, &#39;Use&#39;] = False

                    outlier_fig.add_trace(medTrace, row=rowDict[comp], col=1)
                    
                    outlier_fig.update_xaxes(showticklabels=False, row=1, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=1, col=1)
                    outlier_fig.update_xaxes(showticklabels=False, row=2, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=2, col=1)
                    outlier_fig.update_xaxes(showticklabels=True, row=3, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=3, col=1)

                    outlier_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=True,
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Outliers&#34;)
                    if comp == &#39;N&#39;:
                        minY = np.nanmin(curr_data)
                        maxY = np.nanmax(curr_data)
                    totalWindows = curr_data.shape[0]
                
                outlier_fig.add_annotation(
                    text=f&#34;{len(indRemoved)}/{totalWindows} outlier windows removed&#34;,
                    x=np.log10(max(x_data)) - (np.log10(max(x_data))-np.log10(min(x_data))) * 0.01,
                    y=minY+(maxY-minY)*0.01,
                    xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,#bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
                    showarrow=False,row=no_subplots, col=1)


        outlier_fig.update_xaxes(type=&#39;log&#39;)
        with outlier_graph_widget:
            clear_output(wait=True)
            display(outlier_fig)
        
        if show_plot_check.value:
            outlier_fig.show()

        return outlier_fig, hvsr_data

    # HVSR SETTINGS SUBTAB
    h_combine_meth = widgets.Dropdown(description=&#39;Horizontal Combination Method&#39;, value=3,
                                    options=[(&#39;1. Differential Field Assumption (not implemented)&#39;, 1), 
                                             (&#39;2. Arithmetic Mean |  H = (N + E)/2&#39;, 2), 
                                             (&#39;3. Geometric Mean | H = √(N * E) (SESAME recommended)&#39;, 3),
                                             (&#39;4. Vector Summation | H = √(N^2 + E^2)&#39;, 4),
                                             (&#39;5. Quadratic Mean | H = √(N^2 + E^2)/2&#39;, 5),
                                             (&#39;6. Maximum Horizontal Value | H = max(N, E)&#39;, 6)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    freq_smoothing = widgets.Dropdown(description=&#39;Frequency Smoothing Operations&#39;, value=&#39;konno ohmachi&#39;,
                                    options=[(&#39;Konno-Ohmachi&#39;, &#39;konno ohmachi&#39;),
                                             (&#39;Constant&#39;,&#39;constant&#39;),
                                             (&#39;Proportional&#39;, &#39;proportional&#39;),
                                             (&#39;None&#39;, None)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    freq_smooth_width = widgets.FloatText(description=&#39;Freq. Smoothing Width&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=40, value=40, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    resample_hv_curve_bool = widgets.Checkbox(layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    resample_hv_curve = widgets.IntText(description=&#39;Resample H/V Curve&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=500, value=500, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    smooth_hv_curve_bool = widgets.Checkbox(layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    smooth_hv_curve = widgets.IntText(description=&#39;Smooth H/V Curve&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=51, value=51, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    hvsr_band_hbox_hvsrSet = widgets.HBox([hvsr_band_min_box, hvsr_band_max_box],layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    peak_freq_range_hbox_hvsrSet = widgets.HBox([peak_freq_range_min_box, peak_freq_range_max_box],layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    peak_selection_type = widgets.Dropdown(description=&#39;Peak Selection Method&#39;, value=&#39;max&#39;,
                                    options=[(&#39;Highest Peak&#39;, &#39;max&#39;),
                                             (&#39;Best Scored&#39;,&#39;scored&#39;)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    process_hvsr_call_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;process_hvsr&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;, align_content=&#39;flex-start&#39;))
    process_hvsr_call = widgets.HTML(value=&#39;()&#39;)
    process_hvsr_call_hbox = widgets.HBox([process_hvsr_call_prefix, process_hvsr_call])

    # Update process_hvsr call
    def update_process_hvsr_call():
        ph_kwargs = get_process_hvsr_kwargs()
        ph_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        method={ph_kwargs[&#39;method&#39;]}, 
                        smooth={ph_kwargs[&#39;smooth&#39;]}, 
                        freq_smooth={ph_kwargs[&#39;freq_smooth&#39;]}, 
                        f_smooth_width={ph_kwargs[&#39;f_smooth_width&#39;]}, 
                        resample={ph_kwargs[&#39;resample&#39;]}, 
                        outlier_curve_rmse_percentile={ph_kwargs[&#39;outlier_curve_rmse_percentile&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        process_hvsr_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + ph_text + &#39;&lt;/p&gt;&#39;
    update_process_hvsr_call()

    check_peaks_call_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39;+&#39;check_peaks&#39; + &#39;&lt;/p&gt;&#39;,
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    check_peaks_call = widgets.HTML(value=&#39;()&#39;)
    check_peaks_call_hbox = widgets.HBox([check_peaks_call_prefix, check_peaks_call])

    # Update process_hvsr call
    def update_check_peaks_call():
        cp_kwargs = get_check_peaks_kwargs()
        cp_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        hvsr_band={cp_kwargs[&#39;hvsr_band&#39;]}, 
                        peak_selection={cp_kwargs[&#39;peak_selection&#39;]}, 
                        peak_freq_range={cp_kwargs[&#39;peak_freq_range&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        check_peaks_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + cp_text + &#39;&lt;/p&gt;&#39;
    update_check_peaks_call()

    freq_smooth_hbox = widgets.HBox([freq_smoothing, freq_smooth_width])
    resample_hbox = widgets.HBox([resample_hv_curve_bool, resample_hv_curve])
    smooth_hbox = widgets.HBox([smooth_hv_curve_bool, smooth_hv_curve])
    
    # Set up vbox for hvsr_settings subtab
    hvsr_settings_tab = widgets.VBox([h_combine_meth,
                                    freq_smooth_hbox,
                                    resample_hbox,
                                    smooth_hbox,
                                    hvsr_band_hbox_hvsrSet,
                                    peak_freq_range_hbox_hvsrSet,
                                    peak_selection_type,
                                    process_hvsr_call_hbox,
                                    check_peaks_call_hbox])

    # PLOT SETTINGS SUBTAB
    hv_plot_label = widgets.Label(value=&#39;HVSR Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))
    component_plot_label = widgets.Label(value=&#39;Component Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))
    spec_plot_label = widgets.Label(value=&#39;Spectrogram Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))

    use_plot_label = widgets.Label(value=&#39;Use Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    use_plot_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    use_plot_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    use_plot_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    comibne_plot_label = widgets.Label(value=&#39;Combine HV and Comp. Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    combine_hv_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_peak_label = widgets.Label(value=&#39;Show Best Peak&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_best_peak_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_best_peak_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_best_peak_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    annotate_peak_label = widgets.Label(value=&#39;Annotate Best Peak&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    ann_best_peak_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    ann_best_peak_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    ann_best_peak_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_all_peaks_label = widgets.Label(value=&#39;Show All Peaks&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_all_peaks_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_all_curves_label = widgets.Label(value=&#39;Show All Curves&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_all_curves_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_all_curves_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_ind_peaks_label = widgets.Label(value=&#39;Show Individual Peaks&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_ind_peaks_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_ind_peaks_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                       style={&#39;description_width&#39;: &#39;initial&#39;})

    show_std_label = widgets.Label(value=&#39;Show Standard Deviation&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_std_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_std_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_legend_label = widgets.Label(value=&#39;Show Legend&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_legend_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_legend_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_legend_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    x_type_label = widgets.Label(value=&#39;X Type&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    x_type = widgets.Dropdown(options=[(&#39;Frequency&#39;, &#39;freq&#39;), (&#39;Period&#39;, &#39;period&#39;)],
                              layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;})

    plotly_kwargs_label = widgets.Label(value=&#39;Plotly Kwargs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    plotly_kwargs = widgets.Text(style={&#39;description_width&#39;: &#39;initial&#39;},
                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    mpl_kwargs_label = widgets.Label(value=&#39;Matplotlib Kwargs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    mpl_kwargs = widgets.Text(style={&#39;description_width&#39;: &#39;initial&#39;},
                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    plot_hvsr_call = widgets.Label(value=f&#34;Plot String: &#39;{get_default(sprit_hvsr.get_report, &#39;plot_type&#39;)}&#39;&#34;)
    def update_plot_string():
        plot_hvsr_text = f&#34;&#34;&#34;Plot String: {get_get_report_kwargs()[&#39;plot_type&#39;]}&#34;&#34;&#34;
        plot_hvsr_call.value = plot_hvsr_text
    update_plot_string()

    update_plot_button = widgets.Button(description=&#39;Update Plot&#39;,button_style=&#39;info&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    def manually_update_results_fig(change):
        plot_string = get_get_report_kwargs()[&#39;plot_type&#39;]
        update_results_fig(hvsr_results, plot_string)
        sprit_tabs.selected_index = 4

    # Set up grid for ppsd_settings subtab
    plot_settings_tab[0, 5:10]   = hv_plot_label
    plot_settings_tab[0, 10:15]  = component_plot_label
    plot_settings_tab[0, 15:] = spec_plot_label

    plot_settings_tab[1, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[2, :5] = use_plot_label
    plot_settings_tab[2, 5:10] = use_plot_hv
    plot_settings_tab[2, 10:15] = use_plot_comp
    plot_settings_tab[2, 15:] = use_plot_spec

    plot_settings_tab[3, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[4, :5] = comibne_plot_label
    plot_settings_tab[4, 10:15] = combine_hv_comp

    plot_settings_tab[5, :5] = show_peak_label
    plot_settings_tab[5, 5:10] = show_best_peak_hv
    plot_settings_tab[5, 10:15] = show_best_peak_comp
    plot_settings_tab[5, 15:] = show_best_peak_spec

    plot_settings_tab[6, :5] = annotate_peak_label
    plot_settings_tab[6, 5:10] = ann_best_peak_hv
    plot_settings_tab[6, 10:15] = ann_best_peak_comp
    plot_settings_tab[6, 15:] = ann_best_peak_spec

    plot_settings_tab[7, :5] = show_all_peaks_label
    plot_settings_tab[7, 5:10] = show_all_peaks_hv

    plot_settings_tab[8, :5] = show_all_curves_label
    plot_settings_tab[8, 5:10] = show_all_curves_hv
    plot_settings_tab[8, 10:15] = show_all_curves_comp

    plot_settings_tab[9, :5] = show_ind_peaks_label
    plot_settings_tab[9, 5:10] = show_ind_peaks_hv
    plot_settings_tab[9, 15:] = show_ind_peaks_spec
   
    plot_settings_tab[10, :5] = show_std_label
    plot_settings_tab[10, 5:10] = show_std_hv
    plot_settings_tab[10, 10:15] = show_std_comp

    plot_settings_tab[11, :5] = show_legend_label
    plot_settings_tab[11, 5:10] = show_legend_hv
    plot_settings_tab[11, 10:15] = show_legend_comp
    plot_settings_tab[11, 15:] = show_legend_spec

    plot_settings_tab[12, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[13, :5] = x_type_label
    plot_settings_tab[13, 6:] = x_type

    plot_settings_tab[14, :5] = plotly_kwargs_label
    plot_settings_tab[14, 6:] = plotly_kwargs

    plot_settings_tab[15, :5] = mpl_kwargs_label
    plot_settings_tab[15, 6:] = mpl_kwargs

    plot_settings_tab[16, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[17, :18] = plot_hvsr_call
    plot_settings_tab[17, 18:] = update_plot_button
    update_plot_button.on_click(manually_update_results_fig)

    # Place everything in Settings Tab
    settings_subtabs = widgets.Tab([ppsd_settings_tab, hvsr_settings_tab, outlier_settings_tab, plot_settings_tab])
    settings_tab = widgets.VBox(children=[settings_subtabs, settings_progress_hbox])
    settings_subtabs.set_title(0, &#34;PPSD Settings&#34;)
    settings_subtabs.set_title(1, &#34;HVSR Settings&#34;)
    settings_subtabs.set_title(2, &#34;Outlier Settings&#34;)
    settings_subtabs.set_title(3, &#34;Plot Settings&#34;)

    # LOG TAB - not currently using
    log_tab = widgets.VBox(children=[log_textArea])
    #log_textArea = widgets.Textarea(value=&#34;SESSION LOG&#34;, disabled=True, layout={&#39;height&#39;: &#39;99%&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    # RESULTS TAB
    # PLOT SUBTAB
    global results_subp
    results_subp = subplots.make_subplots(rows=3, cols=1, horizontal_spacing=0.01, vertical_spacing=0.01, row_heights=[2,1,1])
    results_fig = go.FigureWidget(results_subp)
    global results_graph_widget
    results_graph_widget = widgets.Output()   

    with results_graph_widget:
        display(results_fig)

    global printed_results_textArea
    printed_results_textArea = widgets.Textarea(value=&#34;RESULTS&#34;, disabled=True, layout={&#39;height&#39;: &#39;500px&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    global results_table
    initialTableCols=[&#39;SiteName&#39;, &#39;Acq_Date&#39;, &#39;Longitude&#39;, &#39;Latitude&#39;, &#39;Elevation&#39;,
                      &#39;PeakFrequency&#39;, &#39;WindowLengthFreq.&#39;, &#39;SignificantCycles&#39;, &#39;LowCurveStDevOverTime&#39;, 
                      &#39;PeakProminenceBelow&#39;, &#39;PeakProminenceAbove&#39;, &#39;PeakAmpClarity&#39;, 
                      &#39;FreqStability&#39;, &#39;PeakStability_FreqStD&#39;, &#39;PeakStability_AmpStD&#39;, &#39;PeakPasses&#39;]
    results_table = widgets.HTML(value=pd.DataFrame(columns=initialTableCols).to_html())

    # A text box labeled Data Filepath
    export_results_table_filepath = widgets.Text(description=&#39;Export Filepath:&#39;,
                                    placeholder=&#39;&#39;, value=&#39;&#39;,
                                    style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;90%&#39;))

    export_results_table_read_button = widgets.Button(description=&#39;&#39;, icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    export_results_table_browse_button = widgets.Button(description=&#39;Export Table&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    def export_results_table(button):
        try:
            if button.value == &#39;Export Table&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                export_results_table_filepath.value = str(filedialog.asksaveasfilename(defaultextension=&#39;.csv&#39;, title=&#39;Save CSV Report&#39;))
                root.destroy()
        except Exception as e:
            print(e)
            export_results_table_browse_button.disabled=True
            export_results_table_browse_button.description=&#39;Use Text Field&#39;

        out_path = export_results_table_filepath.value
        sprit_hvsr.get_report(hvsr_results, report_format=&#39;csv&#39;, export_path=out_path,
                              csv_overwrite_opt=&#39;overwrite&#39;)

    export_results_table_browse_button.on_click(export_results_table)
    export_results_table_read_button.on_click(export_results_table)

    results_table_export_hbox = widgets.HBox([export_results_table_filepath, export_results_table_read_button, export_results_table_browse_button])
    results_table_vbox = widgets.VBox([results_table, results_table_export_hbox])
    global results_tab
    results_subtabs = widgets.Tab([results_graph_widget, printed_results_textArea, results_table_vbox])
    results_tab = widgets.VBox(children=[results_subtabs])
    results_subtabs.set_title(0, &#34;Plot&#34;)
    results_subtabs.set_title(1, &#34;Peak Tests&#34;)
    results_subtabs.set_title(2, &#34;Peak Table&#34;)

    widget_param_dict = {
        &#39;fetch_data&#39;: 
            {&#39;source&#39;: data_source_type,
            &#39;trim_dir&#39;: trim_directory,
            &#39;export_format&#39;: trim_export_dropdown,
            &#39;detrend&#39;: detrend_type_dropdown,
            &#39;detrend_order&#39;: detrend_order,
            &#39;verbose&#39;: verbose_check},
        &#39;remove_noise&#39;: 
            {
            &#39;sat_percent&#39;: max_saturation_pct,
            &#39;noise_percent&#39;: max_window_pct,
            &#39;sta&#39;: sta,
            &#39;lta&#39;: lta,
            &#39;stalta_thresh&#39;: [stalta_thresh_low, stalta_thresh_hi],
            &#39;warmup_time&#39;: warmup_time,
            &#39;cooldown_time&#39;: cooldown_time,
            &#39;min_win_size&#39;: noisy_window_length,
            &#39;remove_raw_noise&#39;: raw_data_remove_check,
            &#39;verbose&#39;: verbose_check},
        &#39;generate_ppsds&#39;: 
            {&#39;verbose&#39;: verbose_check,
             &#39;skip_on_gaps&#39;:skip_on_gaps, 
             &#39;db_bins&#39;:[db_bins_min, db_bins_max, db_bins_step],
             &#39;ppsd_length&#39;:ppsd_length, 
             &#39;overlap&#39;:overlap_pct, 
             &#39;special_handling&#39;:special_handling_dropdown, 
             &#39;period_smoothing_width_octaves&#39;:period_smoothing_width, 
             &#39;period_step_octaves&#39;:period_step_octave, 
             &#39;period_limits&#39;:[hvsr_band_min_box, hvsr_band_max_box]},
        &#39;process_hvsr&#39;: 
            {&#39;method&#39;: h_combine_meth,
            &#39;smooth&#39;: smooth_hv_curve,
            &#39;freq_smooth&#39;: freq_smoothing,
            &#39;f_smooth_width&#39;: freq_smooth_width,
            &#39;resample&#39;: resample_hv_curve,
            &#39;verbose&#39;: verbose_check},
        &#39;remove_outlier_curves&#39;: 
            {&#39;rmse_thresh&#39;: rmse_thresh,
            &#39;use_percentile&#39;: rmse_pctile_check,
            &#39;use_hv_curve&#39;: use_hv_curve_rmse,
            &#39;verbose&#39;: verbose_check},
        &#39;check_peaks&#39;: 
            {&#39;hvsr_band&#39;: [hvsr_band_min_box, hvsr_band_max_box],
            &#39;peak_freq_range&#39;: [peak_freq_range_min_box, peak_freq_range_max_box],
            &#39;verbose&#39;: verbose_check},
        &#39;get_report&#39;: 
            {
            &#39;export_path&#39;: export_results_table_filepath,
            &#39;verbose&#39;: verbose_check}}

    # SPRIT WIDGET
    # Add all  a tab and add the grid to it
    global sprit_tabs
    sprit_tabs = widgets.Tab([input_tab, preview_tab, settings_tab, log_tab, results_tab])
    sprit_tabs.set_title(0, &#34;Input&#34;)
    sprit_tabs.set_title(1, &#34;Preview&#34;)
    sprit_tabs.set_title(2, &#34;Settings&#34;)
    sprit_tabs.set_title(3, &#34;Log&#34;)
    sprit_tabs.set_title(4, &#34;Results&#34;)

    sprit_title = widgets.Label(value=&#39;SPRIT&#39;, layout=widgets.Layout(width=&#39;150px&#39;))
    sprit_subtitle = widgets.Label(value=&#39;Tools for ambient siesmic noise analysis using HVSR&#39;,
                                   layout=widgets.Layout(flex=&#39;1&#39;, justify_content=&#39;flex-start&#39;, align_content=&#39;flex-end&#39;))

    # Function to open a link
    def open_dist(button):
        link = &#39;https://pypi.org/project/sprit/&#39;
        webbrowser.open_new_tab(link)

    def open_repo(button):
        link = &#39;https://github.com/RJbalikian/SPRIT-HVSR&#39;
        webbrowser.open_new_tab(link)

    def open_docs(button):
        link = &#39;https://rjbalikian.github.io/SPRIT-HVSR/main.html&#39;
        webbrowser.open_new_tab(link)

    sourcebutton = widgets.Button(description=&#34;PyPI&#34;,
                                layout=widgets.Layout(width=&#39;4%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))
    repobutton = widgets.Button(description=&#34;Repo&#34;,
                                layout=widgets.Layout(width=&#39;4%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))
    docsbutton = widgets.Button(description=&#34;Docs&#34;,
                                layout=widgets.Layout(width=&#39;8%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))

    # Attach the open_link function to the button&#39;s on_click event
    sourcebutton.on_click(open_dist)
    repobutton.on_click(open_repo)
    docsbutton.on_click(open_docs)

    titlehbox = widgets.HBox([sprit_title, sprit_subtitle, repobutton, sourcebutton, docsbutton],
                            layout = widgets.Layout(align_content=&#39;space-between&#39;))
    
    title_style = {
        &#39;font_family&#39;: &#39;Arial, sans-serif&#39;,
        &#39;font_size&#39;: &#39;36px&#39;,
        &#39;font_weight&#39;: &#39;bold&#39;,
        &#39;color&#39;: &#39;black&#39;
    }

    # Apply the style to the label
    sprit_title.style = title_style

    sprit_widget = widgets.VBox([titlehbox, sprit_tabs])

    def observe_children(widget, callback):
        if hasattr(widget, &#39;children&#39;):
            for child in widget.children:
                child.observe(callback)
                observe_children(child, callback)

    def any_update(change):
        update_input_param_call()
        update_fetch_data_call()
        update_remove_noise_call()
        update_generate_ppsd_call()
        update_process_hvsr_call()
        update_remove_outlier_curve_call()
        update_check_peaks_call()
        update_plot_string()

    observe_children(sprit_tabs, any_update)

    # Display the tab
    display(sprit_widget)</code></pre>
</details>
</dd>
<dt id="sprit.export_data"><code class="name flex">
<span>def <span class="ident">export_data</span></span>(<span>hvsr_data, export_path=None, ext='hvsr', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Export data into pickle format that can be read back in using import_data() so data does not need to be processed each time.
Default extension is .hvsr but it is still a pickled file that can be read in using pickle.load().</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code></dt>
<dd>Data to be exported</dd>
<dt><strong><code>export_path</code></strong> :&ensp;<code>str</code> or <code>filepath object</code>, default <code>= None</code></dt>
<dd>String or filepath object to be read by pathlib.Path() and/or a with open(export_path, 'wb') statement. If None, defaults to input datapath directory, by default None</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, default <code>= 'hvsr'</code></dt>
<dd>Filepath extension to use for data file, by default 'hvsr'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_data(hvsr_data, export_path=None, ext=&#39;hvsr&#39;, verbose=False):
    &#34;&#34;&#34;Export data into pickle format that can be read back in using import_data() so data does not need to be processed each time. 
    Default extension is .hvsr but it is still a pickled file that can be read in using pickle.load().

    Parameters
    ----------
    hvsr_data : HVSRData or HVSRBatch
        Data to be exported
    export_path : str or filepath object, default = None
        String or filepath object to be read by pathlib.Path() and/or a with open(export_path, &#39;wb&#39;) statement. If None, defaults to input datapath directory, by default None
    ext : str, default = &#39;hvsr&#39;
        Filepath extension to use for data file, by default &#39;hvsr&#39;
    &#34;&#34;&#34;
    def _do_export(_hvsr_data=hvsr_data, _export_path=export_path, _ext=ext):
        
        fname = f&#34;{_hvsr_data.site}_{_hvsr_data.acq_date}_pickled.{ext}&#34;
        if _export_path is None or _export_path is True:
            _export_path = _hvsr_data[&#39;datapath&#39;]
            _export_path = pathlib.Path(_export_path).with_name(fname)
        else:
            _export_path = pathlib.Path(_export_path)
            if _export_path.is_dir():
                _export_path = _export_path.joinpath(fname)    

        _export_path = str(_export_path)
        with open(_export_path, &#39;wb&#39;) as f:
            pickle.dump(_hvsr_data, f) 
            
        if verbose:
            print(f&#34;Processed data exported as pickled data to: {_export_path} [~{round(float(pathlib.Path(_export_path).stat().st_size)/2**20,1)} Mb]&#34;)    
            
    if isinstance(hvsr_data, HVSRBatch):
        for sitename in hvsr_data.keys():
            _do_export(hvsr_data[sitename], export_path, ext)
    elif isinstance(hvsr_data, HVSRData):
        _do_export(hvsr_data, export_path, ext)
    else:
        print(&#34;Error in data export. Data must be either of type sprit.HVSRData or sprit.HVSRBatch&#34;)         
    return</code></pre>
</details>
</dd>
<dt id="sprit.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>hvsr_data, export_settings_path='default', export_settings_type='all', include_location=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save settings to json file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, default=<code>"default"</code></dt>
<dd>Where to save the json file(s) containing the settings, by default 'default'.
If "default," will save to sprit package resources. Otherwise, set a filepath location you would like for it to be saved to.
If 'all' is selected, a directory should be supplied.
Otherwise, it will save in the directory of the provided file, if it exists. Otherwise, defaults to the home directory.</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code></dt>
<dd>What kind of settings to save.
If 'all', saves all possible types in their respective json files.
If 'instrument', save the instrument settings to their respective file.
If 'processing', saves the processing settings to their respective file. By default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, default=<code>False, input CRS</code></dt>
<dd>Whether to include the location parametersin the exported settings document.This includes xcoord, ycoord, elevation, elev_unit, and input_crs</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print outputs and information to the terminal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_settings(hvsr_data, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
    &#34;&#34;&#34;Save settings to json file

    Parameters
    ----------
    export_settings_path : str, default=&#34;default&#34;
        Where to save the json file(s) containing the settings, by default &#39;default&#39;. 
        If &#34;default,&#34; will save to sprit package resources. Otherwise, set a filepath location you would like for it to be saved to.
        If &#39;all&#39; is selected, a directory should be supplied. 
        Otherwise, it will save in the directory of the provided file, if it exists. Otherwise, defaults to the home directory.
    export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}
        What kind of settings to save. 
        If &#39;all&#39;, saves all possible types in their respective json files.
        If &#39;instrument&#39;, save the instrument settings to their respective file.
        If &#39;processing&#39;, saves the processing settings to their respective file. By default &#39;all&#39;
    include_location : bool, default=False, input CRS
        Whether to include the location parametersin the exported settings document.This includes xcoord, ycoord, elevation, elev_unit, and input_crs
    verbose : bool, default=True
        Whether to print outputs and information to the terminal

    &#34;&#34;&#34;
    fnameDict = {}
    fnameDict[&#39;instrument&#39;] = &#34;instrument_settings.json&#34;
    fnameDict[&#39;processing&#39;] = &#34;processing_settings.json&#34;

    if export_settings_path == &#39;default&#39; or export_settings_path is True:
        settingsPath = resource_dir.joinpath(&#39;settings&#39;)
    else:
        export_settings_path = pathlib.Path(export_settings_path)
        if not export_settings_path.exists():
            if not export_settings_path.parent.exists():
                print(f&#39;The provided value for export_settings_path ({export_settings_path}) does not exist. Saving settings to the home directory: {pathlib.Path.home()}&#39;)
                settingsPath = pathlib.Path.home()
            else:
                settingsPath = export_settings_path.parent
        
        if export_settings_path.is_dir():
            settingsPath = export_settings_path
        elif export_settings_path.is_file():
            settingsPath = export_settings_path.parent
            fnameDict[&#39;instrument&#39;] = export_settings_path.name+&#34;_instrumentSettings.json&#34;
            fnameDict[&#39;processing&#39;] = export_settings_path.name+&#34;_processingSettings.json&#34;

    #Get final filepaths        
    instSetFPath = settingsPath.joinpath(fnameDict[&#39;instrument&#39;])
    procSetFPath = settingsPath.joinpath(fnameDict[&#39;processing&#39;])

    #Get settings values
    instKeys = [&#34;instrument&#34;, &#34;net&#34;, &#34;sta&#34;, &#34;loc&#34;, &#34;cha&#34;, &#34;depth&#34;, &#34;metapath&#34;, &#34;hvsr_band&#34;]
    inst_location_keys = [&#39;xcoord&#39;, &#39;ycoord&#39;, &#39;elevation&#39;, &#39;elev_unit&#39;, &#39;input_crs&#39;]
    procFuncs = [fetch_data, remove_noise, generate_ppsds, process_hvsr, check_peaks, get_report]

    instrument_settings_dict = {}
    processing_settings_dict = {}

    for k in instKeys:
        if isinstance(hvsr_data[k], pathlib.PurePath):
            #For those that are paths and cannot be serialized
            instrument_settings_dict[k] = hvsr_data[k].as_posix()
        else:
            instrument_settings_dict[k] = hvsr_data[k]

    if include_location:
        for k in inst_location_keys:
            if isinstance(hvsr_data[k], pathlib.PurePath):
                #For those that are paths and cannot be serialized
                instrument_settings_dict[k] = hvsr_data[k].as_posix()
            else:
                instrument_settings_dict[k] = hvsr_data[k]

    
    for func in procFuncs:
        funcName = func.__name__
        processing_settings_dict[funcName] = {}
        for arg in hvsr_data[&#39;processing_parameters&#39;][funcName]:
            if isinstance(hvsr_data[&#39;processing_parameters&#39;][funcName][arg], (HVSRBatch, HVSRData)):
                pass
            else:
                processing_settings_dict[funcName][arg] = hvsr_data[&#39;processing_parameters&#39;][funcName][arg]
    
    if verbose:
        print(&#34;Exporting Settings&#34;)
    #Save settings files
    if export_settings_type.lower()==&#39;instrument&#39; or export_settings_type.lower()==&#39;all&#39;:
        try:
            with open(instSetFPath.with_suffix(&#39;.inst&#39;).as_posix(), &#39;w&#39;) as instSetF:
                jsonString = json.dumps(instrument_settings_dict, indent=2)
                #Format output for readability
                jsonString = jsonString.replace(&#39;\n    &#39;, &#39; &#39;)
                jsonString = jsonString.replace(&#39;[ &#39;, &#39;[&#39;)
                jsonString = jsonString.replace(&#39;\n  ]&#39;, &#39;]&#39;)
                #Export
                instSetF.write(jsonString)
        except:
            instSetFPath = pathlib.Path.home().joinpath(instSetFPath.name)
            with open(instSetFPath.with_suffix(&#39;.inst&#39;).as_posix(), &#39;w&#39;) as instSetF:
                jsonString = json.dumps(instrument_settings_dict, indent=2)
                #Format output for readability
                jsonString = jsonString.replace(&#39;\n    &#39;, &#39; &#39;)
                jsonString = jsonString.replace(&#39;[ &#39;, &#39;[&#39;)
                jsonString = jsonString.replace(&#39;\n  ]&#39;, &#39;]&#39;)
                #Export
                instSetF.write(jsonString)
                            
        if verbose:
            print(f&#34;Instrument settings exported to {instSetFPath}&#34;)
            print(f&#34;{jsonString}&#34;)
            print()
    if export_settings_type.lower()==&#39;processing&#39; or export_settings_type.lower()==&#39;all&#39;:
        try:
            with open(procSetFPath.with_suffix(&#39;.proc&#39;).as_posix(), &#39;w&#39;) as procSetF:
                jsonString = json.dumps(processing_settings_dict, indent=2)
                #Format output for readability
                jsonString = jsonString.replace(&#39;\n    &#39;, &#39; &#39;)
                jsonString = jsonString.replace(&#39;[ &#39;, &#39;[&#39;)
                jsonString = jsonString.replace(&#39;\n  ]&#39;, &#39;]&#39;)
                jsonString = jsonString.replace(&#39;\n  },&#39;,&#39;\n\t\t},\n&#39;)
                jsonString = jsonString.replace(&#39;{ &#34;&#39;, &#39;\n\t\t{\n\t\t&#34;&#39;)
                jsonString = jsonString.replace(&#39;, &#34;&#39;, &#39;,\n\t\t&#34;&#39;)
                jsonString = jsonString.replace(&#39;\n  }&#39;, &#39;\n\t\t}&#39;)
                jsonString = jsonString.replace(&#39;: {&#39;, &#39;:\n\t\t\t{&#39;)
                
                #Export
                procSetF.write(jsonString)
        except:
            procSetFPath = pathlib.Path.home().joinpath(procSetFPath.name)
            with open(procSetFPath.with_suffix(&#39;.proc&#39;).as_posix(), &#39;w&#39;) as procSetF:
                jsonString = json.dumps(processing_settings_dict, indent=2)
                #Format output for readability
                jsonString = jsonString.replace(&#39;\n    &#39;, &#39; &#39;)
                jsonString = jsonString.replace(&#39;[ &#39;, &#39;[&#39;)
                jsonString = jsonString.replace(&#39;\n  ]&#39;, &#39;]&#39;)
                jsonString = jsonString.replace(&#39;\n  },&#39;,&#39;\n\t\t},\n&#39;)
                jsonString = jsonString.replace(&#39;{ &#34;&#39;, &#39;\n\t\t{\n\t\t&#34;&#39;)
                jsonString = jsonString.replace(&#39;, &#34;&#39;, &#39;,\n\t\t&#34;&#39;)
                jsonString = jsonString.replace(&#39;\n  }&#39;, &#39;\n\t\t}&#39;)
                jsonString = jsonString.replace(&#39;: {&#39;, &#39;:\n\t\t\t{&#39;)
                
                #Export
                procSetF.write(jsonString)            
        if verbose:
            print(f&#34;Processing settings exported to {procSetFPath}&#34;)
            print(f&#34;{jsonString}&#34;)
            print()</code></pre>
</details>
</dd>
<dt id="sprit.fetch_data"><code class="name flex">
<span>def <span class="ident">fetch_data</span></span>(<span>params, source='file', trim_dir=None, export_format='mseed', detrend='spline', detrend_order=2, update_metadata=True, plot_input_stream=False, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch ambient seismic data from a source to read into obspy stream</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>params
: dict</dt>
<dt>Dictionary containing all the necessary params to get data.</dt>
<dt>Parameters defined using input_params() function.</dt>
<dt _batch_="'batch'" _dir_="'dir'," _file_="'file'," _raw_="'raw',">source
: str,</dt>
<dt>String indicating where/how data file was created. For example, if raw data, will need to find correct channels.</dt>
<dt>'raw' finds raspberry shake data, from raw output copied using scp directly from Raspberry Shake, either in folder or subfolders;</dt>
<dt>'dir' is used if the day's 3 component files (currently Raspberry Shake supported only) are all 3 contained in a directory by themselves.</dt>
<dt>'file' is used if the params['datapath'] specified in input_params() is the direct filepath to a single file to be read directly into an obspy stream.</dt>
<dt>'batch' is used to read a list or specified set of seismic files.</dt>
<dt>Most commonly, a csv file can be read in with all the parameters. Each row in the csv is a separate file. Columns can be arranged by parameter.</dt>
<dt><strong><code>trim_dir</code></strong> :&ensp;<code>None</code> or <code>str</code> or <code>pathlib obj</code>, default=<code>None</code></dt>
<dd>If None (or False), data is not trimmed in this function.
Otherwise, this is the directory to save trimmed and exported data.</dd>
<dt><strong><code>export_format</code></strong> :&ensp;<code>str='mseed'</code></dt>
<dd>If trim_dir is not None, this is the format in which to save the data</dd>
<dt><strong><code>detrend</code></strong> :&ensp;<code>str</code> or <code>bool</code>, default=<code>'spline'</code></dt>
<dd>If False, data is not detrended.
Otherwise, this should be a string accepted by the type parameter of the obspy.core.trace.Trace.detrend method: <a href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html">https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html</a></dd>
<dt><strong><code>detrend_order</code></strong> :&ensp;<code>int</code>, default=<code>2</code></dt>
<dd>If detrend parameter is 'spline' or 'polynomial', this is passed directly to the order parameter of obspy.core.trace.Trace.detrend method.</dd>
<dt><strong><code>update_metadata</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to update the metadata file, used primarily with Raspberry Shake data which uses a generic inventory file.</dd>
<dt><strong><code>plot_input_stream</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to plot the raw input stream. This plot includes a spectrogram (Z component) and the raw (with decimation for speed) plots of each component signal.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print outputs and inputs to the terminal</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keywords arguments, primarily for 'batch' and 'dir' sources</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Same as params parameter, but with an additional "stream" attribute with an obspy data stream with 3 traces: Z (vertical), N (North-south), and E (East-west)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_data(params, source=&#39;file&#39;, trim_dir=None, export_format=&#39;mseed&#39;, detrend=&#39;spline&#39;, detrend_order=2, update_metadata=True, plot_input_stream=False, verbose=False, **kwargs):
    &#34;&#34;&#34;Fetch ambient seismic data from a source to read into obspy stream
    
    Parameters
    ----------
    params  : dict
        Dictionary containing all the necessary params to get data.
            Parameters defined using input_params() function.
    source  : str, {&#39;raw&#39;, &#39;dir&#39;, &#39;file&#39;, &#39;batch&#39;}
        String indicating where/how data file was created. For example, if raw data, will need to find correct channels.
            &#39;raw&#39; finds raspberry shake data, from raw output copied using scp directly from Raspberry Shake, either in folder or subfolders; 
            &#39;dir&#39; is used if the day&#39;s 3 component files (currently Raspberry Shake supported only) are all 3 contained in a directory by themselves.
            &#39;file&#39; is used if the params[&#39;datapath&#39;] specified in input_params() is the direct filepath to a single file to be read directly into an obspy stream.
            &#39;batch&#39; is used to read a list or specified set of seismic files. 
                Most commonly, a csv file can be read in with all the parameters. Each row in the csv is a separate file. Columns can be arranged by parameter.
    trim_dir : None or str or pathlib obj, default=None
        If None (or False), data is not trimmed in this function.
        Otherwise, this is the directory to save trimmed and exported data.
    export_format: str=&#39;mseed&#39;
        If trim_dir is not None, this is the format in which to save the data
    detrend : str or bool, default=&#39;spline&#39;
        If False, data is not detrended.
        Otherwise, this should be a string accepted by the type parameter of the obspy.core.trace.Trace.detrend method: https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html
    detrend_order : int, default=2
        If detrend parameter is &#39;spline&#39; or &#39;polynomial&#39;, this is passed directly to the order parameter of obspy.core.trace.Trace.detrend method.
    update_metadata : bool, default=True
        Whether to update the metadata file, used primarily with Raspberry Shake data which uses a generic inventory file.
    plot_input_stream : bool, default=False
        Whether to plot the raw input stream. This plot includes a spectrogram (Z component) and the raw (with decimation for speed) plots of each component signal.
    verbose : bool, default=False
        Whether to print outputs and inputs to the terminal
    **kwargs
        Keywords arguments, primarily for &#39;batch&#39; and &#39;dir&#39; sources
        
    Returns
    -------
    params : HVSRData or HVSRBatch object
        Same as params parameter, but with an additional &#34;stream&#34; attribute with an obspy data stream with 3 traces: Z (vertical), N (North-south), and E (East-west)
    &#34;&#34;&#34;
    # Get intput paramaters
    orig_args = locals().copy()
    start_time = datetime.datetime.now()
    
    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in params.keys():
        if &#39;fetch_data&#39; in params[&#39;processing_parameters&#39;].keys():
            defaultVDict = dict(zip(inspect.getfullargspec(fetch_data).args[1:], 
                        inspect.getfullargspec(fetch_data).defaults))
            defaultVDict[&#39;kwargs&#39;] = kwargs
            for k, v in params[&#39;processing_parameters&#39;][&#39;fetch_data&#39;].items():
                # Manual input to function overrides the imported parameter values
                if k!=&#39;params&#39; and k in orig_args.keys() and orig_args[k]==defaultVDict[k]:
                    orig_args[k] = v

    #Update local variables, in case of previously-specified parameters
    source=orig_args[&#39;source&#39;]
    trim_dir=orig_args[&#39;trim_dir&#39;]
    export_format=orig_args[&#39;export_format&#39;]
    detrend=orig_args[&#39;detrend&#39;]
    detrend_order=orig_args[&#39;detrend_order&#39;]
    update_metadata=orig_args[&#39;update_metadata&#39;]
    plot_input_stream=orig_args[&#39;plot_input_stream&#39;]
    verbose=orig_args[&#39;verbose&#39;]
    kwargs=orig_args[&#39;kwargs&#39;]

    if source != &#39;batch&#39; and verbose:
        print(&#39;\nFetching data (fetch_data())&#39;)
        print()

    params = get_metadata(params, update_metadata=update_metadata, source=source)
    inv = params[&#39;inv&#39;]
    date=params[&#39;acq_date&#39;]

    #Cleanup for gui input
    if isinstance(params[&#39;datapath&#39;], (obspy.Stream, obspy.Trace)):
        pass
    elif &#39;}&#39; in str(params[&#39;datapath&#39;]):
        params[&#39;datapath&#39;] = params[&#39;datapath&#39;].as_posix().replace(&#39;{&#39;,&#39;&#39;)
        params[&#39;datapath&#39;] = params[&#39;datapath&#39;].split(&#39;}&#39;)
    
    sampleListNos = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;]
    sampleList = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;batch&#39;, &#39;sample&#39;, &#39;sample_batch&#39;]
    for s in sampleListNos:
        sampleList.append(f&#39;sample{s}&#39;)
        sampleList.append(f&#39;sample_{s}&#39;)

    #Make sure datapath is pointing to an actual file
    if isinstance(params[&#39;datapath&#39;],list):
        for i, d in enumerate(params[&#39;datapath&#39;]):
            params[&#39;datapath&#39;][i] = sprit_utils.checkifpath(str(d).strip(), sample_list=sampleList)
        dPath = params[&#39;datapath&#39;]
    elif isinstance(params[&#39;datapath&#39;], (obspy.Stream, obspy.Trace)):
        pass
    else:
        dPath = sprit_utils.checkifpath(params[&#39;datapath&#39;], sample_list=sampleList)

    inst = params[&#39;instrument&#39;]

    #Need to put dates and times in right formats first
    if type(date) is datetime.datetime:
        doy = date.timetuple().tm_yday
        year = date.year
    elif type(date) is datetime.date:
        date = datetime.datetime.combine(date, datetime.time(hour=0, minute=0, second=0))
        doy = date.timetuple().tm_yday
        year = date.year
    elif type(date) is tuple:
        if date[0]&gt;366:
            raise ValueError(&#39;First item in date tuple must be day of year (0-366)&#39;, 0)
        elif date[1] &gt; datetime.datetime.now().year:
            raise ValueError(&#39;Second item in date tuple should be year, but given item is in the future&#39;, 0)
        else:
            doy = date[0]
            year = date[1]
    elif type(date) is str:
        if &#39;/&#39; in date:
            dateSplit = date.split(&#39;/&#39;)            
        elif &#39;-&#39; in date:
            dateSplit = date.split(&#39;-&#39;)
        else:
            dateSplit = date

        if int(dateSplit[0]) &gt; 31:
            date = datetime.datetime(int(dateSplit[0]), int(dateSplit[1]), int(dateSplit[2]))
            doy = date.timetuple().tm_yday
            year = date.year
        elif int(dateSplit[0])&lt;=12 and int(dateSplit[2]) &gt; 31:
            warnings.warn(&#34;Preferred date format is &#39;yyyy-mm-dd&#39; or &#39;yyyy/mm/dd&#39;. Will attempt to parse date.&#34;)
            date = datetime.datetime(int(dateSplit[2]), int(dateSplit[0]), int(dateSplit[1]))
            doy = date.timetuple().tm_yday
            year = date.year
        else:
            warnings.warn(&#34;Preferred date format is &#39;yyyy-mm-dd&#39; or &#39;yyyy/mm/dd&#39;. Cannot parse date.&#34;)
    elif type(date) is int:
        doy = date
        year = datetime.datetime.today().year
    else: #FOR NOW, need to update
        date = datetime.datetime.now()
        doy = date.timetuple().tm_yday
        year = date.year
        warnings.warn(&#34;Did not recognize date, using year {} and day {}&#34;.format(year, doy))

    #Select which instrument we are reading from (requires different processes for each instrument)
    raspShakeInstNameList = [&#39;raspberry shake&#39;, &#39;shake&#39;, &#39;raspberry&#39;, &#39;rs&#39;, &#39;rs3d&#39;, &#39;rasp. shake&#39;, &#39;raspshake&#39;]
    trominoNameList = [&#39;tromino&#39;, &#39;trom&#39;, &#39;tromino 3g&#39;, &#39;tromino 3g+&#39;, &#39;tr&#39;, &#39;t&#39;]

    #Get any kwargs that are included in obspy.read
    obspyReadKwargs = {}
    for argName in inspect.getfullargspec(obspy.read)[0]:
        if argName in kwargs.keys():
            obspyReadKwargs[argName] = kwargs[argName]

    #Select how reading will be done
    if source==&#39;raw&#39;:
        try:
            if inst.lower() in raspShakeInstNameList:
                rawDataIN = __read_RS_file_struct(dPath, source, year, doy, inv, params, verbose=verbose)

            elif inst.lower() in trominoNameList:
                rawDataIN = read_tromino_files(dPath, params, verbose=verbose, **kwargs)
        except:
            raise RuntimeError(f&#34;Data not fetched for {params[&#39;site&#39;]}. Check input parameters or the data file.&#34;)
    elif source==&#39;stream&#39; or isinstance(params, (obspy.Stream, obspy.Trace)):
        rawDataIN = params[&#39;datapath&#39;].copy()
    elif source==&#39;dir&#39;:
        if inst.lower() in raspShakeInstNameList:
            rawDataIN = __read_RS_file_struct(dPath, source, year, doy, inv, params, verbose=verbose)
        else:
            obspyFiles = {}
            for obForm in obspyFormats:
                temp_file_glob = pathlib.Path(dPath.as_posix().lower()).glob(&#39;.&#39;+obForm.lower())
                for f in temp_file_glob:
                    currParams = params
                    currParams[&#39;datapath&#39;] = f

                    curr_data = fetch_data(params, source=&#39;file&#39;, #all the same as input, except just reading the one file using the source=&#39;file&#39;
                                trim_dir=trim_dir, export_format=export_format, detrend=detrend, detrend_order=detrend_order, update_metadata=update_metadata, verbose=verbose, **kwargs)
                    curr_data.merge()
                    obspyFiles[f.stem] = curr_data  #Add path object to dict, with filepath&#39;s stem as the site name
            return HVSRBatch(obspyFiles)
    elif source==&#39;file&#39; and str(params[&#39;datapath&#39;]).lower() not in sampleList:
        if isinstance(dPath, list) or isinstance(dPath, tuple):
            rawStreams = []
            for datafile in dPath:
                rawStream = obspy.read(datafile, **obspyReadKwargs)
                rawStreams.append(rawStream) #These are actually streams, not traces
            for i, stream in enumerate(rawStreams):
                if i == 0:
                    rawDataIN = obspy.Stream(stream) #Just in case
                else:
                    rawDataIN = rawDataIN + stream #This adds a stream/trace to the current stream object
        elif str(dPath)[:6].lower()==&#39;sample&#39;:
            pass
        else:
            rawDataIN = obspy.read(dPath, **obspyReadKwargs)#, starttime=obspy.core.UTCDateTime(params[&#39;starttime&#39;]), endttime=obspy.core.UTCDateTime(params[&#39;endtime&#39;]), nearest_sample =True)
        import warnings
        with warnings.catch_warnings():
            warnings.simplefilter(action=&#39;ignore&#39;, category=UserWarning)
            rawDataIN.attach_response(inv)
    elif source==&#39;batch&#39; and str(params[&#39;datapath&#39;]).lower() not in sampleList:
        if verbose:
            print(&#39;\nFetching data (fetch_data())&#39;)
        batch_data_read_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in batch_data_read.__code__.co_varnames}
        params = batch_data_read(input_data=params[&#39;datapath&#39;], verbose=verbose, **batch_data_read_kwargs)
        params = HVSRBatch(params)
        return params
    elif str(params[&#39;datapath&#39;]).lower() in sampleList or f&#34;sample{params[&#39;datapath&#39;].lower()}&#34; in sampleList:
        sample_data_dir = pathlib.Path(pkg_resources.resource_filename(__name__, &#39;resources/sample_data/&#39;))
        if source==&#39;batch&#39;:
            params[&#39;datapath&#39;] = sample_data_dir.joinpath(&#39;Batch_SampleData.csv&#39;)
            params = batch_data_read(input_data=params[&#39;datapath&#39;], batch_type=&#39;sample&#39;, verbose=verbose)
            params = HVSRBatch(params)
            return params

        elif source==&#39;dir&#39;:
            params[&#39;datapath&#39;] = sample_data_dir.joinpath(&#39;Batch_SampleData.csv&#39;)
            params = batch_data_read(input_data=params[&#39;datapath&#39;], batch_type=&#39;sample&#39;, verbose=verbose)
            params = HVSRBatch(params)
            return params

        elif source==&#39;file&#39;:
            params[&#39;datapath&#39;] = str(params[&#39;datapath&#39;]).lower()
            
            if params[&#39;datapath&#39;].lower() in sampleFileKeyMap.keys():
                params[&#39;datapath&#39;] = sampleFileKeyMap[params[&#39;datapath&#39;].lower()]
            else:
                params[&#39;datapath&#39;] = sample_data_dir.joinpath(&#39;SampleHVSRSite1_AM.RAC84.00.2023.046_2023-02-15_1704-1734.MSEED&#39;)

            dPath = params[&#39;datapath&#39;]
            rawDataIN = obspy.read(dPath)#, starttime=obspy.core.UTCDateTime(params[&#39;starttime&#39;]), endttime=obspy.core.UTCDateTime(params[&#39;endtime&#39;]), nearest_sample =True)
            import warnings
            with warnings.catch_warnings():
                warnings.simplefilter(action=&#39;ignore&#39;, category=UserWarning)
                rawDataIN.attach_response(inv)
    else:
        try:
            rawDataIN = obspy.read(dPath)
            rawDataIN.attach_response(inv)
        except:
            RuntimeError(f&#39;source={source} not recognized, and datapath cannot be read using obspy.read()&#39;)

    #Get metadata from the data itself, if not reading raw data
    try:
        dataIN = rawDataIN.copy()
        if source!=&#39;raw&#39;:
            #Use metadata from file for;
            # site
            if params[&#39;site&#39;] == &#34;HVSR Site&#34;:
                if isinstance(dPath, (list, tuple)):
                    dPath = dPath[0]
                params[&#39;site&#39;] = dPath.stem
                params[&#39;params&#39;][&#39;site&#39;] = dPath.stem
            
            # network
            if str(params[&#39;net&#39;]) == &#39;AM&#39;:
                params[&#39;net&#39;] = dataIN[0].stats.network
                params[&#39;params&#39;][&#39;net&#39;] = dataIN[0].stats.network

            # station
            if str(params[&#39;sta&#39;]) == &#39;RAC84&#39;:
                params[&#39;sta&#39;] = dataIN[0].stats.station
                params[&#39;params&#39;][&#39;sta&#39;] = dataIN[0].stats.station

            # loc
            if str(params[&#39;loc&#39;]) == &#39;00&#39;:
                params[&#39;loc&#39;] = dataIN[0].stats.location
                params[&#39;params&#39;][&#39;loc&#39;] = dataIN[0].stats.location
            
            # channels
            channelList = []
            if str(params[&#39;cha&#39;]) == [&#39;EHZ&#39;, &#39;EHN&#39;, &#39;EHE&#39;]:
                for tr in dataIN:
                    if tr.stats.channel not in channelList:
                        channelList.append(tr.stats.channel)
                        channelList.sort(reverse=True) #Just so z is first, just in case
                params[&#39;cha&#39;] = channelList
                params[&#39;params&#39;][&#39;cha&#39;] = channelList
           
            # Acquisition date
            if str(params[&#39;acq_date&#39;]) == str(datetime.datetime.now().date()):
                params[&#39;acq_date&#39;] = dataIN[0].stats.starttime.date

            # starttime
            today_Starttime = obspy.UTCDateTime(datetime.datetime(year=datetime.date.today().year, month=datetime.date.today().month,
                                                                 day = datetime.date.today().day,
                                                                hour=0, minute=0, second=0, microsecond=0))
            maxStarttime = datetime.datetime(year=params[&#39;acq_date&#39;].year, month=params[&#39;acq_date&#39;].month, day=params[&#39;acq_date&#39;].day, 
                                             hour=0, minute=0, second=0, microsecond=0, tzinfo=datetime.timezone.utc)
            if str(params[&#39;starttime&#39;]) == str(today_Starttime):
                for tr in dataIN.merge():
                    currTime = datetime.datetime(year=tr.stats.starttime.year, month=tr.stats.starttime.month, day=tr.stats.starttime.day,
                                        hour=tr.stats.starttime.hour, minute=tr.stats.starttime.minute, 
                                       second=tr.stats.starttime.second, microsecond=tr.stats.starttime.microsecond, tzinfo=datetime.timezone.utc)
                    if currTime &gt; maxStarttime:
                        maxStarttime = currTime

                newStarttime = obspy.UTCDateTime(datetime.datetime(year=params[&#39;acq_date&#39;].year, month=params[&#39;acq_date&#39;].month,
                                                                 day = params[&#39;acq_date&#39;].day,
                                                                hour=maxStarttime.hour, minute=maxStarttime.minute, 
                                                                second=maxStarttime.second, microsecond=maxStarttime.microsecond))
                params[&#39;starttime&#39;] = newStarttime
                params[&#39;params&#39;][&#39;starttime&#39;] = newStarttime

            # endttime
            today_Endtime = obspy.UTCDateTime(datetime.datetime(year=datetime.date.today().year, month=datetime.date.today().month,
                                                                 day = datetime.date.today().day,
                                                                hour=23, minute=59, second=59, microsecond=999999))
            tomorrow_Endtime = today_Endtime + (60*60*24)
            minEndtime = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc)#(hour=23, minute=59, second=59, microsecond=999999)
            if str(params[&#39;endtime&#39;]) == str(today_Endtime) or str(params[&#39;endtime&#39;])==tomorrow_Endtime:
                for tr in dataIN.merge():
                    currTime = datetime.datetime(year=tr.stats.endtime.year, month=tr.stats.endtime.month, day=tr.stats.endtime.day,
                                        hour=tr.stats.endtime.hour, minute=tr.stats.endtime.minute, 
                                       second=tr.stats.endtime.second, microsecond=tr.stats.endtime.microsecond, tzinfo=datetime.timezone.utc)
                    if currTime &lt; minEndtime:
                        minEndtime = currTime
                newEndtime = obspy.UTCDateTime(datetime.datetime(year=minEndtime.year, month=minEndtime.month,
                                                                 day = minEndtime.day,
                                                                hour=minEndtime.hour, minute=minEndtime.minute, 
                                                                second=minEndtime.second, microsecond=minEndtime.microsecond, tzinfo=datetime.timezone.utc))
                params[&#39;endtime&#39;] = newEndtime
                params[&#39;params&#39;][&#39;endtime&#39;] = newEndtime


            #print(dataIN)
            #print(params[&#39;starttime&#39;])
            #print(params[&#39;endtime&#39;])
            dataIN = dataIN.split()
            dataIN = dataIN.trim(starttime=params[&#39;starttime&#39;], endtime=params[&#39;endtime&#39;])
            dataIN.merge()
            #print(dataIN)
    except:
        raise RuntimeError(&#39;Data not fetched. Check your input parameters or the data file.&#39;)
        
    #Trim and save data as specified
    if trim_dir==&#39;None&#39;:
        trim_dir=None
    if not trim_dir:
        pass
    else:
        if isinstance(params, HVSRBatch):
            pass
        else:
            dataIN = _trim_data(input=params, stream=dataIN, export_dir=trim_dir, source=source, export_format=export_format)

    #Split data if masked array (if there are gaps)...detrending cannot be done without
    for tr in dataIN:
        if isinstance(tr.data, np.ma.masked_array):
            dataIN = dataIN.split()
            #Splits entire stream if any trace is masked_array
            break

    #Detrend data
    if isinstance(params, HVSRBatch):
        pass
    else:
        dataIN =  __detrend_data(input=dataIN, detrend=detrend, detrend_order=detrend_order, verbose=verbose, source=source)

    #Remerge data
    dataIN = dataIN.merge(method=1)

    #Plot the input stream?
    if plot_input_stream:
        try:
            params[&#39;InputPlot&#39;] = _plot_specgram_stream(stream=dataIN, params=params, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, fill_gaps=None, ylimstd=3, return_fig=True, fig=None, ax=None, show_plot=False)
            #_get_removed_windows(input=dataIN, fig=params[&#39;InputPlot&#39;][0], ax=params[&#39;InputPlot&#39;][1], lineArtist =[], winArtist = [], existing_lineArtists=[], existing_xWindows=[], exist_win_format=&#39;matplotlib&#39;, keep_line_artists=True, time_type=&#39;matplotlib&#39;, show_plot=True)
            plt.show()
        except:
            print(&#39;Error with default plotting method, falling back to internal obspy plotting method&#39;)
            dataIN.plot(method=&#39;full&#39;, linewidth=0.25)

    #Sort channels (make sure Z is first, makes things easier later)
    if isinstance(params, HVSRBatch):
        pass
    else:
        dataIN = _sort_channels(input=dataIN, source=source, verbose=verbose)

    #Clean up the ends of the data unless explicitly specified to do otherwise (this is a kwarg, not a parameter)
    if &#39;clean_ends&#39; not in kwargs.keys():
        clean_ends=True 
    else:
        clean_ends = kwargs[&#39;clean_ends&#39;]

    if clean_ends:
        maxStarttime = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc) - datetime.timedelta(days=36500) #100 years ago
        minEndtime = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc) 

        for tr in dataIN:
            currStarttime = datetime.datetime(year=tr.stats.starttime.year, month=tr.stats.starttime.month, day=tr.stats.starttime.day, 
                                         hour=tr.stats.starttime.hour, minute=tr.stats.starttime.minute, 
                                         second=tr.stats.starttime.second, microsecond=tr.stats.starttime.microsecond, tzinfo=datetime.timezone.utc)
            if currStarttime &gt; maxStarttime:
                maxStarttime = currStarttime

            currEndtime = datetime.datetime(year=tr.stats.endtime.year, month=tr.stats.endtime.month, day=tr.stats.endtime.day, 
                                         hour=tr.stats.endtime.hour, minute=tr.stats.endtime.minute, 
                                         second=tr.stats.endtime.second, microsecond=tr.stats.endtime.microsecond, tzinfo=datetime.timezone.utc)

            if currEndtime &lt; minEndtime:
                minEndtime = currEndtime


        maxStarttime = obspy.UTCDateTime(maxStarttime)
        minEndtime = obspy.UTCDateTime(minEndtime)
        dataIN = dataIN.split()
        for tr in dataIN:
            tr.trim(starttime=maxStarttime, endtime=minEndtime)
            pass
        dataIN.merge()
    
    params[&#39;batch&#39;] = False #Set False by default, will get corrected later in batch mode        
    params[&#39;input_stream&#39;] = dataIN.copy()
    params[&#39;stream&#39;] = dataIN.copy()
    
    if &#39;processing_parameters&#39; not in params.keys():
        params[&#39;processing_parameters&#39;] = {}
    params[&#39;processing_parameters&#39;][&#39;fetch_data&#39;] = {}
    for key, value in orig_args.items():
        params[&#39;processing_parameters&#39;][&#39;fetch_data&#39;][key] = value

    
    params[&#39;ProcessingStatus&#39;][&#39;FetchDataStatus&#39;] = True
    if verbose and not isinstance(params, HVSRBatch):
        dataINStr = dataIN.__str__().split(&#39;\n&#39;)
        for line in dataINStr:
            print(&#39;\t&#39;,line)
    
    params = _check_processing_status(params, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)

    return params</code></pre>
</details>
</dd>
<dt id="sprit.format_time"><code class="name flex">
<span>def <span class="ident">format_time</span></span>(<span>inputDT, tzone='UTC')</span>
</code></dt>
<dd>
<div class="desc"><p>Private function to format time, used in other functions</p>
<p>Formats input time to datetime objects in utc</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inputDT</code></strong> :&ensp;<code>str</code> or <code>datetime obj </code></dt>
<dd>Input datetime. Can include date and time, just date (time inferred to be 00:00:00.00) or just time (if so, date is set as today)</dd>
</dl>
<p>tzone
: str='utc' or int {'utc', 'local'}
Timezone of data entry.
If string and not utc, assumed to be timezone of computer running the process.
If int, assumed to be offset from UTC (e.g., CST in the United States is -6; CDT in the United States is -5)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>outputTimeObj</code></strong> :&ensp;<code>datetime object in UTC</code></dt>
<dd>Output datetime.datetime object, now in UTC time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_time(inputDT, tzone=&#39;UTC&#39;):
    &#34;&#34;&#34;Private function to format time, used in other functions

    Formats input time to datetime objects in utc

    Parameters
    ----------
    inputDT : str or datetime obj 
        Input datetime. Can include date and time, just date (time inferred to be 00:00:00.00) or just time (if so, date is set as today)
    tzone   : str=&#39;utc&#39; or int {&#39;utc&#39;, &#39;local&#39;} 
        Timezone of data entry. 
            If string and not utc, assumed to be timezone of computer running the process.
            If int, assumed to be offset from UTC (e.g., CST in the United States is -6; CDT in the United States is -5)

    Returns
    -------
    outputTimeObj : datetime object in UTC
        Output datetime.datetime object, now in UTC time.

    &#34;&#34;&#34;
    if type(inputDT) is str:
        #tzone = &#39;America/Chicago&#39;
        #Format string to datetime obj
        div = &#39;-&#39;
        timeDiv = &#39;T&#39;
        if &#34;/&#34; in inputDT:
            div = &#39;/&#39;
            hasDate = True
        elif &#39;-&#39; in inputDT:
            div = &#39;-&#39;
            hasDate = True
        else:
            hasDate= False
            year = datetime.datetime.today().year
            month = datetime.datetime.today().month
            day = datetime.datetime.today().day

        if &#39;:&#39; in inputDT:
            hasTime = True
            if &#39;T&#39; in inputDT:
                timeDiv = &#39;T&#39;
            else:
                timeDiv = &#39; &#39;
        else:
            hasTime = False
        
        if hasDate:
            #If first number is 4-dig year (assumes yyyy-dd-mm is not possible)
            if len(inputDT.split(div)[0])&gt;2:
                year = inputDT.split(div)[0]
                month = inputDT.split(div)[1]
                day = inputDT.split(div)[2].split(timeDiv)[0]

            #If last number is 4-dig year            
            elif len(inputDT.split(div)[2].split(timeDiv)[0])&gt;2:
                #..and first number is day
                if int(inputDT.split(div)[0])&gt;12:
                    #dateStr = &#39;%d&#39;+div+&#39;%m&#39;+div+&#39;%Y&#39;   
                    year = inputDT.split(div)[2].split(timeDiv)[0]
                    month = inputDT.split(div)[1]
                    day = inputDT.split(div)[0]
                #...and first number is month (like American style)                             
                else:
                    year = inputDT.split(div)[2].split(timeDiv)[0]
                    month = inputDT.split(div)[0]
                    day = inputDT.split(div)[1]     
            
            #Another way to catch if first number is (2-digit) year
            elif int(inputDT.split(div)[0])&gt;31:
                #dateStr = &#39;%y&#39;+div+&#39;%m&#39;+div+&#39;%d&#39;
                year = inputDT.split(div)[0]
                #Assumes anything less than current year is from this century
                if year &lt; datetime.datetime.today().year:
                    year = &#39;20&#39;+year
                else:#...and anything more than current year is from last century
                    year = &#39;19&#39;+year
                #assumes day will always come last in this instance, as above
                month = inputDT.split(div)[1]
                day = inputDT.split(div)[2].split(timeDiv)[0]

            #If last digit is (2 digit) year           
            elif int(inputDT.split(div)[2].split(timeDiv)[0])&gt;31:
                #...and first digit is day
                if int(inputDT.split(div)[0])&gt;12:
                    #dateStr = &#39;%d&#39;+div+&#39;%m&#39;+div+&#39;%y&#39;       
                    year = inputDT.split(div)[2].split(timeDiv)[0]
                    if year &lt; datetime.datetime.today().year:
                        year = &#39;20&#39;+year
                    else:
                        year = &#39;19&#39;+year
                    month = inputDT.split(div)[1]
                    day = inputDT.split(div)[0]                           
                else: #...and second digit is day
                    #dateStr = &#39;%m&#39;+div+&#39;%d&#39;+div+&#39;%y&#39;
                    year = inputDT.split(div)[2].split(timeDiv)[0]
                    if year &lt; datetime.datetime.today().year:
                        year = &#39;20&#39;+year
                    else:
                        year = &#39;19&#39;+year
                    month = inputDT.split(div)[0]
                    day = inputDT.split(div)[1]                  

        hour=0
        minute=0
        sec=0
        microS=0
        if hasTime:
            if hasDate:
                timeStr = inputDT.split(timeDiv)[1]
            else:
                timeStr = inputDT
            
            if &#39;T&#39; in timeStr:
                timeStr=timeStr.split(&#39;T&#39;)[1]
            elif &#39; &#39; in timeStr:
                timeStr=timeStr.split(&#39; &#39;)[1]

            timeStrList = timeStr.split(&#39;:&#39;)
            if len(timeStrList[0])&gt;2:
                timeStrList[0] = timeStrList[0][-2:]
            elif int(timeStrList[0]) &gt; 23:
                timeStrList[0] = timeStrList[0][-1:]
            
            if len(timeStrList) == 3:
                if &#39;.&#39; in timeStrList[2]:
                    microS = int(timeStrList[2].split(&#39;.&#39;)[1])
                    timeStrList[2] = timeStrList[2].split(&#39;.&#39;)[0]
            elif len(timeStrList) == 2:
                timeStrList.append(&#39;00&#39;)

            hour = int(timeStrList[0])
            minute=int(timeStrList[1])
            sec = int(timeStrList[2])

        outputTimeObj = datetime.datetime(year=int(year),month=int(month), day=int(day),
                                hour=int(hour), minute=int(minute), second=int(sec), microsecond=int(microS))

    elif type(inputDT) is datetime.datetime or type(inputDT) is datetime.time:
        outputTimeObj = inputDT

    #Add timezone info
    availableTimezones = list(map(str.lower, zoneinfo.available_timezones()))
    if outputTimeObj.tzinfo is not None and outputTimeObj.tzinfo.utcoffset(outputTimeObj) is not None:
        #This is already timezone aware
        pass
    elif type(tzone) is int:
        outputTimeObj = outputTimeObj-datetime.timedelta(hours=tzone)
    elif type(tzone) is str:
        if tzone.lower() in availableTimezones:
            outputTimeObj = outputTimeObj.replace(tzinfo=zoneinfo.ZoneInfo(tzone))
        else:
            raise ValueError(&#34;Timezone {} is not in official list. \nAvailable timezones:\n{}&#34;.format(tzone, availableTimezones))
    elif isinstance(tzone, zoneinfo.ZoneInfo):
        outputTimeObj = outputTimeObj.replace(tzinfo=tzone)
    else:
        raise ValueError(&#34;Timezone must be either str or int&#34;)
    
    #Convert to UTC
    outputTimeObj = outputTimeObj.astimezone(datetime.timezone.utc)   

    return outputTimeObj</code></pre>
</details>
</dd>
<dt id="sprit.generate_ppsds"><code class="name flex">
<span>def <span class="ident">generate_ppsds</span></span>(<span>hvsr_data, azimuthal_ppsds=False, verbose=False, **ppsd_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates PPSDs for each channel</p>
<p>Channels need to be in Z, N, E order
Info on PPSD creation here: <a href="https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html">https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict, <a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a> object,</code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Data object containing all the parameters and other data of interest (stream and paz, for example)</dd>
<dt><strong><code>azimuthal_ppsds</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to generate PPSDs for azimuthal data</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print inputs and results to terminal</dd>
<dt><strong><code>**ppsd_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with keyword arguments that are passed directly to obspy.signal.PPSD.
If the following keywords are not specified, their defaults are amended in this function from the obspy defaults for its PPSD function. Specifically:
- ppsd_length defaults to 60 (seconds) here instead of 3600
- skip_on_gaps defaults to True instead of False
- period_step_octaves defaults to 0.03125 instead of 0.125</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>ppsds : HVSRData object
    Dictionary containing entries with ppsds for each channel
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_ppsds(hvsr_data, azimuthal_ppsds=False, verbose=False, **ppsd_kwargs):
    &#34;&#34;&#34;Generates PPSDs for each channel

        Channels need to be in Z, N, E order
        Info on PPSD creation here: https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html
        
        Parameters
        ----------
        hvsr_data : dict, HVSRData object, or HVSRBatch object
            Data object containing all the parameters and other data of interest (stream and paz, for example)
        azimuthal_ppsds : bool, default=False
            Whether to generate PPSDs for azimuthal data
        verbose : bool, default=True
            Whether to print inputs and results to terminal
        **ppsd_kwargs : dict
            Dictionary with keyword arguments that are passed directly to obspy.signal.PPSD.
            If the following keywords are not specified, their defaults are amended in this function from the obspy defaults for its PPSD function. Specifically:
                - ppsd_length defaults to 60 (seconds) here instead of 3600
                - skip_on_gaps defaults to True instead of False
                - period_step_octaves defaults to 0.03125 instead of 0.125

        Returns
        -------
            ppsds : HVSRData object
                Dictionary containing entries with ppsds for each channel
    &#34;&#34;&#34;
    #First, divide up for batch or not
    orig_args = locals().copy() #Get the initial arguments
    start_time = datetime.datetime.now()

    ppsd_kwargs_sprit_defaults = ppsd_kwargs.copy()
    #Set defaults here that are different than obspy defaults
    if &#39;ppsd_length&#39; not in ppsd_kwargs.keys():
        ppsd_kwargs_sprit_defaults[&#39;ppsd_length&#39;] = 30.0
    if &#39;skip_on_gaps&#39; not in ppsd_kwargs.keys():
        ppsd_kwargs_sprit_defaults[&#39;skip_on_gaps&#39;] = True
    if &#39;period_step_octaves&#39; not in ppsd_kwargs.keys():
        ppsd_kwargs_sprit_defaults[&#39;period_step_octaves&#39;] = 0.03125
    if &#39;period_limits&#39; not in ppsd_kwargs.keys():
        ppsd_kwargs_sprit_defaults[&#39;period_limits&#39;] =  [1/40, 1/1]

    #Get Probablistic power spectral densities (PPSDs)
    #Get default args for function
    def get_default_args(func):
        signature = inspect.signature(func)
        return {
            k: v.default
            for k, v in signature.parameters.items()
            if v.default is not inspect.Parameter.empty
            }
    
    ppsd_kwargs = get_default_args(PPSD)
    ppsd_kwargs.update(ppsd_kwargs_sprit_defaults)#Update with sprit defaults, or user input
    orig_args[&#39;ppsd_kwargs&#39;] = ppsd_kwargs

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;generate_ppsds&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            defaultVDict = dict(zip(inspect.getfullargspec(generate_ppsds).args[1:], 
                                    inspect.getfullargspec(generate_ppsds).defaults))
            defaultVDict[&#39;ppsd_kwargs&#39;] = ppsd_kwargs
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;generate_ppsds&#39;].items():
                # Manual input to function overrides the imported parameter values
                if not isinstance(v, (HVSRData, HVSRBatch)) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    orig_args[k] = v

    azimuthal_ppsds = orig_args[&#39;azimuthal_ppsds&#39;]
    verbose = orig_args[&#39;verbose&#39;]
    ppsd_kwargs = orig_args[&#39;ppsd_kwargs&#39;]

    if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nGenerating Probabilistic Power Spectral Densities (generate_ppsds())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key==&#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))
            print()

    #Site is in the keys anytime it&#39;s not batch
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each one
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            individual_params = hvsr_data[site_name] #Get what would normally be the &#34;hvsr_data&#34; variable for each site
            args[&#39;hvsr_data&#39;] = individual_params #reset the hvsr_data parameter we originally read in to an individual site hvsr_data
            #args[&#39;hvsr_data&#39;][&#39;batch&#39;] = False #Set to false, since only running this time
            if hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
                try:
                    hvsr_data[site_name] = _generate_ppsds_batch(**args) #Call another function, that lets us run this function again
                except:
                    hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;PPSDStatus&#39;]=False
                    hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False                     
            else:
                hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;PPSDStatus&#39;]=False
                hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False                
            
            try:
                sprit_gui.update_progress_bars(prog_percent=5)
            except Exception as e:
                pass
                #print(e)
        return hvsr_data
    else:
        paz = hvsr_data[&#39;paz&#39;]
        stream = hvsr_data[&#39;stream&#39;]

        if azimuthal_ppsds:
            #get azimuthal ppsds (in an HVSRBatch object?)
            pass
        else:
            #Get ppsds of e component
            eStream = stream.select(component=&#39;E&#39;)
            estats = eStream.traces[0].stats
            ppsdE = PPSD(estats, paz[&#39;E&#39;],  **ppsd_kwargs)
            ppsdE.add(eStream)

            #Get ppsds of n component
            nStream = stream.select(component=&#39;N&#39;)
            nstats = nStream.traces[0].stats
            ppsdN = PPSD(nstats, paz[&#39;N&#39;], **ppsd_kwargs)
            ppsdN.add(nStream)

            #Get ppsds of z component
            zStream = stream.select(component=&#39;Z&#39;)
            zstats = zStream.traces[0].stats
            ppsdZ = PPSD(zstats, paz[&#39;Z&#39;], **ppsd_kwargs)
            ppsdZ.add(zStream)

            ppsds = {&#39;Z&#39;:ppsdZ, &#39;N&#39;:ppsdN, &#39;E&#39;:ppsdE}

            #Add to the input dictionary, so that some items can be manipulated later on, and original can be saved
            hvsr_data[&#39;ppsds_obspy&#39;] = ppsds
            hvsr_data[&#39;ppsds&#39;] = {}
            anyKey = list(hvsr_data[&#39;ppsds_obspy&#39;].keys())[0]
            
            #Get ppsd class members
            members = [mems for mems in dir(hvsr_data[&#39;ppsds_obspy&#39;][anyKey]) if not callable(mems) and not mems.startswith(&#34;_&#34;)]
            hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;] = {}
            hvsr_data[&#39;ppsds&#39;][&#39;E&#39;] = {}
            hvsr_data[&#39;ppsds&#39;][&#39;N&#39;] = {}
            
            #Get lists/arrays so we can manipulate data later and copy everything over to main &#39;ppsds&#39; subdictionary (convert lists to np.arrays for consistency)
            listList = [&#39;times_data&#39;, &#39;times_gaps&#39;, &#39;times_processed&#39;,&#39;current_times_used&#39;, &#39;psd_values&#39;] #Things that need to be converted to np.array first, for consistency
            timeKeys= [&#39;times_processed&#39;,&#39;current_times_used&#39;,&#39;psd_values&#39;]
            timeDiffWarn = True
            dfList = []
            time_data = {}
            time_dict = {}
            for m in members:
                hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m] = getattr(hvsr_data[&#39;ppsds_obspy&#39;][&#39;Z&#39;], m)
                hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m] = getattr(hvsr_data[&#39;ppsds_obspy&#39;][&#39;E&#39;], m)
                hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m] = getattr(hvsr_data[&#39;ppsds_obspy&#39;][&#39;N&#39;], m)
                if m in listList:
                
                    hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m] = np.array(hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m])
                    hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m] = np.array(hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m])
                    hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m] = np.array(hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m])
                
                if str(m)==&#39;times_processed&#39;:
                    unique_times = np.unique(np.array([hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m],
                                            hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m],
                                            hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m]]))
                    
                    common_times = []
                    for currTime in unique_times:
                        if currTime in hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m]:
                            if currTime in hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m]:
                                if currTime in hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m]:
                                    common_times.append(currTime)

                    cTimeIndList = []
                    for cTime in common_times:
                        ZArr = hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m]
                        EArr = hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m]
                        NArr = hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m]

                        cTimeIndList.append([int(np.where(ZArr == cTime)[0][0]),
                                            int(np.where(EArr == cTime)[0][0]),
                                            int(np.where(NArr == cTime)[0][0])])
                        
                #Make sure number of time windows is the same between PPSDs (this can happen with just a few slightly different number of samples)
                if m in timeKeys:
                    if str(m) != &#39;times_processed&#39;:
                        time_data[str(m)] = (hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m], hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m], hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m])

                    #print(m, hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m])

                    tSteps_same = hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m].shape[0] == hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m].shape[0] == hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m].shape[0]

                    if not tSteps_same:
                        shortestTimeLength = min(hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][m].shape[0], hvsr_data[&#39;ppsds&#39;][&#39;E&#39;][m].shape[0], hvsr_data[&#39;ppsds&#39;][&#39;N&#39;][m].shape[0])

                        maxPctDiff = 0
                        for comp in hvsr_data[&#39;ppsds&#39;].keys():
                            currCompTimeLength = hvsr_data[&#39;ppsds&#39;][comp][m].shape[0]
                            timeLengthDiff = currCompTimeLength - shortestTimeLength
                            percentageDiff = timeLengthDiff / currCompTimeLength
                            if percentageDiff &gt; maxPctDiff:
                                maxPctDiff = percentageDiff

                        for comp in hvsr_data[&#39;ppsds&#39;].keys():
                            while hvsr_data[&#39;ppsds&#39;][comp][m].shape[0] &gt; shortestTimeLength:
                                hvsr_data[&#39;ppsds&#39;][comp][m] = hvsr_data[&#39;ppsds&#39;][comp][m][:-1]
                        
                        
                        if maxPctDiff &gt; 0.05 and timeDiffWarn:
                            warnings.warn(f&#34;\t  Number of ppsd time windows between different components is significantly different: {round(maxPctDiff*100,2)}% &gt; 5%. Last windows will be trimmed.&#34;)
                        elif verbose  and timeDiffWarn:
                            print(f&#34;\t  Number of ppsd time windows between different components is different by {round(maxPctDiff*100,2)}%. Last window(s) of components with larger number of ppsd windows will be trimmed.&#34;)
                        timeDiffWarn = False #So we only do this warning once, even though there are multiple arrays that need to be trimmed

            for i, currTStep in enumerate(cTimeIndList):
                colList = []
                currTStepList = []
                colList.append(&#39;TimesProcessed_Obspy&#39;)
                currTStepList.append(common_times[i])
                for tk in time_data.keys():
                    colList.append(str(tk)+&#39;_Z&#39;)
                    colList.append(str(tk)+&#39;_E&#39;)
                    colList.append(str(tk)+&#39;_N&#39;)
                    currTStepList.append(time_data[tk][0][currTStep[0]])#z
                    currTStepList.append(time_data[tk][1][currTStep[1]])#e
                    currTStepList.append(time_data[tk][2][currTStep[2]])#n

                dfList.append(currTStepList)
                
            hvsrDF = pd.DataFrame(dfList, columns=colList)
            hvsrDF[&#39;TimesProcessed_ObspyEnd&#39;] = hvsrDF[&#39;TimesProcessed_Obspy&#39;] + ppsd_kwargs[&#39;ppsd_length&#39;]
            
            #Add other times (for start times)
            def convert_to_datetime(obspyUTCDateTime):
                return obspyUTCDateTime.datetime.replace(tzinfo=datetime.timezone.utc)

            def convert_to_mpl_dates(obspyUTCDateTime):
                return obspyUTCDateTime.matplotlib_date

            hvsrDF[&#39;TimesProcessed&#39;] = hvsrDF[&#39;TimesProcessed_Obspy&#39;].apply(convert_to_datetime)     
            hvsrDF[&#39;TimesProcessed_End&#39;] = hvsrDF[&#39;TimesProcessed&#39;] + datetime.timedelta(days=0,seconds=ppsd_kwargs[&#39;ppsd_length&#39;])
            hvsrDF[&#39;TimesProcessed_MPL&#39;] = hvsrDF[&#39;TimesProcessed_Obspy&#39;].apply(convert_to_mpl_dates)
            hvsrDF[&#39;TimesProcessed_MPLEnd&#39;] = hvsrDF[&#39;TimesProcessed_MPL&#39;] + (ppsd_kwargs[&#39;ppsd_length&#39;]/86400)
            
            hvsrDF[&#39;Use&#39;] = True
            hvsrDF[&#39;Use&#39;]=hvsrDF[&#39;Use&#39;].astype(bool)
            for gap in hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][&#39;times_gaps&#39;]:
                hvsrDF[&#39;Use&#39;] = (hvsrDF[&#39;TimesProcessed_MPL&#39;].gt(gap[1].matplotlib_date))| \
                                (hvsrDF[&#39;TimesProcessed_MPLEnd&#39;].lt(gap[0].matplotlib_date))# | \
            
            hvsrDF[&#39;Use&#39;] = hvsrDF[&#39;Use&#39;].astype(bool)
            if &#39;xwindows_out&#39; in hvsr_data.keys():
                for window in hvsr_data[&#39;xwindows_out&#39;]:
                    hvsrDF[&#39;Use&#39;] = (hvsrDF[&#39;TimesProcessed_MPL&#39;][hvsrDF[&#39;Use&#39;]].lt(window[0]) &amp; hvsrDF[&#39;TimesProcessed_MPLEnd&#39;][hvsrDF[&#39;Use&#39;]].lt(window[0]) )| \
                            (hvsrDF[&#39;TimesProcessed_MPL&#39;][hvsrDF[&#39;Use&#39;]].gt(window[1]) &amp; hvsrDF[&#39;TimesProcessed_MPLEnd&#39;][hvsrDF[&#39;Use&#39;]].gt(window[1]))
                hvsrDF[&#39;Use&#39;] = hvsrDF[&#39;Use&#39;].astype(bool)
                
            hvsrDF.set_index(&#39;TimesProcessed&#39;, inplace=True)
            hvsr_data[&#39;hvsr_df&#39;] = hvsrDF
            #Create dict entry to keep track of how many outlier hvsr curves are removed (2-item list with [0]=current number, [1]=original number of curves)
            hvsr_data[&#39;tsteps_used&#39;] = [hvsrDF[&#39;Use&#39;].sum(), hvsrDF[&#39;Use&#39;].shape[0]]
            #hvsr_data[&#39;tsteps_used&#39;] = [hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][&#39;times_processed&#39;].shape[0], hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][&#39;times_processed&#39;].shape[0]]
            
            hvsr_data[&#39;tsteps_used&#39;][0] = hvsr_data[&#39;ppsds&#39;][&#39;Z&#39;][&#39;current_times_used&#39;].shape[0]
            
            hvsr_data = sprit_utils.make_it_classy(hvsr_data)
        
            if &#39;processing_parameters&#39; not in hvsr_data.keys():
                hvsr_data[&#39;processing_parameters&#39;] = {}
            hvsr_data[&#39;processing_parameters&#39;][&#39;generate_ppsds&#39;] = {}
            for key, value in orig_args.items():
                hvsr_data[&#39;processing_parameters&#39;][&#39;generate_ppsds&#39;][key] = value

    hvsr_data[&#39;ProcessingStatus&#39;][&#39;PPSDStatus&#39;] = True
    hvsr_data = _check_processing_status(hvsr_data, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)
    return hvsr_data</code></pre>
</details>
</dd>
<dt id="sprit.get_char"><code class="name flex">
<span>def <span class="ident">get_char</span></span>(<span>in_char)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs character with proper encoding/decoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_char(in_char):
    &#34;&#34;&#34;Outputs character with proper encoding/decoding&#34;&#34;&#34;
    if in_char in greek_chars.keys():
        out_char = greek_chars[in_char].encode(encoding=&#39;utf-8&#39;)
    else:
        out_char = in_char.encode(encoding=&#39;utf-8&#39;)
    return out_char.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="sprit.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>params, write_path='', update_metadata=True, source=None, **read_inventory_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get metadata and calculate or get paz parameter needed for PPSD</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the input and other parameters needed for processing
Ouput from input_params() function</dd>
<dt><strong><code>write_path</code></strong> :&ensp;<code>str</code></dt>
<dd>String with output filepath of where to write updated inventory or metadata file
If not specified, does not write file</dd>
<dt><strong><code>update_metadata</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to update the metadata file itself, or just read as-is. If using provided raspberry shake metadata file, select True.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>This passes the source variable value to _read_RS_metadata. It is expected that this is passed directly from the source parameter of sprit.fetch_data()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Modified input dictionary with additional key:value pair containing paz dictionary (key = "paz")</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata(params, write_path=&#39;&#39;, update_metadata=True, source=None, **read_inventory_kwargs):
    &#34;&#34;&#34;Get metadata and calculate or get paz parameter needed for PPSD

    Parameters
    ----------
    params : dict
        Dictionary containing all the input and other parameters needed for processing
            Ouput from input_params() function
    write_path : str
        String with output filepath of where to write updated inventory or metadata file
            If not specified, does not write file 
    update_metadata : bool
        Whether to update the metadata file itself, or just read as-is. If using provided raspberry shake metadata file, select True.
    source : str, default=None
        This passes the source variable value to _read_RS_metadata. It is expected that this is passed directly from the source parameter of sprit.fetch_data()

    Returns
    -------
    params : dict
        Modified input dictionary with additional key:value pair containing paz dictionary (key = &#34;paz&#34;)
    &#34;&#34;&#34;
    invPath = params[&#39;metapath&#39;]
    raspShakeInstNameList = [&#39;raspberry shake&#39;, &#39;shake&#39;, &#39;raspberry&#39;, &#39;rs&#39;, &#39;rs3d&#39;, &#39;rasp. shake&#39;, &#39;raspshake&#39;]
    trominoNameList = [&#39;tromino&#39;, &#39;trom&#39;, &#39;trm&#39;, &#39;t&#39;]
    if params[&#39;instrument&#39;].lower() in raspShakeInstNameList:
        if update_metadata:
            params = _update_shake_metadata(filepath=invPath, params=params, write_path=write_path)
        params = _read_RS_Metadata(params, source=source)
    elif params[&#39;instrument&#39;].lower() in trominoNameList:
        params[&#39;paz&#39;] = {&#39;Z&#39;:{}, &#39;E&#39;:{}, &#39;N&#39;:{}}
        #ALL THESE VALUES ARE PLACEHOLDERS, taken from RASPBERRY SHAKE! (Needed for PPSDs)
        params[&#39;paz&#39;][&#39;Z&#39;] = {&#39;sensitivity&#39;: 360000000.0,
                              &#39;gain&#39;: 360000000.0,
                              &#39;poles&#39;: [(-1+0j), (-3.03+0j), (-3.03+0j), (-666.67+0j)],  
                              &#39;zeros&#39;: [0j, 0j, 0j]}
        params[&#39;paz&#39;][&#39;E&#39;] =  params[&#39;paz&#39;][&#39;Z&#39;]
        params[&#39;paz&#39;][&#39;N&#39;] =  params[&#39;paz&#39;][&#39;Z&#39;]

        channelObj_Z = obspy.core.inventory.channel.Channel(code=&#39;BHZ&#39;, location_code=&#39;00&#39;, latitude=params[&#39;params&#39;][&#39;latitude&#39;], 
                                                longitude=params[&#39;params&#39;][&#39;longitude&#39;], elevation=params[&#39;params&#39;][&#39;elevation&#39;], depth=params[&#39;params&#39;][&#39;depth&#39;], 
                                                azimuth=0, dip=90, types=None, external_references=None, 
                                                sample_rate=None, sample_rate_ratio_number_samples=None, sample_rate_ratio_number_seconds=None,
                                                storage_format=None, clock_drift_in_seconds_per_sample=None, calibration_units=None, 
                                                calibration_units_description=None, sensor=None, pre_amplifier=None, data_logger=None,
                                                equipments=None, response=None, description=None, comments=None, start_date=None, end_date=None, 
                                                restricted_status=None, alternate_code=None, historical_code=None, data_availability=None, 
                                                identifiers=None, water_level=None, source_id=None)
        channelObj_E = obspy.core.inventory.channel.Channel(code=&#39;BHE&#39;, location_code=&#39;00&#39;, latitude=params[&#39;params&#39;][&#39;latitude&#39;], 
                                                longitude=params[&#39;params&#39;][&#39;longitude&#39;], elevation=params[&#39;params&#39;][&#39;elevation&#39;], depth=params[&#39;params&#39;][&#39;depth&#39;], 
                                                azimuth=90, dip=0) 
        
        channelObj_N = obspy.core.inventory.channel.Channel(code=&#39;BHN&#39;, location_code=&#39;00&#39;, latitude=params[&#39;params&#39;][&#39;latitude&#39;], 
                                                longitude=params[&#39;params&#39;][&#39;longitude&#39;], elevation=params[&#39;params&#39;][&#39;elevation&#39;], depth=params[&#39;params&#39;][&#39;depth&#39;], 
                                                azimuth=0, dip=0) 
        
        siteObj = obspy.core.inventory.util.Site(name=params[&#39;params&#39;][&#39;site&#39;], description=None, town=None, county=None, region=None, country=None)
        stationObj = obspy.core.inventory.station.Station(code=&#39;TZ&#39;, latitude=params[&#39;params&#39;][&#39;latitude&#39;], longitude=params[&#39;params&#39;][&#39;longitude&#39;], 
                                            elevation=params[&#39;params&#39;][&#39;elevation&#39;], channels=[channelObj_Z, channelObj_E, channelObj_N], site=siteObj, 
                                            vault=None, geology=None, equipments=None, operators=None, creation_date=datetime.datetime.today(),
                                            termination_date=None, total_number_of_channels=None, 
                                            selected_number_of_channels=None, description=&#39;Estimated data for Tromino, this is NOT from the manufacturer&#39;,
                                            comments=None, start_date=None, 
                                            end_date=None, restricted_status=None, alternate_code=None, historical_code=None, 
                                            data_availability=None, identifiers=None, water_level=None, source_id=None)

        network = [obspy.core.inventory.network.Network(code=&#39;TROM&#39;, stations=[stationObj], total_number_of_stations=None, 
                                            selected_number_of_stations=None, description=None, comments=None, start_date=None, 
                                            end_date=None, restricted_status=None, alternate_code=None, historical_code=None, 
                                            data_availability=None, identifiers=None, operators=None, source_id=None)]
        
        params[&#39;inv&#39;] = obspy.Inventory(networks=network)
    else:
        if not invPath:
            pass #if invPath is None
        elif not pathlib.Path(invPath).exists() or invPath==&#39;&#39;:
            warnings.warn(f&#34;The metapath parameter was not specified correctly. Returning original params value {params[&#39;metapath&#39;]}&#34;)
        readInvKwargs = {}
        argspecs = inspect.getfullargspec(obspy.read_inventory)
        for argName in argspecs[0]:
            if argName in read_inventory_kwargs.keys():
                readInvKwargs[argName] = read_inventory_kwargs[argName]

        readInvKwargs[&#39;path_or_file_object&#39;] = invPath
        params[&#39;inv&#39;] = obspy.read_inventory(invPath)
        if &#39;params&#39; in params.keys():
            params[&#39;params&#39;][&#39;inv&#39;] = params[&#39;inv&#39;]

    return params</code></pre>
</details>
</dd>
<dt id="sprit.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>hvsr_results, report_format='print', plot_type='HVSR p ann C+ p ann Spec', export_path=None, csv_overwrite_opt='append', no_output=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a report of the HVSR analysis in a variety of formats.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the information about the processed hvsr data</dd>
<dt><strong><code>report_format</code></strong> :&ensp;<code>{'csv', 'print', plot}</code></dt>
<dd>Format in which to print or export the report.
The following report_formats return the following items in the following attributes:
- 'plot': hvsr_results['Print_Report'] as a str str
- 'print': hvsr_results['HV_Plot'] - matplotlib.Figure object
- 'csv':
hvsr_results['CSV_Report']- pandas.DataFrame object
- list/tuple - a list or tuple of the above objects, in the same order they are in the report_format list</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>str</code>, default <code>= 'HVSR p ann C+ p ann Spec</code></dt>
<dd>What type of plot to plot, if 'plot' part of report_format input</dd>
<dt><strong><code>export_path</code></strong> :&ensp;<code>None, bool,</code> or <code>filepath</code>, default <code>= None</code></dt>
<dd>If None or False, does not export; if True, will export to same directory as the datapath parameter in the input_params() function.
Otherwise, it should be a string or path object indicating where to export results. May be a file or directory.
If a directory is specified, the filename will be
"<site_name><em><acq_date></em><UTC start time>-<UTC end time>". The suffix defaults to png for report_format="plot", csv for 'csv', and does not export if 'print.'</dd>
<dt><strong><code>csv_overwrite_opts</code></strong> :&ensp;<code>str, {'append', 'overwrite', 'keep/rename'}</code></dt>
<dd>How to handle csv report outputs if the designated csv output file already exists. By default, appends the new information to the end of the existing file.</dd>
<dt><strong><code>no_output</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, only reads output to appropriate attribute of data class (ie, print does not print, only reads text into variable). If False, performs as normal.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print the results to terminal. This is the same output as report_format='print', and will not repeat if that is already selected</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_report(hvsr_results, report_format=&#39;print&#39;, plot_type=&#39;HVSR p ann C+ p ann Spec&#39;, export_path=None, csv_overwrite_opt=&#39;append&#39;, no_output=False, verbose=False):    
    &#34;&#34;&#34;Get a report of the HVSR analysis in a variety of formats.
        
    Parameters
    ----------
    hvsr_results : dict
        Dictionary containing all the information about the processed hvsr data
    report_format : {&#39;csv&#39;, &#39;print&#39;, plot}
        Format in which to print or export the report.
        The following report_formats return the following items in the following attributes:
            - &#39;plot&#39;: hvsr_results[&#39;Print_Report&#39;] as a str str
            - &#39;print&#39;: hvsr_results[&#39;HV_Plot&#39;] - matplotlib.Figure object
            - &#39;csv&#39;:  hvsr_results[&#39;CSV_Report&#39;]- pandas.DataFrame object
                - list/tuple - a list or tuple of the above objects, in the same order they are in the report_format list
    plot_type : str, default = &#39;HVSR p ann C+ p ann Spec
        What type of plot to plot, if &#39;plot&#39; part of report_format input
    export_path : None, bool, or filepath, default = None
        If None or False, does not export; if True, will export to same directory as the datapath parameter in the input_params() function.
        Otherwise, it should be a string or path object indicating where to export results. May be a file or directory.
        If a directory is specified, the filename will be  &#34;&lt;site_name&gt;_&lt;acq_date&gt;_&lt;UTC start time&gt;-&lt;UTC end time&gt;&#34;. The suffix defaults to png for report_format=&#34;plot&#34;, csv for &#39;csv&#39;, and does not export if &#39;print.&#39;
    csv_overwrite_opts : str, {&#39;append&#39;, &#39;overwrite&#39;, &#39;keep/rename&#39;}
        How to handle csv report outputs if the designated csv output file already exists. By default, appends the new information to the end of the existing file.
    no_output : bool, default=False
        If True, only reads output to appropriate attribute of data class (ie, print does not print, only reads text into variable). If False, performs as normal.
    verbose : bool, default=True
        Whether to print the results to terminal. This is the same output as report_format=&#39;print&#39;, and will not repeat if that is already selected

    Returns
    -------
    sprit.HVSRData
    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_results.keys():
        if &#39;get_report&#39; in hvsr_results[&#39;processing_parameters&#39;].keys():
            for k, v in hvsr_results[&#39;processing_parameters&#39;][&#39;get_report&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(get_report).args[1:], 
                                        inspect.getfullargspec(get_report).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    orig_args[k] = v

    report_format = orig_args[&#39;report_format&#39;]
    plot_type = orig_args[&#39;plot_type&#39;]
    export_path = orig_args[&#39;export_path&#39;]
    csv_overwrite_opt = orig_args[&#39;csv_overwrite_opt&#39;]
    no_output = orig_args[&#39;no_output&#39;]
    verbose = orig_args[&#39;verbose&#39;]
    
    if (verbose and isinstance(hvsr_results, HVSRBatch)) or (verbose and not hvsr_results[&#39;batch&#39;]):
        if isinstance(hvsr_results, HVSRData) and hvsr_results[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nGetting HVSR Report: get_report()&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key==&#39;params&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))
            print()

    if isinstance(hvsr_results, HVSRBatch):
        if verbose:
            print(&#39;\nGetting Reports: Running in batch mode&#39;)

            print(&#39;\tUsing parameters:&#39;)
            for key, value in orig_args.items():
                print(f&#39;\t  {key}={value}&#39;)    
            print()
        #If running batch, we&#39;ll loop through each site
        for site_name in hvsr_results.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            individual_params = hvsr_results[site_name] #Get what would normally be the &#34;params&#34; variable for each site
            args[&#39;hvsr_results&#39;] = individual_params #reset the params parameter we originally read in to an individual site params
            if hvsr_results[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
                try:
                    hvsr_results[site_name] = _get_report_batch(**args) #Call another function, that lets us run this function again
                except:
                    hvsr_results[site_name] = hvsr_results[site_name]
            else:
                hvsr_results[site_name] = hvsr_results[site_name]
        
        combined_csvReport = pd.DataFrame()
        for site_name in hvsr_results.keys():
            if &#39;CSV_Report&#39; in hvsr_results[site_name].keys():
                combined_csvReport = pd.concat([combined_csvReport, hvsr_results[site_name][&#39;CSV_Report&#39;]], ignore_index=True, join=&#39;inner&#39;)
        
        if export_path is not None:
            if export_path is True:
                if pathlib.Path(hvsr_results[&#39;input_params&#39;][&#39;datapath&#39;]) in sampleFileKeyMap.values():
                    csvExportPath = pathlib.Path(os.getcwd())
                else:
                    csvExportPath = pathlib.Path(hvsr_results[&#39;input_params&#39;][&#39;datapath&#39;])
            elif pathlib.Path(export_path).is_dir():
                csvExportPath = export_path
            elif pathlib.Path(export_path).is_file():
                csvExportPath = export_path.parent
            else:
                csvExportPath = pathlib.Path(hvsr_results[site_name].datapath)
                if csvExportPath.is_dir():
                    pass
                else:
                    csvExportPath = csvExportPath.parent
                
            combined_csvReport.to_csv(csvExportPath, index=False)
        
    else:       
        #if &#39;BestPeak&#39; in hvsr_results.keys() and &#39;PassList&#39; in hvsr_results[&#39;BestPeak&#39;].keys():
        try:
            curvTestsPassed = (hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;WindowLengthFreq.&#39;] +
                                hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;SignificantCycles&#39;]+
                                hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;LowCurveStDevOverTime&#39;])
            curvePass = curvTestsPassed &gt; 2
            
            #Peak Pass?
            peakTestsPassed = ( hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;PeakProminenceBelow&#39;] +
                        hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;PeakProminenceAbove&#39;]+
                        hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;PeakAmpClarity&#39;]+
                        hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;FreqStability&#39;]+
                        hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;PeakStability_FreqStD&#39;]+
                        hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;PeakStability_AmpStD&#39;])
            peakPass = peakTestsPassed &gt;= 5
        except Exception as e:
            errMsg= &#39;No BestPeak identified. Check peak_freq_range or hvsr_band or try to remove bad noise windows using remove_noise() or change processing parameters in process_hvsr() or generate_ppsds(). Otherwise, data may not be usable for HVSR.&#39;
            print(errMsg)
            print(e)
            return hvsr_results
            #raise RuntimeError(&#39;No BestPeak identified. Check peak_freq_range or hvsr_band or try to remove bad noise windows using remove_noise() or change processing parameters in process_hvsr() or generate_ppsds(). Otherwise, data may not be usable for HVSR.&#39;)
    
        if isinstance(report_format, (list, tuple)):
            pass
        else:
            #We will use a loop later even if it&#39;s just one report type, so reformat to prepare for for loop
            allList = [&#39;:&#39;, &#39;all&#39;]
            if report_format.lower() in allList:
                report_format = [&#39;print&#39;, &#39;csv&#39;, &#39;plot&#39;]
            else:
                report_format = [report_format]   

        def export_report(export_obj, _export_path, _rep_form):
            if _export_path is None:
                return
            else:
                if _rep_form == &#39;csv&#39;:
                    ext = &#39;.csv&#39;
                elif _rep_form ==&#39;plot&#39;:
                    ext=&#39;.png&#39;
                else:
                    ext=&#39;&#39;
                    
                sitename=hvsr_results[&#39;input_params&#39;][&#39;site&#39;]#.replace(&#39;.&#39;, &#39;-&#39;)
                fname = f&#34;{sitename}_{hvsr_results[&#39;input_params&#39;][&#39;acq_date&#39;]}_{str(hvsr_results[&#39;input_params&#39;][&#39;starttime&#39;].time)[:5]}-{str(hvsr_results[&#39;input_params&#39;][&#39;endtime&#39;].time)[:5]}{ext}&#34;
                fname = fname.replace(&#39;:&#39;, &#39;&#39;)

                if _export_path==True:
                    #Check so we don&#39;t write in sample directory
                    if pathlib.Path(hvsr_results[&#39;input_params&#39;][&#39;datapath&#39;]) in sampleFileKeyMap.values():
                        if pathlib.Path(os.getcwd()) in sampleFileKeyMap.values(): #Just in case current working directory is also sample directory
                            inFile = pathlib.Path.home() #Use the path to user&#39;s home if all else fails
                        else:
                            inFile = pathlib.Path(os.getcwd())
                    else:
                        inFile = pathlib.Path(hvsr_results[&#39;input_params&#39;][&#39;datapath&#39;])
                                 
                    if inFile.is_dir():
                        outFile = inFile.joinpath(fname)
                    else:
                        outFile = inFile.with_name(fname)
                else:
                    if pathlib.Path(_export_path).is_dir():
                        outFile = pathlib.Path(_export_path).joinpath(fname)
                    else:
                        outFile=pathlib.Path(_export_path)

            if _rep_form == &#39;csv&#39;:
                if outFile.exists():
                    existFile = pd.read_csv(outFile)
                    if csv_overwrite_opt.lower() == &#39;append&#39;:
                        export_obj = pd.concat([existFile, export_obj], ignore_index=True, join=&#39;inner&#39;)
                    elif csv_overwrite_opt.lower() == &#39;overwrite&#39;:
                        pass
                    else:# csv_overwrite_opt.lower() in [&#39;keep&#39;, &#39;rename&#39;]:
                        fileNameExists = True
                        i=1
                        while fileNameExists:
                            outFile = outFile.with_stem(f&#34;{outFile.stem}_{i}&#34;)
                            i+=1
                            if not outFile.exists():
                                fileNameExists = False
                try:
                    print(f&#39;\nSaving csv data to: {outFile}&#39;)
                    export_obj.to_csv(outFile, index_label=&#39;ID&#39;)
                except:
                    warnings.warn(&#34;Report not exported. \n\tDataframe to be exported as csv has been saved in hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;CSV_Report]&#34;, category=RuntimeWarning)
            elif _rep_form ==&#39;plot&#39;:
                if verbose:
                    print(f&#39;\nSaving plot to: {outFile}&#39;)
                plt.scf = export_obj
                plt.savefig(outFile)
            return 

        def report_output(_report_format, _plot_type=&#39;HVSR p ann C+ p ann Spec&#39;, _export_path=None, _no_output=False, verbose=False):
            if _report_format==&#39;print&#39;:
                #Print results

                #Make separators for nicely formatted print output
                sepLen = 99
                siteSepSymbol = &#39;=&#39;
                intSepSymbol = u&#34;\u2013&#34;
                extSepSymbol = u&#34;\u2014&#34;
                
                if sepLen % 2 == 0:
                    remainVal = 1
                else:
                    remainVal = 0

                siteWhitespace = 2
                #Format the separator lines internal to each site
                internalSeparator = intSepSymbol.center(sepLen-4, intSepSymbol).center(sepLen, &#39; &#39;)

                extSiteSeparator = &#34;&#34;.center(sepLen, extSepSymbol)
                siteSeparator = f&#34;{hvsr_results[&#39;input_params&#39;][&#39;site&#39;]}&#34;.center(sepLen - siteWhitespace, &#39; &#39;).center(sepLen, siteSepSymbol)
                endSiteSeparator = &#34;&#34;.center(sepLen, siteSepSymbol)

                #Start building list to print
                report_string_list = []
                report_string_list.append(&#34;&#34;) #Blank line to start
                report_string_list.append(extSiteSeparator)
                report_string_list.append(siteSeparator)
                report_string_list.append(extSiteSeparator)
                #report_string_list.append(internalSeparator)
                report_string_list.append(&#39;&#39;)
                report_string_list.append(f&#34;\tSite Name: {hvsr_results[&#39;input_params&#39;][&#39;site&#39;]}&#34;)
                report_string_list.append(f&#34;\tAcq. Date: {hvsr_results[&#39;input_params&#39;][&#39;acq_date&#39;]}&#34;)
                report_string_list.append(f&#34;\tLocation : {hvsr_results[&#39;input_params&#39;][&#39;longitude&#39;]}, {hvsr_results[&#39;input_params&#39;][&#39;latitude&#39;]}&#34;)
                report_string_list.append(f&#34;\tElevation: {hvsr_results[&#39;input_params&#39;][&#39;elevation&#39;]}&#34;)
                report_string_list.append(&#39;&#39;)
                report_string_list.append(internalSeparator)
                report_string_list.append(&#39;&#39;)
                if &#39;BestPeak&#39; not in hvsr_results.keys():
                    report_string_list.append(&#39;\tNo identifiable BestPeak was present between {} for {}&#39;.format(hvsr_results[&#39;input_params&#39;][&#39;hvsr_band&#39;], hvsr_results[&#39;input_params&#39;][&#39;site&#39;]))
                else:
                    report_string_list.append(&#39;\t{0:.3f} Hz Peak Frequency&#39;.format(hvsr_results[&#39;BestPeak&#39;][&#39;f0&#39;]))        
                    if curvePass and peakPass:
                        report_string_list.append(&#39;\t  {} Curve at {} Hz passed quality checks! ☺ :D&#39;.format(sprit_utils.check_mark(), round(hvsr_results[&#39;BestPeak&#39;][&#39;f0&#39;],3)))
                    else:
                        report_string_list.append(&#39;\t  {} Peak at {} Hz did NOT pass quality checks ☹:(&#39;.format(sprit_utils.x_mark(), round(hvsr_results[&#39;BestPeak&#39;][&#39;f0&#39;],3)))            
                    report_string_list.append(&#39;&#39;)
                    report_string_list.append(internalSeparator)
                    report_string_list.append(&#39;&#39;)

                    justSize=34
                    #Print individual results
                    report_string_list.append(&#39;\tCurve Tests: {}/3 passed (3/3 needed)&#39;.format(curvTestsPassed))
                    report_string_list.append(f&#34;\t\t {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Lw&#39;][-1]}&#34;+&#34; Length of processing windows&#34;.ljust(justSize)+f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Lw&#39;]}&#34;)
                    report_string_list.append(f&#34;\t\t {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Nc&#39;][-1]}&#34;+&#34; Number of significant cycles&#34;.ljust(justSize)+f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Nc&#39;]}&#34;)
                    report_string_list.append(f&#34;\t\t {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;σ_A(f)&#39;][-1]}&#34;+&#34; Small H/V StDev over time&#34;.ljust(justSize)+f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;σ_A(f)&#39;]}&#34;)

                    report_string_list.append(&#39;&#39;)
                    report_string_list.append(&#34;\tPeak Tests: {}/6 passed (5/6 needed)&#34;.format(peakTestsPassed))
                    report_string_list.append(f&#34;\t\t {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;A(f-)&#39;][-1]}&#34;+&#34; Peak is prominent below&#34;.ljust(justSize)+f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;A(f-)&#39;]}&#34;)
                    report_string_list.append(f&#34;\t\t {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;A(f+)&#39;][-1]}&#34;+&#34; Peak is prominent above&#34;.ljust(justSize)+f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;A(f+)&#39;]}&#34;)
                    report_string_list.append(f&#34;\t\t {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;A0&#39;][-1]}&#34;+&#34; Peak is large&#34;.ljust(justSize)+f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;A0&#39;]}&#34;)
                    if hvsr_results[&#39;BestPeak&#39;][&#39;PassList&#39;][&#39;FreqStability&#39;]:
                        res = sprit_utils.check_mark()
                    else:
                        res = sprit_utils.x_mark()
                    report_string_list.append(f&#34;\t\t {res}&#34;+ &#34; Peak freq. is stable over time&#34;.ljust(justSize)+ f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;P-&#39;][:5]} and {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;P+&#39;][:-1]} {res}&#34;)
                    report_string_list.append(f&#34;\t\t {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Sf&#39;][-1]}&#34;+&#34; Stability of peak (Freq. StDev)&#34;.ljust(justSize)+f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Sf&#39;]}&#34;)
                    report_string_list.append(f&#34;\t\t {hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Sa&#39;][-1]}&#34;+&#34; Stability of peak (Amp. StDev)&#34;.ljust(justSize)+f&#34;{hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Sa&#39;]}&#34;)
                report_string_list.append(&#39;&#39;)
                report_string_list.append(f&#34;Calculated using {hvsr_results[&#39;hvsr_df&#39;][&#39;Use&#39;].sum()}/{hvsr_results[&#39;hvsr_df&#39;][&#39;Use&#39;].count()} time windows&#34;.rjust(sepLen-1))
                report_string_list.append(extSiteSeparator)
                #report_string_list.append(endSiteSeparator)
                #report_string_list.append(extSiteSeparator)
                report_string_list.append(&#39;&#39;)
                
                reportStr=&#39;&#39;
                #Now print it
                for line in report_string_list:
                    reportStr = reportStr+&#39;\n&#39;+line

                if not _no_output:
                    print(reportStr)

                export_report(export_obj=reportStr, _export_path=_export_path, _rep_form=_report_format)
                hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Print_Report&#39;] = reportStr
                hvsr_results[&#39;Print_Report&#39;] = reportStr

            elif _report_format==&#39;csv&#39;:
                import pandas as pd
                pdCols = [&#39;Site Name&#39;, &#39;Acq_Date&#39;, &#39;Longitude&#39;, &#39;Latitide&#39;, &#39;Elevation&#39;, &#39;PeakFrequency&#39;, 
                        &#39;WindowLengthFreq.&#39;,&#39;SignificantCycles&#39;,&#39;LowCurveStDevOverTime&#39;,
                        &#39;PeakProminenceBelow&#39;,&#39;PeakProminenceAbove&#39;,&#39;PeakAmpClarity&#39;,&#39;FreqStability&#39;, &#39;PeakStability_FreqStD&#39;,&#39;PeakStability_AmpStD&#39;, &#39;PeakPasses&#39;]
                d = hvsr_results
                criteriaList = []
                for p in hvsr_results[&#39;BestPeak&#39;][&#34;PassList&#34;]:
                    criteriaList.append(hvsr_results[&#39;BestPeak&#39;][&#34;PassList&#34;][p])
                criteriaList.append(hvsr_results[&#39;BestPeak&#39;][&#34;PeakPasses&#34;])
                dfList = [[d[&#39;input_params&#39;][&#39;site&#39;], d[&#39;input_params&#39;][&#39;acq_date&#39;], d[&#39;input_params&#39;][&#39;longitude&#39;], d[&#39;input_params&#39;][&#39;latitude&#39;], d[&#39;input_params&#39;][&#39;elevation&#39;], round(d[&#39;BestPeak&#39;][&#39;f0&#39;], 3)]]
                dfList[0].extend(criteriaList)
                outDF = pd.DataFrame(dfList, columns=pdCols)

                if verbose:
                    print(&#39;\nCSV Report:\n&#39;)
                    maxColWidth = 13
                    print(&#39;  &#39;, end=&#39;&#39;)
                    for col in outDF.columns:
                        if len(str(col)) &gt; maxColWidth:
                            colStr = str(col)[:maxColWidth-3]+&#39;...&#39;
                        else:
                            colStr = str(col)
                        print(colStr.ljust(maxColWidth), end=&#39;  &#39;)
                    print() #new line
                    for c in range(len(outDF.columns) * (maxColWidth+2)):
                        if c % (maxColWidth+2) == 0:
                            print(&#39;|&#39;, end=&#39;&#39;)
                        else:
                            print(&#39;-&#39;, end=&#39;&#39;)
                    print(&#39;|&#39;) #new line
                    print(&#39;  &#39;, end=&#39;&#39;) #Small indent at start                    
                    for row in outDF.iterrows():
                        for col in row[1]:
                            if len(str(col)) &gt; maxColWidth:
                                colStr = str(col)[:maxColWidth-3]+&#39;...&#39;
                            else:
                                colStr = str(col)
                            print(colStr.ljust(maxColWidth), end=&#39;  &#39;)
                        print()

                try:
                    export_report(export_obj=outDF, _export_path=_export_path, _rep_form=_report_format)
                except:
                    print(&#34;Error in exporting csv report. CSV not exported&#34;)
                hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;CSV_Report&#39;] = outDF
                hvsr_results[&#39;CSV_Report&#39;] = outDF
                        
            elif _report_format==&#39;plot&#39;:
                fig_ax = plot_hvsr(hvsr_results, plot_type=_plot_type, show=False, return_fig=True)

                export_report(export_obj=fig_ax[0], _export_path=_export_path, _rep_form=_report_format)
                hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;HV_Plot&#39;]=hvsr_results[&#39;HV_Plot&#39;]=fig_ax

                print(&#39;\nPlot of data report:&#39;)
                plt.show()
                
            return hvsr_results

        for i, rep_form in enumerate(report_format):
            if isinstance(export_path, (list, tuple)):
                if not isinstance(report_format, (list, tuple)):
                    warnings.warn(&#39;export_path is a list/tuple and report_format is not. This may result in unexpected behavior.&#39;)
                if isinstance(report_format, (list, tuple)) and isinstance(export_path, (list, tuple)) and len(report_format) != len(export_path):
                    warnings.warn(&#39;export_path and report_format are both lists or tuples, but they are not the same length. This may result in unexpected behavior.&#39;)
            
                exp_path = export_path[i]
            else:
                exp_path = export_path
            hvsr_results = report_output(_report_format=rep_form, _plot_type=plot_type, _export_path=exp_path, _no_output=no_output, verbose=verbose)

        hvsr_results[&#39;processing_parameters&#39;][&#39;get_report&#39;] = {}
        for key, value in orig_args.items():
            hvsr_results[&#39;processing_parameters&#39;][&#39;get_report&#39;][key] = value

    return hvsr_results</code></pre>
</details>
</dd>
<dt id="sprit.gui"><code class="name flex">
<span>def <span class="ident">gui</span></span>(<span>kind='default')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to open a graphical user interface (gui)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>What type of gui to open. "default" opens regular windowed interface,
"widget" opens jupyter widget'
"lite" open lite (pending update), by default 'default'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gui(kind=&#39;default&#39;):
    &#34;&#34;&#34;Function to open a graphical user interface (gui)

    Parameters
    ----------
    kind : str, optional
        What type of gui to open. &#34;default&#34; opens regular windowed interface, 
        &#34;widget&#34; opens jupyter widget&#39;
        &#34;lite&#34; open lite (pending update), by default &#39;default&#39;

    &#34;&#34;&#34;
    defaultList = [&#39;windowed&#39;, &#39;window&#39;, &#39;default&#39;, &#39;d&#39;]
    widgetList = [&#39;widget&#39;, &#39;jupyter&#39;, &#39;notebook&#39;, &#39;w&#39;, &#39;nb&#39;]
    liteList = [&#39;lite&#39;, &#39;light&#39;, &#39;basic&#39;, &#39;l&#39;, &#39;b&#39;]

    if kind.lower() in defaultList:
        import pkg_resources
        #guiPath = pathlib.Path(os.path.realpath(__file__))
        try:
            from sprit.sprit_gui import SPRIT_App
        except:
            from sprit_gui import SPRIT_App
        
        try:
            import tkinter as tk
        except:
            if sys.platform == &#39;linux&#39;:
                raise ImportError(&#39;The SpRIT graphical interface uses tkinter, which ships with python but is not pre-installed on linux machines. Use &#34;apt-get install python-tk&#34; or &#34;apt-get install python3-tk&#34; to install tkinter. You may need to use the sudo command at the start of those commands.&#39;)

        def on_gui_closing():
            plt.close(&#39;all&#39;)
            gui_root.quit()
            gui_root.destroy()

        if sys.platform == &#39;linux&#39;:
            if not pathlib.Path(&#34;/usr/share/doc/python3-tk&#34;).exists():
                warnings.warn(&#39;The SpRIT graphical interface uses tkinter, which ships with python but is not pre-installed on linux machines. Use &#34;apt-get install python-tk&#34; or &#34;apt-get install python3-tk&#34; to install tkinter. You may need to use the sudo command at the start of those commands.&#39;)

        gui_root = tk.Tk()
        try:
            try:
                icon_path =pathlib.Path(pkg_resources.resource_filename(__name__, &#39;resources/icon/sprit_icon_alpha.ico&#39;)) 
                gui_root.iconbitmap(icon_path)
            except:
                icon_path = pathlib.Path(pkg_resources.resource_filename(__name__, &#39;resources/icon/sprit_icon.png&#39;))
                gui_root.iconphoto(False, tk.PhotoImage(file=icon_path.as_posix()))
        except Exception as e:
            print(&#34;ICON NOT LOADED, still opening GUI&#34;)

        gui_root.resizable(True, True)
        spritApp = SPRIT_App(master=gui_root) #Open the app with a tk.Tk root

        gui_root.protocol(&#34;WM_DELETE_WINDOW&#34;, on_gui_closing)    
        gui_root.mainloop() #Run the main loop
    elif kind.lower() in widgetList:
        try:
            sprit_jupyter_UI.create_jupyter_ui()
        except Exception as e:
            print(e)</code></pre>
</details>
</dd>
<dt id="sprit.has_required_channels"><code class="name flex">
<span>def <span class="ident">has_required_channels</span></span>(<span>stream)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_required_channels(stream):
    channel_set = set()
    
    # Extract the channel codes from the traces in the stream
    for trace in stream:
        channel_set.add(trace.stats.channel)
    
    # Check if Z, E, and N channels are present
    return {&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;}.issubset(channel_set)</code></pre>
</details>
</dd>
<dt id="sprit.import_data"><code class="name flex">
<span>def <span class="ident">import_data</span></span>(<span>import_filepath, data_format='pickle')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to import .hvsr (or other extension) data exported using export_data() function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>import_filepath</code></strong> :&ensp;<code>str</code> or <code>path object</code></dt>
<dd>Filepath of file created using export_data() function. This is usually a pickle file with a .hvsr extension</dd>
<dt><strong><code>data_format</code></strong> :&ensp;<code>str</code>, default=<code>'pickle'</code></dt>
<dd>Type of format data is in. Currently, only 'pickle' supported. Eventually, json or other type may be supported, by default 'pickle'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_data(import_filepath, data_format=&#39;pickle&#39;):
    &#34;&#34;&#34;Function to import .hvsr (or other extension) data exported using export_data() function

    Parameters
    ----------
    import_filepath : str or path object
        Filepath of file created using export_data() function. This is usually a pickle file with a .hvsr extension
    data_format : str, default=&#39;pickle&#39;
        Type of format data is in. Currently, only &#39;pickle&#39; supported. Eventually, json or other type may be supported, by default &#39;pickle&#39;.

    Returns
    -------
    HVSRData or HVSRBatch object
    &#34;&#34;&#34;
    if data_format==&#39;pickle&#39;:
        with open(import_filepath, &#39;rb&#39;) as f:
            dataIN = pickle.load(f)
    else:
        dataIN = import_filepath
    return dataIN</code></pre>
</details>
</dd>
<dt id="sprit.import_settings"><code class="name flex">
<span>def <span class="ident">import_settings</span></span>(<span>settings_import_path, settings_import_type='instrument', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_settings(settings_import_path, settings_import_type=&#39;instrument&#39;, verbose=False):

    allList = [&#39;all&#39;, &#39;:&#39;, &#39;both&#39;, &#39;any&#39;]
    if settings_import_type.lower() not in allList:
        # if just a single settings dict is desired
        with open(settings_import_path, &#39;r&#39;) as f:
            settingsDict = json.load(f)
    else:
        # Either a directory or list
        if isinstance(settings_import_path, (list, tuple)):
            for setPath in settings_import_path:
                pass
        else:
            settings_import_path = sprit_utils.checkifpath(settings_import_path)
            if not settings_import_path.is_dir():
                raise RuntimeError(f&#39;settings_import_type={settings_import_type}, but settings_import_path is not list/tuple or filepath to directory&#39;)
            else:
                instFile = settings_import_path.glob(&#39;*.inst&#39;)
                procFile = settings_import_path.glob(&#39;*.proc&#39;)
    return settingsDict</code></pre>
</details>
</dd>
<dt id="sprit.input_params"><code class="name flex">
<span>def <span class="ident">input_params</span></span>(<span>datapath, site='HVSR Site', network='AM', station='RAC84', loc='00', channels=['EHZ', 'EHN', 'EHE'], acq_date='2024-02-19', starttime='00:00:00.00', endtime='23:59:59.999999', tzone='UTC', xcoord=-88.2290526, ycoord=40.1012122, elevation=755, input_crs='EPSG:4326', output_crs='EPSG:4326', elev_unit='feet', depth=0, instrument='Raspberry Shake', metapath=None, hvsr_band=[1, 40], peak_freq_range=[1, 40], processing_parameters={}, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for designating input parameters for reading in and processing data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datapath</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code></dt>
<dd>Filepath of data. This can be a directory or file, but will need to match with what is chosen later as the source parameter in fetch_data()</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>str</code>, default=<code>"HVSR Site"</code></dt>
<dd>Site name as designated by user for ease of reference. Used for plotting titles, filenames, etc.</dd>
<dt><strong><code>network</code></strong> :&ensp;<code>str</code>, default=<code>'AM'</code></dt>
<dd>The network designation of the seismometer. This is necessary for data from Raspberry Shakes. 'AM' is for Amateur network, which fits Raspberry Shakes.</dd>
<dt><strong><code>station</code></strong> :&ensp;<code>str</code>, default=<code>'RAC84'</code></dt>
<dd>The station name of the seismometer. This is necessary for data from Raspberry Shakes.</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>str</code>, default=<code>'00'</code></dt>
<dd>Location information of the seismometer.</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code>list</code>, default=<code>['EHZ', 'EHN', 'EHE']</code></dt>
<dd>The three channels used in this analysis, as a list of strings. Preferred that Z component is first, but not necessary</dd>
<dt><strong><code>acq_date</code></strong> :&ensp;<code>str, int, date object,</code> or <code>datetime object</code></dt>
<dd>If string, preferred format is 'YYYY-MM-DD'.
If int, this will be interpreted as the time_int of year of current year (e.g., 33 would be Feb 2 of current year)
If date or datetime object, this will be the date. Make sure to account for time change when converting to UTC (if UTC is the following time_int, use the UTC time_int).</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>str, time object,</code> or <code>datetime object</code>, default=<code>'00:00:00.00'</code></dt>
<dd>Start time of data stream. This is necessary for Raspberry Shake data in 'raw' form, or for trimming data. Format can be either 'HH:MM:SS.micros' or 'HH:MM' at minimum.</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>str, time obejct,</code> or <code>datetime object</code>, default=<code>'23:59:99.99'</code></dt>
<dd>End time of data stream. This is necessary for Raspberry Shake data in 'raw' form, or for trimming data. Same format as starttime.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>str</code> or <code>int</code>, default <code>= 'UTC'</code></dt>
<dd>Timezone of input data. If string, 'UTC' will use the time as input directly. Any other string value needs to be a TZ identifier in the IANA database, a wikipedia page of these is available here: <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.</a>
If int, should be the int value of the UTC offset (e.g., for American Eastern Standard Time: -5).
This is necessary for Raspberry Shake data in 'raw' format.</dd>
<dt><strong><code>xcoord</code></strong> :&ensp;<code>float</code>, default=<code>-88.2290526</code></dt>
<dd>Longitude (or easting, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in csv output, but will likely be used in future for mapping/profile purposes.</dd>
<dt><strong><code>ycoord</code></strong> :&ensp;<code>float</code>, default=<code>40.1012122</code></dt>
<dd>Latitute (or northing, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in csv output, but will likely be used in future for mapping/profile purposes.</dd>
<dt><strong><code>input_crs</code></strong> :&ensp;<code>str</code> or <code>other format read by pyproj</code>, default=<code>'EPSG:4326'</code></dt>
<dd>Coordinate reference system of input data, as used by pyproj.CRS.from_user_input()</dd>
<dt><strong><code>output_crs</code></strong> :&ensp;<code>str</code> or <code>other format read by pyproj</code>, default=<code>'EPSG:4326'</code></dt>
<dd>Coordinate reference system to which input data will be transformed, as used by pyproj.CRS.from_user_input()</dd>
<dt><strong><code>elevation</code></strong> :&ensp;<code>float</code>, default=<code>755</code></dt>
<dd>Surface elevation of data point. Not currently used (except in csv output), but will likely be used in the future.</dd>
<dt><strong><code>depth</code></strong> :&ensp;<code>float</code>, default=<code>0</code></dt>
<dd>Depth of seismometer. Not currently used, but will likely be used in the future.</dd>
<dt><strong><code>instrument</code></strong> :&ensp;<code>str</code> or <code>list {'Raspberry Shake')</code></dt>
<dd>Instrument from which the data was acquired.</dd>
<dt><strong><code>metapath</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code>, default=<code>None</code></dt>
<dd>Filepath of metadata, in format supported by obspy.read_inventory. If default value of None, will read from resources folder of repository (only supported for Raspberry Shake).</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>list</code>, default=<code>[1, 40]</code></dt>
<dd>Two-element list containing low and high "corner" frequencies (in Hz) for processing. This can specified again later.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>list</code> or <code>tuple</code>, default=<code>[1, 40]</code></dt>
<dd>Two-element list or tuple containing low and high frequencies (in Hz) that are used to check for HVSR Peaks. This can be a tigher range than hvsr_band, but if larger, it will still only use the hvsr_band range.</dd>
<dt>processing_parameters={} : dict or filepath, default={}</dt>
<dt>If filepath, should point to a .proc json file with processing parameters (i.e, an output from sprit.export_settings()).</dt>
<dt>Note that this only applies to parameters for the functions: 'fetch_data', 'remove_noise', 'generate_ppsds', 'process_hvsr', 'check_peaks', and 'get_report.'</dt>
<dt>If dictionary, dictionary containing nested dictionaries of function names as they key, and the parameter names/values as key/value pairs for each key.</dt>
<dt>If a function name is not present, or if a parameter name is not present, default values will be used.</dt>
<dt>For example:</dt>
<dt><code>{ 'fetch_data' : {'source':'batch', 'trim_dir':"/path/to/trimmed/data", 'export_format':'mseed', 'detrend':'spline', 'plot_input_stream':True, 'verbose':False, kwargs:{'kwargskey':'kwargsvalue'}} }</code></dt>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print output and results to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>sprit.HVSRData class containing input parameters, including data file path and metadata path. This will be used as an input to other functions. If batch processing, params will be converted to batch type in fetch_data() step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input_params(datapath,
                site=&#39;HVSR Site&#39;,
                network=&#39;AM&#39;, 
                station=&#39;RAC84&#39;, 
                loc=&#39;00&#39;, 
                channels=[&#39;EHZ&#39;, &#39;EHN&#39;, &#39;EHE&#39;],
                acq_date=str(datetime.datetime.now().date()),
                starttime = &#39;00:00:00.00&#39;,
                endtime = &#39;23:59:59.999999&#39;,
                tzone = &#39;UTC&#39;,
                xcoord = -88.2290526,
                ycoord =  40.1012122,
                elevation = 755,
                input_crs=&#39;EPSG:4326&#39;,#4269 is NAD83, defautling to WGS
                output_crs=&#39;EPSG:4326&#39;,
                elev_unit = &#39;feet&#39;,
                depth = 0,
                instrument = &#39;Raspberry Shake&#39;,
                metapath = None,
                hvsr_band = [1, 40],
                peak_freq_range=[1, 40],
                processing_parameters={},
                verbose=False
                ):
    &#34;&#34;&#34;Function for designating input parameters for reading in and processing data
    
    Parameters
    ----------
    datapath : str or pathlib.Path object
        Filepath of data. This can be a directory or file, but will need to match with what is chosen later as the source parameter in fetch_data()
    site : str, default=&#34;HVSR Site&#34;
        Site name as designated by user for ease of reference. Used for plotting titles, filenames, etc.
    network : str, default=&#39;AM&#39;
        The network designation of the seismometer. This is necessary for data from Raspberry Shakes. &#39;AM&#39; is for Amateur network, which fits Raspberry Shakes.
    station : str, default=&#39;RAC84&#39;
        The station name of the seismometer. This is necessary for data from Raspberry Shakes.
    loc : str, default=&#39;00&#39;
        Location information of the seismometer.
    channels : list, default=[&#39;EHZ&#39;, &#39;EHN&#39;, &#39;EHE&#39;]
        The three channels used in this analysis, as a list of strings. Preferred that Z component is first, but not necessary
    acq_date : str, int, date object, or datetime object
        If string, preferred format is &#39;YYYY-MM-DD&#39;. 
        If int, this will be interpreted as the time_int of year of current year (e.g., 33 would be Feb 2 of current year)
        If date or datetime object, this will be the date. Make sure to account for time change when converting to UTC (if UTC is the following time_int, use the UTC time_int).
    starttime : str, time object, or datetime object, default=&#39;00:00:00.00&#39;
        Start time of data stream. This is necessary for Raspberry Shake data in &#39;raw&#39; form, or for trimming data. Format can be either &#39;HH:MM:SS.micros&#39; or &#39;HH:MM&#39; at minimum.
    endtime : str, time obejct, or datetime object, default=&#39;23:59:99.99&#39;
        End time of data stream. This is necessary for Raspberry Shake data in &#39;raw&#39; form, or for trimming data. Same format as starttime.
    tzone : str or int, default = &#39;UTC&#39;
        Timezone of input data. If string, &#39;UTC&#39; will use the time as input directly. Any other string value needs to be a TZ identifier in the IANA database, a wikipedia page of these is available here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
        If int, should be the int value of the UTC offset (e.g., for American Eastern Standard Time: -5). 
        This is necessary for Raspberry Shake data in &#39;raw&#39; format.
    xcoord : float, default=-88.2290526
        Longitude (or easting, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in csv output, but will likely be used in future for mapping/profile purposes.
    ycoord : float, default=40.1012122
        Latitute (or northing, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in csv output, but will likely be used in future for mapping/profile purposes.
    input_crs : str or other format read by pyproj, default=&#39;EPSG:4326&#39;
        Coordinate reference system of input data, as used by pyproj.CRS.from_user_input()
    output_crs : str or other format read by pyproj, default=&#39;EPSG:4326&#39;
        Coordinate reference system to which input data will be transformed, as used by pyproj.CRS.from_user_input()
    elevation : float, default=755
        Surface elevation of data point. Not currently used (except in csv output), but will likely be used in the future.
    depth : float, default=0
        Depth of seismometer. Not currently used, but will likely be used in the future.
    instrument : str or list {&#39;Raspberry Shake&#39;)
        Instrument from which the data was acquired. 
    metapath : str or pathlib.Path object, default=None
        Filepath of metadata, in format supported by obspy.read_inventory. If default value of None, will read from resources folder of repository (only supported for Raspberry Shake).
    hvsr_band : list, default=[1, 40]
        Two-element list containing low and high &#34;corner&#34; frequencies (in Hz) for processing. This can specified again later.
    peak_freq_range : list or tuple, default=[1, 40]
        Two-element list or tuple containing low and high frequencies (in Hz) that are used to check for HVSR Peaks. This can be a tigher range than hvsr_band, but if larger, it will still only use the hvsr_band range.
    processing_parameters={} : dict or filepath, default={}
        If filepath, should point to a .proc json file with processing parameters (i.e, an output from sprit.export_settings()). 
        Note that this only applies to parameters for the functions: &#39;fetch_data&#39;, &#39;remove_noise&#39;, &#39;generate_ppsds&#39;, &#39;process_hvsr&#39;, &#39;check_peaks&#39;, and &#39;get_report.&#39;
        If dictionary, dictionary containing nested dictionaries of function names as they key, and the parameter names/values as key/value pairs for each key. 
        If a function name is not present, or if a parameter name is not present, default values will be used.
        For example: 
            `{ &#39;fetch_data&#39; : {&#39;source&#39;:&#39;batch&#39;, &#39;trim_dir&#39;:&#34;/path/to/trimmed/data&#34;, &#39;export_format&#39;:&#39;mseed&#39;, &#39;detrend&#39;:&#39;spline&#39;, &#39;plot_input_stream&#39;:True, &#39;verbose&#39;:False, kwargs:{&#39;kwargskey&#39;:&#39;kwargsvalue&#39;}} }`
    verbose : bool, default=False
        Whether to print output and results to terminal

    Returns
    -------
    params : sprit.HVSRData
        sprit.HVSRData class containing input parameters, including data file path and metadata path. This will be used as an input to other functions. If batch processing, params will be converted to batch type in fetch_data() step.

    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments
    start_time = datetime.datetime.now()

    #Reformat times
    if type(acq_date) is datetime.datetime:
        date = str(acq_date.date())
    elif type(acq_date) is datetime.date:
        date=str(acq_date)
    elif type(acq_date) is str:
        monthStrs = {&#39;jan&#39;:1, &#39;january&#39;:1,
                    &#39;feb&#39;:2, &#39;february&#39;:2,
                    &#39;mar&#39;:3, &#39;march&#39;:3,
                    &#39;apr&#39;:4, &#39;april&#39;:4,
                    &#39;may&#39;:5,
                    &#39;jun&#39;:6, &#39;june&#39;:6,
                    &#39;jul&#39;:7, &#39;july&#39;:7,
                    &#39;aug&#39;:8, &#39;august&#39;:8,
                    &#39;sep&#39;:9, &#39;sept&#39;:9, &#39;september&#39;:9,
                    &#39;oct&#39;:10,&#39;october&#39;:10, 
                    &#39;nov&#39;:11,&#39;november&#39;:11,
                    &#39;dec&#39;:12,&#39;december&#39;:12}

        spelledMonth = False
        for m in monthStrs.keys():
            acq_date = acq_date.lower()
            if m in acq_date:
                spelledMonth = True
                break

        if spelledMonth is not False:
            month = monthStrs[m]

        if &#39;/&#39; in acq_date:
            sep = &#39;/&#39;
        elif &#39;.&#39; in acq_date:
            sep=&#39;.&#39;
        elif &#39; &#39; in acq_date:
            sep = &#39; &#39;
            acq_date = acq_date.replace(&#39;,&#39;, &#39;&#39;)
        else:
            sep = &#39;-&#39;

        acq_date = acq_date.split(sep)
        if len(acq_date[2]) &gt; 2: #American format
            date = &#39;{}-{}-{}&#39;.format(acq_date[2], acq_date[0], acq_date[1])
        else: #international format, one we&#39;re going to use
            date = &#39;{}-{}-{}&#39;.format(acq_date[0], acq_date[1], acq_date[2])     

    elif type(acq_date) is int:
        year=datetime.datetime.today().year
        date = str((datetime.datetime(year, 1, 1) + datetime.timedelta(acq_date - 1)).date())
    
    if type(starttime) is str:
        if &#39;T&#39; in starttime:
            #date=starttime.split(&#39;T&#39;)[0]
            starttime = starttime.split(&#39;T&#39;)[1]
        else:
            pass
            #starttime = date+&#39;T&#39;+starttime
    elif type(starttime) is datetime.datetime:
        #date = str(starttime.date())
        starttime = str(starttime.time())
        ###HERE IS NEXT
    elif type(starttime) is datetime.time():
        starttime = str(starttime)
    
    starttime = str(date)+&#34;T&#34;+str(starttime)
    starttime = obspy.UTCDateTime(sprit_utils.format_time(starttime, tzone=tzone))
    
    if type(endtime) is str:
        if &#39;T&#39; in endtime:
            date=endtime.split(&#39;T&#39;)[0]
            endtime = endtime.split(&#39;T&#39;)[1]
    elif type(endtime) is datetime.datetime:
        date = str(endtime.date())
        endtime = str(endtime.time())
    elif type(endtime) is datetime.time():
        endtime = str(endtime)

    endtime = str(date)+&#34;T&#34;+str(endtime)
    endtime = obspy.UTCDateTime(sprit_utils.format_time(endtime, tzone=tzone))

    acq_date = datetime.date(year=int(date.split(&#39;-&#39;)[0]), month=int(date.split(&#39;-&#39;)[1]), day=int(date.split(&#39;-&#39;)[2]))
    raspShakeInstNameList = [&#39;raspberry shake&#39;, &#39;shake&#39;, &#39;raspberry&#39;, &#39;rs&#39;, &#39;rs3d&#39;, &#39;rasp. shake&#39;, &#39;raspshake&#39;]
    
    if output_crs is None:
        output_crs=&#39;EPSG:4326&#39;

    if input_crs is None:
        input_crs = &#39;EPSG:4326&#39;#Default to WGS84
    else:        
        input_crs = CRS.from_user_input(input_crs)
        output_crs = CRS.from_user_input(output_crs)

        coord_transformer = Transformer.from_crs(input_crs, output_crs, always_xy=True)
        xcoord, ycoord = coord_transformer.transform(xcoord, ycoord)

    #Add key/values to input parameter dictionary
    inputParamDict = {&#39;site&#39;:site, &#39;net&#39;:network,&#39;sta&#39;:station, &#39;loc&#39;:loc, &#39;cha&#39;:channels, &#39;instrument&#39;:instrument,
                    &#39;acq_date&#39;:acq_date,&#39;starttime&#39;:starttime,&#39;endtime&#39;:endtime, &#39;timezone&#39;:&#39;UTC&#39;, #Will be in UTC by this point
                    &#39;longitude&#39;:xcoord,&#39;latitude&#39;:ycoord,&#39;elevation&#39;:elevation,&#39;input_crs&#39;:input_crs, &#39;output_crs&#39;:output_crs,
                    &#39;depth&#39;:depth, &#39;datapath&#39;: datapath, &#39;metapath&#39;:metapath, &#39;hvsr_band&#39;:hvsr_band, &#39;peak_freq_range&#39;:peak_freq_range,
                    &#39;ProcessingStatus&#39;:{&#39;InputParamsStatus&#39;:True, &#39;OverallStatus&#39;:True}
                    }
    
    #Replace any default parameter settings with those from json file of interest, potentially
    instrument_settings_dict = {}
    if pathlib.Path(instrument).exists():
        instrument_settings = import_settings(settings_import_path=instrument, settings_import_type=&#39;instrument&#39;, verbose=verbose)
        input_params_args = inspect.getfullargspec(input_params).args
        input_params_args.append(&#39;net&#39;)
        input_params_args.append(&#39;sta&#39;)
        for k, settings_value in instrument_settings.items():
            if k in input_params_args:
                instrument_settings_dict[k] = settings_value
        inputParamDict[&#39;instrument_settings&#39;] = inputParamDict[&#39;instrument&#39;]
        inputParamDict.update(instrument_settings_dict)
    
    if instrument.lower() in raspShakeInstNameList:
        if metapath is None or metapath==&#39;&#39;:
            metapath = pathlib.Path(pkg_resources.resource_filename(__name__, &#39;resources/rs3dv5plus_metadata.inv&#39;)).as_posix()
            inputParamDict[&#39;metapath&#39;] = metapath
            #metapath = pathlib.Path(os.path.realpath(__file__)).parent.joinpath(&#39;/resources/rs3dv7_metadata.inv&#39;)

    for settingName in instrument_settings_dict.keys():
        if settingName in inputParamDict.keys():
            inputParamDict[settingName] = instrument_settings_dict[settingName]

    #Declare obspy here instead of at top of file for (for example) colab, where obspy first needs to be installed on environment
    if verbose:
        print(&#39;Gathering input parameters (input_params())&#39;)
        for key, value in inputParamDict.items():
            print(&#39;\t  {}={}&#39;.format(key, value))
        print()

    if isinstance(processing_parameters, dict):
        inputParamDict[&#39;processing_parameters&#39;] = processing_parameters
    else:
        processing_parameters = sprit_utils.checkifpath(processing_parameters)
        inputParamDict[&#39;processing_parameters&#39;] = import_settings(processing_parameters, settings_import_type=&#39;processing&#39;, verbose=verbose)

    #Format everything nicely
    params = sprit_utils.make_it_classy(inputParamDict)
    params[&#39;ProcessingStatus&#39;][&#39;InputParamsStatus&#39;] = True
    params = _check_processing_status(params, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)
    return params</code></pre>
</details>
</dd>
<dt id="sprit.make_it_classy"><code class="name flex">
<span>def <span class="ident">make_it_classy</span></span>(<span>input_data, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_it_classy(input_data, verbose=False):
    if isinstance(input_data, (sprit_hvsr.HVSRData, sprit_hvsr.HVSRBatch)):
        for k, v in input_data.items():
            if k==&#39;input_params&#39;:
                for kin in input_data[&#39;input_params&#39;].keys():
                    if kin not in input_data.keys():
                        input_data[kin] = input_data[&#39;input_params&#39;][kin]
            if k==&#39;params&#39;:
                for kin in input_data[&#39;params&#39;].keys():
                    print(kin)
                    if kin not in input_data.keys():
                        input_data[kin] = input_data[&#39;params&#39;][kin]                
        output_class = input_data
    else:
        output_class = sprit_hvsr.HVSRData(input_data)
    if verbose:
        print(&#39;Made it classy | {} --&gt; {}&#39;.format(type(input_data), type(output_class)))
    return output_class</code></pre>
</details>
</dd>
<dt id="sprit.plot_hvsr"><code class="name flex">
<span>def <span class="ident">plot_hvsr</span></span>(<span>hvsr_data, plot_type='HVSR ann p C+ ann p SPEC', use_subplots=True, fig=None, ax=None, return_fig=False, save_dir=None, save_suffix='', show_legend=False, show=True, close_figs=False, clear_fig=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot HVSR data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict
</code></dt>
<dd>Dictionary containing output from process_hvsr function</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>str</code> or <code>list</code>, default <code>= 'HVSR ann p C+ ann p SPEC'</code></dt>
<dd>The plot_type of plot(s) to plot. If list, will plot all plots listed
- 'HVSR' - Standard HVSR plot, including standard deviation. Options are included below:
- 'p' shows a vertical dotted line at frequency of the "best" peak
- 'ann' annotates the frequency value of of the "best" peak
- 'all' shows all the peaks identified in check_peaks() (by default, only the max is identified)
- 't' shows the H/V curve for all time windows
-'tp' shows all the peaks from the H/V curves of all the time windows
- 'COMP' - plot of the PPSD curves for each individual component ("C" also works)
- '+' (as a suffix in 'C+' or 'COMP+') plots C on a plot separate from HVSR (C+ is default, but without + will plot on the same plot as HVSR)
- 'p' shows a vertical dotted line at frequency of the "best" peak
- 'ann' annotates the frequency value of of the "best" peak
- 'all' shows all the peaks identified in check_peaks() (by default, only the max is identified)
- 't' shows the H/V curve for all time windows
- 'SPEC' - spectrogram style plot of the H/V curve over time
- 'p' shows a horizontal dotted line at the frequency of the "best" peak
- 'ann' annotates the frequency value of the "best" peak</dd>
<dt><strong><code>use_subplots</code></strong> :&ensp;<code>bool</code>, default <code>= True</code></dt>
<dd>Whether to output the plots as subplots (True) or as separate plots (False)</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.Figure</code>, default <code>= None</code></dt>
<dd>If not None, matplotlib figure on which plot is plotted</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.Axis</code>, default <code>= None</code></dt>
<dd>If not None, matplotlib axis on which plot is plotted</dd>
<dt><strong><code>return_fig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return figure and axis objects</dd>
<dt><strong><code>save_dir</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Directory in which to save figures</dd>
<dt><strong><code>save_suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>Suffix to add to end of figure filename(s), if save_dir is used</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show legend in plot</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show plot</dd>
<dt><strong><code>close_figs</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to close figures before plotting</dd>
<dt><strong><code>clear_fig</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to clear figures before plotting</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>Keyword arguments for matplotlib.pyplot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib figure and axis objects</code></dt>
<dd>Returns figure and axis matplotlib.pyplot objects if return_fig=True, otherwise, simply plots the figures</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hvsr(hvsr_data, plot_type=&#39;HVSR ann p C+ ann p SPEC&#39;, use_subplots=True, fig=None, ax=None, return_fig=False,  save_dir=None, save_suffix=&#39;&#39;, show_legend=False, show=True, close_figs=False, clear_fig=True,**kwargs):
    &#34;&#34;&#34;Function to plot HVSR data

    Parameters
    ----------
    hvsr_data : dict                  
        Dictionary containing output from process_hvsr function
    plot_type : str or list, default = &#39;HVSR ann p C+ ann p SPEC&#39;
        The plot_type of plot(s) to plot. If list, will plot all plots listed
        - &#39;HVSR&#39; - Standard HVSR plot, including standard deviation. Options are included below:
            - &#39;p&#39; shows a vertical dotted line at frequency of the &#34;best&#34; peak
            - &#39;ann&#39; annotates the frequency value of of the &#34;best&#34; peak
            - &#39;all&#39; shows all the peaks identified in check_peaks() (by default, only the max is identified)
            - &#39;t&#39; shows the H/V curve for all time windows
                -&#39;tp&#39; shows all the peaks from the H/V curves of all the time windows
        - &#39;COMP&#39; - plot of the PPSD curves for each individual component (&#34;C&#34; also works)
            - &#39;+&#39; (as a suffix in &#39;C+&#39; or &#39;COMP+&#39;) plots C on a plot separate from HVSR (C+ is default, but without + will plot on the same plot as HVSR)
            - &#39;p&#39; shows a vertical dotted line at frequency of the &#34;best&#34; peak
            - &#39;ann&#39; annotates the frequency value of of the &#34;best&#34; peak
            - &#39;all&#39; shows all the peaks identified in check_peaks() (by default, only the max is identified)
            - &#39;t&#39; shows the H/V curve for all time windows
        - &#39;SPEC&#39; - spectrogram style plot of the H/V curve over time
            - &#39;p&#39; shows a horizontal dotted line at the frequency of the &#34;best&#34; peak
            - &#39;ann&#39; annotates the frequency value of the &#34;best&#34; peak
    use_subplots : bool, default = True
        Whether to output the plots as subplots (True) or as separate plots (False)
    fig : matplotlib.Figure, default = None
        If not None, matplotlib figure on which plot is plotted
    ax : matplotlib.Axis, default = None
        If not None, matplotlib axis on which plot is plotted
    return_fig : bool
        Whether to return figure and axis objects
    save_dir : str or None
        Directory in which to save figures
    save_suffix : str
        Suffix to add to end of figure filename(s), if save_dir is used
    show_legend : bool, default=False
        Whether to show legend in plot
    show : bool
        Whether to show plot
    close_figs : bool, default=False
        Whether to close figures before plotting
    clear_fig : bool, default=True
        Whether to clear figures before plotting
    **kwargs : keyword arguments
        Keyword arguments for matplotlib.pyplot

    Returns
    -------
    fig, ax : matplotlib figure and axis objects
        Returns figure and axis matplotlib.pyplot objects if return_fig=True, otherwise, simply plots the figures
    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            individual_params = hvsr_data[site_name] #Get what would normally be the &#34;params&#34; variable for each site
            args[&#39;hvsr_results&#39;] = individual_params #reset the params parameter we originally read in to an individual site params
            if hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
                try:
                    _hvsr_plot_batch(**args) #Call another function, that lets us run this function again
                except:
                    print(f&#34;{site_name} not able to be plotted.&#34;)
    else:
        if clear_fig and fig is not None and ax is not None: #Intended use for tkinter
            #Clear everything
            for key in ax:
                ax[key].clear()
            for t in fig.texts:
                del t
            fig.clear()
        if close_figs:
            plt.close(&#39;all&#39;)

        compList = [&#39;c&#39;, &#39;comp&#39;, &#39;component&#39;, &#39;components&#39;]
        specgramList = [&#39;spec&#39;, &#39;specgram&#39;, &#39;spectrogram&#39;]
        hvsrList = [&#39;hvsr&#39;, &#39;hv&#39;, &#39;h&#39;]

        hvsrInd = np.nan
        compInd = np.nan
        specInd = np.nan

        kList = plot_type.split(&#39; &#39;)
        for i, k in enumerate(kList):
            kList[i] = k.lower()

        #Get the plots in the right order, no matter how they were input (and ensure the right options go with the right plot)
        #HVSR index
        if len(set(hvsrList).intersection(kList)):
            for i, hv in enumerate(hvsrList):
                if hv in kList:
                    hvsrInd = kList.index(hv)
                    break
        #Component index
        #if len(set(compList).intersection(kList)):
        for i, c in enumerate(kList):
            if &#39;+&#39; in c and c[:-1] in compList:
                compInd = kList.index(c)
                break
            
        #Specgram index
        if len(set(specgramList).intersection(kList)):
            for i, sp in enumerate(specgramList):
                if sp in kList:
                    specInd = kList.index(sp)
                    break        

        indList = [hvsrInd, compInd, specInd]
        indListCopy = indList.copy()
        plotTypeList = [&#39;hvsr&#39;, &#39;comp&#39;, &#39;spec&#39;]

        plotTypeOrder = []
        plotIndOrder = []

        lastVal = 0
        while lastVal != 99:
            firstInd = np.nanargmin(indListCopy)
            plotTypeOrder.append(plotTypeList[firstInd])
            plotIndOrder.append(indList[firstInd])
            lastVal = indListCopy[firstInd]
            indListCopy[firstInd] = 99 #just a high number

        plotTypeOrder.pop()
        plotIndOrder[-1]=len(kList)
        
        for i, p in enumerate(plotTypeOrder):
            pStartInd = plotIndOrder[i]
            pEndInd = plotIndOrder[i+1]
            plotComponents = kList[pStartInd:pEndInd]

            if use_subplots and i==0 and fig is None and ax is None:
                mosaicPlots = []
                for pto in plotTypeOrder:
                    mosaicPlots.append([pto])
                fig, ax = plt.subplot_mosaic(mosaicPlots, gridspec_kw={&#39;hspace&#39;:0.3})
                axis = ax[p]
            elif use_subplots:
                with warnings.catch_warnings():
                    warnings.simplefilter(&#34;ignore&#34;) #Often warns about xlim when it is not an issue
                    ax[p].clear()
                axis = ax[p]
            else:
                fig, axis = plt.subplots()
                    
            if p == &#39;hvsr&#39;:
                kwargs[&#39;p&#39;] = &#39;hvsr&#39;
                _plot_hvsr(hvsr_data, fig=fig, ax=axis, plot_type=plotComponents, xtype=&#39;x_freqs&#39;, show_legend=show_legend, axes=ax, **kwargs)
            elif p==&#39;comp&#39;:
                plotComponents[0] = plotComponents[0][:-1]
                kwargs[&#39;p&#39;]==&#39;comp&#39;
                _plot_hvsr(hvsr_data, fig=fig, ax=axis, plot_type=plotComponents, xtype=&#39;x_freqs&#39;, show_legend=show_legend, axes=ax, **kwargs)
            elif p==&#39;spec&#39;:
                plottypeKwargs = {}
                for c in plotComponents:
                    plottypeKwargs[c] = True
                kwargs.update(plottypeKwargs)
                _plot_specgram_hvsr(hvsr_data, fig=fig, ax=axis, colorbar=False, **kwargs)
            else:
                warnings.warn(&#39;Plot type {p} not recognized&#39;, UserWarning)   

        windowsUsedStr = f&#34;{hvsr_data[&#39;hvsr_df&#39;][&#39;Use&#39;].sum()}/{hvsr_data[&#39;hvsr_df&#39;].shape[0]} windows used&#34;
        fig.text(x=0.98, y=0.02, s=windowsUsedStr, ha=&#39;right&#39;, va=&#39;bottom&#39;, fontsize=&#39;x-small&#39;,
                 bbox=dict(facecolor=&#39;w&#39;, edgecolor=None, linewidth=0, alpha=1, pad=9))

        if show:
            fig.canvas.draw()
            
        if return_fig:
            return fig, ax
    return</code></pre>
</details>
</dd>
<dt id="sprit.process_hvsr"><code class="name flex">
<span>def <span class="ident">process_hvsr</span></span>(<span>hvsr_data, method=3, smooth=True, freq_smooth='konno ohmachi', f_smooth_width=40, resample=True, outlier_curve_rmse_percentile=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Process the input data and get HVSR data</p>
<p>This is the main function that uses other (private) functions to do
the bulk of processing of the HVSR data and the data quality checks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>hvsr_data
: HVSRData or HVSRBatch</dt>
<dt>Data object containing all the parameters input and generated by the user (usually, during sprit.input_params(), sprit.fetch_data(), sprit.generate_ppsds() and/or sprit.remove_noise()).</dt>
<dt>method
: int or str, default=3</dt>
<dt>Method to use for combining the horizontal components</dt>
<dt>0) (not used)</dt>
<dt>1) Diffuse field assumption, or 'DFA' (not currently implemented)</dt>
<dt>2) 'Arithmetic Mean': H ≡ (HN + HE)/2</dt>
<dt>3) 'Geometric Mean': H ≡ √HN · HE, recommended by the SESAME project (2004)</dt>
<dt>4) 'Vector Summation': H ≡ √H2 N + H2 E</dt>
<dt>5) 'Quadratic Mean': H ≡ √(H2 N + H2 E )/2</dt>
<dt HE HN_="HN,">6) 'Maximum Horizontal Value': H ≡ max</dt>
<dt>smooth
: bool, default=True</dt>
<dt>bool or int may be used.</dt>
<dt>If True, default to smooth H/V curve to using savgoy filter with window length of 51 (works well with default resample of 1000 pts)</dt>
<dt>If int, the length of the window in the savgoy filter.</dt>
<dt><strong><code>freq_smooth</code></strong> :&ensp;<code>str {'konno ohmachi', 'constant', 'proportional'}</code></dt>
<dd>Which frequency smoothing method to use. By default, uses the 'konno ohmachi' method.
- The Konno &amp; Ohmachi method uses the obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing() function: <a href="https://docs.obspy.org/packages/autogen/obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing.html">https://docs.obspy.org/packages/autogen/obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing.html</a>
- The constant method uses a window of constant length f_smooth_width
- The proportional method uses a window the percentage length of the frequncy steps/range (f_smooth_width now refers to percentage)
See here for more information: <a href="https://www.geopsy.org/documentation/geopsy/hv-processing.html">https://www.geopsy.org/documentation/geopsy/hv-processing.html</a></dd>
<dt><strong><code>f_smooth_width</code></strong> :&ensp;<code>int</code>, default <code>= 40</code></dt>
<dd>
<ul>
<li>For 'konno ohmachi': passed directly to the bandwidth parameter of the konno_ohmachi_smoothing() function, determines the width of the smoothing peak, with lower values resulting in broader peak. Must be &gt; 0.</li>
<li>For 'constant': the size of a triangular smoothing window in the number of frequency steps</li>
<li>For 'proportional': the size of a triangular smoothing window in percentage of the number of frequency steps (e.g., if 1000 frequency steps/bins and f_smooth_width=40, window would be 400 steps wide)</li>
</ul>
</dd>
<dt>resample
: bool, default = True</dt>
<dt>bool or int.</dt>
<dt>If True, default to resample H/V data to include 1000 frequency values for the rest of the analysis</dt>
<dt>If int, the number of data points to interpolate/resample/smooth the component psd/HV curve data to.</dt>
<dt><strong><code>outlier_curve_rmse_percentile</code></strong> :&ensp;<code>bool, float</code>, default <code>= False</code></dt>
<dd>If False, outlier curve removal is not carried out here.
If True, defaults to 98 (98th percentile).
Otherwise, float of percentile used as rmse_thresh of remove_outlier_curve().</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool, defualt=False</code></dt>
<dd>Whether to print output to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>hvsr_out    : dict
    Dictionary containing all the information about the data, including input parameters
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_hvsr(hvsr_data, method=3, smooth=True, freq_smooth=&#39;konno ohmachi&#39;, f_smooth_width=40, resample=True, outlier_curve_rmse_percentile=False, verbose=False):
    &#34;&#34;&#34;Process the input data and get HVSR data
    
    This is the main function that uses other (private) functions to do 
    the bulk of processing of the HVSR data and the data quality checks.

    Parameters
    ----------
    hvsr_data  : HVSRData or HVSRBatch
        Data object containing all the parameters input and generated by the user (usually, during sprit.input_params(), sprit.fetch_data(), sprit.generate_ppsds() and/or sprit.remove_noise()).
    method  : int or str, default=3
        Method to use for combining the horizontal components
            0) (not used)
            1) Diffuse field assumption, or &#39;DFA&#39; (not currently implemented)
            2) &#39;Arithmetic Mean&#39;: H ≡ (HN + HE)/2
            3) &#39;Geometric Mean&#39;: H ≡ √HN · HE, recommended by the SESAME project (2004)
            4) &#39;Vector Summation&#39;: H ≡ √H2 N + H2 E
            5) &#39;Quadratic Mean&#39;: H ≡ √(H2 N + H2 E )/2
            6) &#39;Maximum Horizontal Value&#39;: H ≡ max {HN, HE}
    smooth  : bool, default=True
        bool or int may be used. 
            If True, default to smooth H/V curve to using savgoy filter with window length of 51 (works well with default resample of 1000 pts)
            If int, the length of the window in the savgoy filter.
    freq_smooth : str {&#39;konno ohmachi&#39;, &#39;constant&#39;, &#39;proportional&#39;}
        Which frequency smoothing method to use. By default, uses the &#39;konno ohmachi&#39; method.
            - The Konno &amp; Ohmachi method uses the obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing() function: https://docs.obspy.org/packages/autogen/obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing.html
            - The constant method uses a window of constant length f_smooth_width
            - The proportional method uses a window the percentage length of the frequncy steps/range (f_smooth_width now refers to percentage)
        See here for more information: https://www.geopsy.org/documentation/geopsy/hv-processing.html
    f_smooth_width : int, default = 40
        - For &#39;konno ohmachi&#39;: passed directly to the bandwidth parameter of the konno_ohmachi_smoothing() function, determines the width of the smoothing peak, with lower values resulting in broader peak. Must be &gt; 0.
        - For &#39;constant&#39;: the size of a triangular smoothing window in the number of frequency steps
        - For &#39;proportional&#39;: the size of a triangular smoothing window in percentage of the number of frequency steps (e.g., if 1000 frequency steps/bins and f_smooth_width=40, window would be 400 steps wide)
    resample  : bool, default = True
        bool or int. 
            If True, default to resample H/V data to include 1000 frequency values for the rest of the analysis
            If int, the number of data points to interpolate/resample/smooth the component psd/HV curve data to.
    outlier_curve_rmse_percentile : bool, float, default = False
        If False, outlier curve removal is not carried out here. 
        If True, defaults to 98 (98th percentile). 
        Otherwise, float of percentile used as rmse_thresh of remove_outlier_curve().
    verbose : bool, defualt=False
        Whether to print output to terminal

    Returns
    -------
        hvsr_out    : dict
            Dictionary containing all the information about the data, including input parameters

    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments
    start_time = datetime.datetime.now()

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;process_hvsr&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;process_hvsr&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(process_hvsr).args[1:], 
                                        inspect.getfullargspec(process_hvsr).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    orig_args[k] = v
                    
    method = orig_args[&#39;method&#39;]
    smooth = orig_args[&#39;smooth&#39;]
    freq_smooth = orig_args[&#39;freq_smooth&#39;]
    f_smooth_width = orig_args[&#39;f_smooth_width&#39;]
    resample = orig_args[&#39;resample&#39;]
    outlier_curve_rmse_percentile = orig_args[&#39;outlier_curve_rmse_percentile&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nCalculating Horizontal/Vertical Ratios at all frequencies/time steps (process_hvsr())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key==&#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))
            print()

    #First, divide up for batch or not
    #Site is in the keys anytime it&#39;s not batch
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        hvsr_out = {}
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] = hvsr_data[site_name] #Get what would normally be the &#34;hvsr_data&#34; variable for each site
            if hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
                try:
                    hvsr_out[site_name] = _process_hvsr_batch(**args) #Call another function, that lets us run this function again
                except:
                    hvsr_out = hvsr_data
                    hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;HVStatus&#39;]=False
                    hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False                    
            else:
                hvsr_out = hvsr_data
                hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;HVStatus&#39;]=False
                hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False
        hvsr_out = HVSRBatch(hvsr_out)
    else:
        ppsds = hvsr_data[&#39;ppsds&#39;].copy()#[k][&#39;psd_values&#39;]
        ppsds = sprit_utils.check_xvalues(ppsds)

        methodList = [&#39;&lt;placeholder_0&gt;&#39;, &#39;Diffuse Field Assumption&#39;, &#39;Arithmetic Mean&#39;, &#39;Geometric Mean&#39;, &#39;Vector Summation&#39;, &#39;Quadratic Mean&#39;, &#39;Maximum Horizontal Value&#39;]
        x_freqs = {}
        x_periods = {}

        psdValsTAvg = {}
        stDev = {}
        stDevValsP = {}
        stDevValsM = {}
        psdRaw={}
        currTimesUsed={}
        hvsrDF = hvsr_data[&#39;hvsr_df&#39;]

        def move_avg(y, box_pts):
            #box = np.ones(box_pts)/box_pts
            box = np.hanning(box_pts)
            y_smooth = np.convolve(y, box, mode=&#39;same&#39;) / sum(box)
            return y_smooth

        for k in ppsds.keys():
            #input_ppsds = ppsds[k][&#39;psd_values&#39;] #original, not used anymore
            input_ppsds = np.stack(hvsrDF[&#39;psd_values_&#39;+k].values)

            currPPSDs = hvsrDF[&#39;psd_values_&#39;+k][hvsrDF[&#39;Use&#39;]].values
            used_ppsds = np.stack(currPPSDs)
            
            #if reasmpling has been selected
            if resample is True or isinstance(resample, (int, float)):
                if resample is True:
                    resample = 1000 #Default smooth value

                #xValMin = min(ppsds[k][&#39;period_bin_centers&#39;])
                #xValMax = max(ppsds[k][&#39;period_bin_centers&#39;])
                xValMin = 1/hvsr_data[&#39;hvsr_band&#39;][1]
                xValMax = 1/hvsr_data[&#39;hvsr_band&#39;][0]
                #Resample period bin values
                x_periods[k] = np.logspace(np.log10(xValMin), np.log10(xValMax), num=resample)
                if smooth or isinstance(smooth, (int, float)):
                    if smooth:
                        smooth = 51 #Default smoothing window
                        padVal = 25
                    elif smooth % 2==0:
                        smooth +1 #Otherwise, needs to be odd
                        padVal = smooth//2
                        if padVal %2==0:
                            padVal += 1

                #Resample raw ppsd values
                for i, ppsd_t in enumerate(input_ppsds):
                    if i==0:
                        psdRaw[k] = np.interp(x_periods[k], ppsds[k][&#39;period_bin_centers&#39;], ppsd_t)
                        if smooth is not False:
                            padRawKPad = np.pad(psdRaw[k], [padVal, padVal], mode=&#39;reflect&#39;)
                            #padRawKPadSmooth = scipy.signal.savgol_filter(padRawKPad, smooth, 3)
                            padRawKPadSmooth = move_avg(padRawKPad, smooth)
                            psdRaw[k] = padRawKPadSmooth[padVal:-padVal]

                    else:
                        psdRaw[k] = np.vstack((psdRaw[k], np.interp(x_periods[k], ppsds[k][&#39;period_bin_centers&#39;], ppsd_t)))
                        if smooth is not False:
                            padRawKiPad = np.pad(psdRaw[k][i], [padVal, padVal], mode=&#39;reflect&#39;)
                            #padRawKiPadSmooth = scipy.signal.savgol_filter(padRawKiPad, smooth, 3)
                            padRawKiPadSmooth = move_avg(padRawKiPad, smooth)
                            psdRaw[k][i] = padRawKiPadSmooth[padVal:-padVal]

            else:
                #If no resampling desired
                #x_periods[k] = np.array(ppsds[k][&#39;period_bin_centers&#39;])
                x_periods[k] = np.round([1/p for p in hvsr_data[&#39;ppsds&#39;][k][&#39;period_xedges&#39;][:-1]],3)
                x_periods[k][0] = hvsr_data[&#39;hvsr_band&#39;][1]
                x_periods[k][-1] = hvsr_data[&#39;hvsr_band&#39;][0]
                psdRaw[k] = np.array(input_ppsds)

            hvsrDF[&#39;psd_values_&#39;+k] = list(psdRaw[k])

            #Get average psd value across time for each channel (used to calc main H/V curve)
            psdValsTAvg[k] = np.nanmean(np.array(psdRaw[k]), axis=0)
            x_freqs[k] = np.array([1/p for p in x_periods[k]]) #np.divide(np.ones_like(x_periods[k]), x_periods[k]) 
            stDev[k] = np.std(psdRaw[k], axis=0)
            stDevValsM[k] = np.array(psdValsTAvg[k] - stDev[k])
            stDevValsP[k] = np.array(psdValsTAvg[k] + stDev[k])

            currTimesUsed[k] = np.array(hvsrDF[&#39;TimesProcessed_Obspy&#39;][hvsrDF[&#39;Use&#39;]].values)
            #currTimesUsed[k] = ppsds[k][&#39;current_times_used&#39;] #original one
        
        #Get string of method type
        if type(method) is int:
            methodInt = method
            method = methodList[method]
        hvsr_data[&#39;method&#39;] = method

        #This gets the main hvsr curve averaged from all time steps
        anyK = list(x_freqs.keys())[0]
        hvsr_curve, _ = __get_hvsr_curve(x=x_freqs[anyK], psd=psdValsTAvg, method=methodInt, hvsr_data=hvsr_data, verbose=verbose)
        origPPSD = hvsr_data[&#39;ppsds_obspy&#39;].copy()


        #Add some other variables to our output dictionary
        hvsr_dataUpdate = {&#39;input_params&#39;:hvsr_data,
                    &#39;x_freqs&#39;:x_freqs,
                    &#39;hvsr_curve&#39;:hvsr_curve,
                    &#39;x_period&#39;:x_periods,
                    &#39;psd_raw&#39;:psdRaw,
                    &#39;current_times_used&#39;: currTimesUsed,
                    &#39;psd_values_tavg&#39;:psdValsTAvg,
                    &#39;ppsd_std&#39;:stDev,
                    &#39;ppsd_std_vals_m&#39;:stDevValsM,
                    &#39;ppsd_std_vals_p&#39;:stDevValsP,
                    &#39;method&#39;:method,
                    &#39;ppsds&#39;:ppsds,
                    &#39;ppsds_obspy&#39;:origPPSD,
                    &#39;tsteps_used&#39;: hvsr_data[&#39;tsteps_used&#39;].copy(),
                    &#39;hvsr_df&#39;:hvsr_data[&#39;hvsr_df&#39;]
                    }
        
        hvsr_out = HVSRData(hvsr_dataUpdate)

        #This is if manual editing was used (should probably be updated at some point to just use masks)
        if &#39;xwindows_out&#39; in hvsr_data.keys():
            hvsr_out[&#39;xwindows_out&#39;] = hvsr_data[&#39;xwindows_out&#39;]
        else:
            hvsr_out[&#39;xwindows_out&#39;] = []


        freq_smooth_ko = [&#39;konno ohmachi&#39;, &#39;konno-ohmachi&#39;, &#39;konnoohmachi&#39;, &#39;konnohmachi&#39;, &#39;ko&#39;, &#39;k&#39;]
        freq_smooth_constant = [&#39;constant&#39;, &#39;const&#39;, &#39;c&#39;]
        freq_smooth_proport = [&#39;proportional&#39;, &#39;proportion&#39;, &#39;prop&#39;, &#39;p&#39;]

        #Frequency Smoothing
        if not freq_smooth:
            if verbose:
                warnings.warn(&#39;No frequency smoothing is being applied. This is not recommended for noisy datasets.&#39;)
        elif freq_smooth is True or freq_smooth.lower() in freq_smooth_ko:
            from obspy.signal import konnoohmachismoothing
            for k in hvsr_out[&#39;psd_raw&#39;]:
                colName = f&#39;psd_values_{k}&#39;

                ppsd_data = np.stack(hvsr_out[&#39;hvsr_df&#39;][colName])
                ppsd_data = hvsr_out[&#39;psd_raw&#39;][k]


                freqs = hvsr_out[&#39;x_freqs&#39;][k]
                padding_length = int(f_smooth_width)

                padding_value_R = np.nanmean(ppsd_data[:,-1*padding_length:])
                padding_value_L = np.nanmean(ppsd_data[:,:padding_length])

                # Pad the data to prevent boundary anamolies
                padded_ppsd_data = np.pad(ppsd_data, ((0, 0), (padding_length, padding_length)), 
                                          &#39;constant&#39;, constant_values=(padding_value_L, padding_value_R))

                # Pad the frequencies
                ratio = freqs[1] / freqs[0]
                # Generate new elements on either side and combine
                left_padding = [freqs[0] / (ratio ** i) for i in range(padding_length, 0, -1)]
                right_padding = [freqs[-1] * (ratio ** i) for i in range(1, padding_length + 1)]
                padded_freqs = np.concatenate([left_padding, freqs, right_padding])
                
                #Filter out UserWarning for just this method, since it throws up a UserWarning that doesn&#39;t really matter about dtypes often
                with warnings.catch_warnings():
                    warnings.simplefilter(&#39;ignore&#39;, category=UserWarning)
                    smoothed_ppsd_data = konnoohmachismoothing.konno_ohmachi_smoothing(padded_ppsd_data, 
                                                    padded_freqs, bandwidth=f_smooth_width, normalize=True)
                
                #Just use the original data
                smoothed_ppsd_data = smoothed_ppsd_data[:,padding_length:-1*padding_length]
                hvsr_out[&#39;psd_raw&#39;][k] = smoothed_ppsd_data
                hvsr_out[&#39;hvsr_df&#39;][colName] = pd.Series(list(smoothed_ppsd_data), index=hvsr_out[&#39;hvsr_df&#39;].index)

        elif freq_smooth.lower() in freq_smooth_constant:
            hvsr_out = __freq_smooth_window(hvsr_out, f_smooth_width, kind_freq_smooth=&#39;constant&#39;)
        elif freq_smooth.lower() in freq_smooth_proport:
            hvsr_out = __freq_smooth_window(hvsr_out, f_smooth_width, kind_freq_smooth=&#39;proportional&#39;)
        else:
            if verbose:
                warnings.warn(f&#39;You indicated no frequency smoothing should be applied (freq_smooth = {freq_smooth}). This is not recommended for noisy datasets.&#39;)

        #Get hvsr curve from three components at each time step
        anyK = list(hvsr_out[&#39;psd_raw&#39;].keys())[0]
        if method==1 or method ==&#39;dfa&#39; or method ==&#39;Diffuse Field Assumption&#39;:
            pass ###UPDATE HERE NEXT???__get_hvsr_curve(x=hvsr_out[&#39;x_freqs&#39;][anyK], psd=tStepDict, method=methodInt, hvsr_data=hvsr_out, verbose=verbose)
        else:
            hvsr_tSteps = []
            for tStep in range(len(hvsr_out[&#39;psd_raw&#39;][anyK])):
                tStepDict = {}
                for k in hvsr_out[&#39;psd_raw&#39;]:
                    tStepDict[k] = hvsr_out[&#39;psd_raw&#39;][k][tStep]
                hvsr_tstep, _ = __get_hvsr_curve(x=hvsr_out[&#39;x_freqs&#39;][anyK], psd=tStepDict, method=methodInt, hvsr_data=hvsr_out, verbose=verbose)
                hvsr_tSteps.append(np.float32(hvsr_tstep)) #Add hvsr curve for each time step to larger list of arrays with hvsr_curves
        hvsr_out[&#39;hvsr_df&#39;][&#39;HV_Curves&#39;] = hvsr_tSteps

        hvsr_out[&#39;ind_hvsr_curves&#39;] = np.stack(hvsr_out[&#39;hvsr_df&#39;][&#39;HV_Curves&#39;][hvsr_out[&#39;hvsr_df&#39;][&#39;Use&#39;]])
        #hvsr_out[&#39;ind_hvsr_curves&#39;] = np.array(hvsr_tSteps)

        #Initialize array based only on the curves we are currently using
        indHVCurvesArr = np.stack(hvsr_out[&#39;hvsr_df&#39;][&#39;HV_Curves&#39;][hvsr_out[&#39;hvsr_df&#39;][&#39;Use&#39;]])
        #indHVCurvesArr = hvsr_out[&#39;ind_hvsr_curves&#39;]

        if outlier_curve_rmse_percentile:
            if outlier_curve_rmse_percentile is True:
                outlier_curve_rmse_percentile = 98
            hvsr_out = remove_outlier_curves(hvsr_out, use_percentile=True, rmse_thresh=outlier_curve_rmse_percentile, use_hv_curve=True, verbose=verbose)
  
        hvsr_out[&#39;ind_hvsr_stdDev&#39;] = np.nanstd(indHVCurvesArr, axis=0)

        #Get peaks for each time step
        tStepPeaks = []
        for tStepHVSR in hvsr_tSteps:
            tStepPeaks.append(__find_peaks(tStepHVSR))
        hvsr_out[&#39;ind_hvsr_peak_indices&#39;] = tStepPeaks
        hvsr_out[&#39;hvsr_df&#39;][&#39;CurvesPeakIndices&#39;] = tStepPeaks

        tStepPFList = []
        for tPeaks in tStepPeaks:
            tStepPFs = []
            for pInd in tPeaks:
                tStepPFs.append(np.float32(hvsr_out[&#39;x_freqs&#39;][anyK][pInd]))
            tStepPFList.append(tStepPFs)
        hvsr_out[&#39;hvsr_df&#39;][&#39;CurvesPeakFreqs&#39;] = tStepPFList

        #Get peaks of main HV curve
        hvsr_out[&#39;hvsr_peak_indices&#39;] = __find_peaks(hvsr_out[&#39;hvsr_curve&#39;])
        
        #Get frequency values at HV peaks in main curve
        hvsrPF=[]
        for p in hvsr_out[&#39;hvsr_peak_indices&#39;]:
            hvsrPF.append(hvsr_out[&#39;x_freqs&#39;][anyK][p])
        hvsr_out[&#39;hvsr_peak_freqs&#39;] = np.array(hvsrPF)


        #Get other HVSR parameters (i.e., standard deviations, etc.)
        hvsr_out = __gethvsrparams(hvsr_out)

        #Include the original obspy stream in the output
        hvsr_out[&#39;input_stream&#39;] = hvsr_dataUpdate[&#39;input_params&#39;][&#39;input_stream&#39;] #input_stream
        hvsr_out = sprit_utils.make_it_classy(hvsr_out)
        hvsr_out[&#39;ProcessingStatus&#39;][&#39;HVStatus&#39;] = True

        if &#39;processing_parameters&#39; not in hvsr_out.keys():
            hvsr_out[&#39;processing_parameters&#39;] = {}
        hvsr_out[&#39;processing_parameters&#39;][&#39;generate_ppsds&#39;] = {}
        for key, value in orig_args.items():
            hvsr_out[&#39;processing_parameters&#39;][&#39;generate_ppsds&#39;][key] = value

    hvsr_out = _check_processing_status(hvsr_out, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)

    return hvsr_out</code></pre>
</details>
</dd>
<dt id="sprit.read_from_RS"><code class="name flex">
<span>def <span class="ident">read_from_RS</span></span>(<span>dest, src='SHAKENAME@HOSTNAME:/opt/data/archive/YEAR/AM/STATION/', opts='az', username='myshake', password='shakeme', hostname='rs.local', year='2023', sta='RAC84', sleep_time=0.1, verbose=True, save_progress=True, method='scp')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_from_RS(dest, src=&#39;SHAKENAME@HOSTNAME:/opt/data/archive/YEAR/AM/STATION/&#39;, opts=&#39;az&#39;, username=&#39;myshake&#39;, password=&#39;shakeme&#39;,hostname=&#39;rs.local&#39;, year=&#39;2023&#39;, sta=&#39;RAC84&#39;,sleep_time=0.1, verbose=True, save_progress=True, method=&#39;scp&#39;):
    src = src.replace(&#39;SHAKENAME&#39;, username)
    src = src.replace(&#39;SHAKENAME&#39;, hostname)
    src = src.replace(&#39;YEAR&#39;, year)
    src = src.replace(&#39;STATION&#39;, sta)

    if method == &#39;src&#39;:
        &#34;&#34;&#34;This does not work from within a virtual environment!!!!&#34;&#34;&#34;
        #import pexpect
        import sys
        #from pexpect import popen_spawn
        import time
        import wexpect

        scp_command = &#39;scp -r {} &#34;{}&#34;&#39;.format(src, dest)

        print(&#39;Command:&#39;, scp_command)
        child = wexpect.spawn(scp_command, timeout=5)

        child.expect(&#34;password:&#34;)
        child.sendline(password)

        child.expect(wexpect.EOF)

        print(&#34;Files have been successfully transferred to {}!&#34;.format(dest))
    elif method==&#39;rsync&#39;:
        if verbose:
            opts = opts + &#39;v&#39;
        if save_progress:
            opts = opts + &#39;p&#39;   

        #import subprocess
        #subprocess.run([&#34;rsync&#34;, &#34;-&#34;+opts, src, dest])
        #subprocess.run([&#34;rsync&#34;, &#34;-&#34;+opts, src, dest])

        import pty
        #Test, from https://stackoverflow.com/questions/13041732/ssh-password-through-python-subprocess
        command = [
            &#39;rsync&#39;,
            &#34;-&#34;+opts,
            src,
            dest
            #&#39;{0}@{1}&#39;.format(shakename, hostname),
            #&#39;-o&#39;, &#39;NumberOfPasswordPrompts=1&#39;,
            #&#39;sleep {0}&#39;.format(sleep_time),
        ]

        # PID = 0 for child, and the PID of the child for the parent    
        pid, child_fd = pty.fork()

        if not pid: # Child process
            # Replace child process with our SSH process
            os.execv(command[0], command)

        while True:
            output = os.read(child_fd, 1024).strip()
            lower = output.lower()
            # Write the password
            if lower.endswith(&#39;password:&#39;):
                os.write(child_fd, password + &#39;\n&#39;)
                break
            elif &#39;are you sure you want to continue connecting&#39; in lower:
                # Adding key to known_hosts
                os.write(child_fd, &#39;yes\n&#39;)
            elif &#39;company privacy warning&#39; in lower:
                pass # This is an understood message
            else:
                print(&#34;SSH Connection Failed&#34;,
                    &#34;Encountered unrecognized message when spawning &#34;
                    &#34;the SSH tunnel: &#39;{0}&#39;&#34;.format(output))

    return dest</code></pre>
</details>
</dd>
<dt id="sprit.read_tromino_files"><code class="name flex">
<span>def <span class="ident">read_tromino_files</span></span>(<span>datapath, params, sampling_rate=128, start_byte=24576, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read data from tromino. Specifically, this has been lightly tested on Tromino 3G+ machines</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datapath</code></strong> :&ensp;<code>str, pathlib.Path()</code></dt>
<dd>The input parameter <em>datapath</em> from sprit.input_params()</dd>
<dt><strong><code>params</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code></dt>
<dd>The parameters as read in from input_params() and and fetch_data()</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print results to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>obspy.Stream</code></dt>
<dd>An obspy.Stream object containing the trace data from the Tromino instrument</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_tromino_files(datapath, params, sampling_rate=128, start_byte=24576, verbose=False, **kwargs):
    &#34;&#34;&#34;Function to read data from tromino. Specifically, this has been lightly tested on Tromino 3G+ machines

    Parameters
    ----------
    datapath : str, pathlib.Path()
        The input parameter _datapath_ from sprit.input_params()
    params : HVSRData or HVSRBatch
        The parameters as read in from input_params() and and fetch_data()
    verbose : bool, optional
        Whether to print results to terminal, by default False

    Returns
    -------
    obspy.Stream
        An obspy.Stream object containing the trace data from the Tromino instrument
    &#34;&#34;&#34;
    dPath = datapath

    strucSizes = {&#39;c&#39;:1, &#39;b&#39;:1,&#39;B&#39;:1, &#39;?&#39;:1,
                &#39;h&#39;:2,&#39;H&#39;:2,&#39;e&#39;:2,
                &#39;i&#39;:4,&#39;I&#39;:4,&#39;l&#39;:4,&#39;L&#39;:4,&#39;f&#39;:4,
                &#39;q&#39;:8,&#39;Q&#39;:8,&#39;d&#39;:8,
                &#39;n&#39;:8,&#39;N&#39;:8,&#39;s&#39;:16,&#39;p&#39;:16,&#39;P&#39;:16,&#39;x&#39;:16}

    #H (pretty sure it&#39;s Q) I L or Q all seem to work (probably not Q?)
    structFormat = &#39;H&#39;
    structSize = strucSizes[structFormat]

    dataList = []
    with open(dPath, &#39;rb&#39;) as f:
        while True:
            data = f.read(structSize)  # Read 4 bytes
            if not data:  # End of file
                break
            value = struct.unpack(structFormat, data)[0]  # Interpret as a float
            dataList.append(value)
     
    import numpy as np
    dataArr = np.array(dataList)
    import matplotlib.pyplot as plt

    medVal = np.nanmedian(dataArr[50000:100000])

    if &#39;start_byte&#39; in kwargs.keys():
        start_byte = kwargs[&#39;start_byte&#39;]

    startByte = start_byte
    comp1 = dataArr[startByte::3] - medVal
    comp2 = dataArr[startByte+1::3] - medVal
    comp3 = dataArr[startByte+2::3] - medVal
    headerBytes = dataArr[:startByte]

    #fig, ax = plt.subplots(3, sharex=True, sharey=True)
    #ax[0].plot(comp1, linewidth=0.1, c=&#39;k&#39;)
    #ax[1].plot(comp2, linewidth=0.1, c=&#39;k&#39;)
    #ax[2].plot(comp3, linewidth=0.1, c=&#39;k&#39;)

    if &#39;sampling_rate&#39; in kwargs.keys():
        sampling_rate = kwargs[&#39;sampling_rate&#39;]

    sTime = obspy.UTCDateTime(params[&#39;acq_date&#39;].year, params[&#39;acq_date&#39;].month, params[&#39;acq_date&#39;].day,
                              params[&#39;starttime&#39;].hour, params[&#39;starttime&#39;].minute,
                              params[&#39;starttime&#39;].second,params[&#39;starttime&#39;].microsecond)
    eTime = sTime + (((len(comp1))/sampling_rate)/60)*60

    traceHeader1 = {&#39;sampling_rate&#39;:sampling_rate,
            &#39;calib&#39; : 1,
            &#39;npts&#39;:len(comp1),
            &#39;network&#39;:&#39;AM&#39;,
            &#39;location&#39;:&#39;00&#39;,
            &#39;station&#39; : &#39;TRMNO&#39;,
            &#39;channel&#39;:&#39;BHE&#39;,
            &#39;starttime&#39;:sTime}
    
    traceHeader2=traceHeader1.copy()
    traceHeader3=traceHeader1.copy()
    traceHeader2[&#39;channel&#39;] = &#39;BHN&#39;
    traceHeader3[&#39;channel&#39;] = &#39;BHZ&#39;

    trace1 = obspy.Trace(data=comp1, header=traceHeader1)
    trace2 = obspy.Trace(data=comp2, header=traceHeader2)
    trace3 = obspy.Trace(data=comp3, header=traceHeader3)

    st = obspy.Stream([trace1, trace2, trace3])    
    return st</code></pre>
</details>
</dd>
<dt id="sprit.remove_noise"><code class="name flex">
<span>def <span class="ident">remove_noise</span></span>(<span>hvsr_data, remove_method='auto', sat_percent=0.995, noise_percent=0.8, sta=2, lta=30, stalta_thresh=[0.5, 5], warmup_time=0, cooldown_time=0, min_win_size=1, remove_raw_noise=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to remove noisy windows from data, using various methods.</p>
<p>Methods include
- Manual window selection (by clicking on a chart with spectrogram and stream data),
- Auto window selection, which does the following two in sequence (these can also be done indepently):
- A sta/lta "antitrigger" method (using stalta values to automatically remove triggered windows where there appears to be too much noise)
- A noise threshold method, that cuts off all times where the noise threshold equals more than (by default) 80% of the highest amplitude noise sample for the length specified by lta (in seconds)
- A saturation threshold method, that cuts off all times where the noise threshold equals more than (by default) 99.5% of the highest amplitude noise sample.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict, obspy.Stream,</code> or <code>obspy.Trace</code></dt>
<dd>Dictionary containing all the data and parameters for the HVSR analysis</dd>
<dt><strong><code>remove_method</code></strong> :&ensp;<code>str, {'auto', 'manual', 'stalta'/'antitrigger', 'saturation threshold', 'noise threshold', 'warmup'/'cooldown'/'buffer'/'warm_cool'}</code></dt>
<dd>The different methods for removing noise from the dataset. A list of strings will also work, in which case, it should be a list of the above strings. See descriptions above for what how each method works. By default 'auto.'
If remove_method='auto', this is the equivalent of remove_method=['noise threshold', 'antitrigger', 'saturation threshold', 'warm_cool']</dd>
<dt><strong><code>sat_percent</code></strong> :&ensp;<code>float</code>, default=<code>0.995</code></dt>
<dd>Percentage (between 0 and 1), to use as the threshold at which to remove data. This is used in the saturation method. By default 0.995.
If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.</dd>
<dt><strong><code>noise_percent</code></strong> :&ensp;<code>float</code>, default <code>= 0.8</code></dt>
<dd>Percentage (between 0 and 1), to use as the threshold at which to remove data, if it persists for longer than time (in seconds (specified by min_win_size)). This is used in the noise threshold method. By default 0.8.
If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.</dd>
<dt><strong><code>sta</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Short term average (STA) window (in seconds), by default 2. For use with sta/lta antitrigger method.</dd>
<dt><strong><code>lta</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Long term average (STA) window (in seconds), by default 30. For use with sta/lta antitrigger method.</dd>
<dt><strong><code>stalta_thresh</code></strong> :&ensp;<code>list</code>, default=<code>[0.5,5]</code></dt>
<dd>Two-item list or tuple with the thresholds for the stalta antitrigger. The first value (index [0]) is the lower threshold, the second value (index [1] is the upper threshold), by default [0.5,5]</dd>
<dt><strong><code>warmup_time</code></strong> :&ensp;<code>int</code>, default=<code>0</code></dt>
<dd>Time in seconds to allow for warmup of the instrument (or while operator is still near instrument). This will renove any data before this time, by default 0.</dd>
<dt><strong><code>cooldown_time</code></strong> :&ensp;<code>int</code>, default=<code>0</code></dt>
<dd>Time in seconds to allow for cooldown of the instrument (or for when operator is nearing instrument). This will renove any data before this time, by default 0.</dd>
<dt><strong><code>min_win_size</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>The minumum size a window must be over specified threshold (in seconds) for it to be removed</dd>
<dt><strong><code>remove_raw_noise</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If remove_raw_noise=True, will perform operation on raw data ('input_stream'), rather than potentially already-modified data ('stream').</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print status of remove_noise</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary similar to hvsr_data, but containing modified data with 'noise' removed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_noise(hvsr_data, remove_method=&#39;auto&#39;, sat_percent=0.995, noise_percent=0.80, sta=2, lta=30, stalta_thresh=[0.5,5], warmup_time=0, cooldown_time=0, min_win_size=1, remove_raw_noise=False, verbose=False):
    &#34;&#34;&#34;Function to remove noisy windows from data, using various methods.
    
    Methods include 
    - Manual window selection (by clicking on a chart with spectrogram and stream data), 
    - Auto window selection, which does the following two in sequence (these can also be done indepently):
        - A sta/lta &#34;antitrigger&#34; method (using stalta values to automatically remove triggered windows where there appears to be too much noise)
        - A noise threshold method, that cuts off all times where the noise threshold equals more than (by default) 80% of the highest amplitude noise sample for the length specified by lta (in seconds)
        - A saturation threshold method, that cuts off all times where the noise threshold equals more than (by default) 99.5% of the highest amplitude noise sample.

    Parameters
    ----------
    hvsr_data : dict, obspy.Stream, or obspy.Trace
        Dictionary containing all the data and parameters for the HVSR analysis
    remove_method : str, {&#39;auto&#39;, &#39;manual&#39;, &#39;stalta&#39;/&#39;antitrigger&#39;, &#39;saturation threshold&#39;, &#39;noise threshold&#39;, &#39;warmup&#39;/&#39;cooldown&#39;/&#39;buffer&#39;/&#39;warm_cool&#39;}
        The different methods for removing noise from the dataset. A list of strings will also work, in which case, it should be a list of the above strings. See descriptions above for what how each method works. By default &#39;auto.&#39;
        If remove_method=&#39;auto&#39;, this is the equivalent of remove_method=[&#39;noise threshold&#39;, &#39;antitrigger&#39;, &#39;saturation threshold&#39;, &#39;warm_cool&#39;]
    sat_percent : float, default=0.995
        Percentage (between 0 and 1), to use as the threshold at which to remove data. This is used in the saturation method. By default 0.995. 
        If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.
    noise_percent : float, default = 0.8
        Percentage (between 0 and 1), to use as the threshold at which to remove data, if it persists for longer than time (in seconds (specified by min_win_size)). This is used in the noise threshold method. By default 0.8. 
        If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.
    sta : int, optional
        Short term average (STA) window (in seconds), by default 2. For use with sta/lta antitrigger method.
    lta : int, optional
        Long term average (STA) window (in seconds), by default 30. For use with sta/lta antitrigger method.
    stalta_thresh : list, default=[0.5,5]
        Two-item list or tuple with the thresholds for the stalta antitrigger. The first value (index [0]) is the lower threshold, the second value (index [1] is the upper threshold), by default [0.5,5]
    warmup_time : int, default=0
        Time in seconds to allow for warmup of the instrument (or while operator is still near instrument). This will renove any data before this time, by default 0.
    cooldown_time : int, default=0
        Time in seconds to allow for cooldown of the instrument (or for when operator is nearing instrument). This will renove any data before this time, by default 0.
    min_win_size : float, default=1
        The minumum size a window must be over specified threshold (in seconds) for it to be removed
    remove_raw_noise : bool, default=False
        If remove_raw_noise=True, will perform operation on raw data (&#39;input_stream&#39;), rather than potentially already-modified data (&#39;stream&#39;).
    verbose : bool, default=False
        Whether to print status of remove_noise

    Returns
    -------
    output : dict
        Dictionary similar to hvsr_data, but containing modified data with &#39;noise&#39; removed
    &#34;&#34;&#34;
    #Get intput paramaters
    orig_args = locals().copy()
    start_time = datetime.datetime.now()
    
    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;remove_noise&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;remove_noise&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(remove_noise).args[1:], 
                                        inspect.getfullargspec(remove_noise).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    orig_args[k] = v

    remove_method = orig_args[&#39;remove_method&#39;]
    sat_percent = orig_args[&#39;sat_percent&#39;]
    noise_percent = orig_args[&#39;noise_percent&#39;]
    sta = orig_args[&#39;sta&#39;]
    lta = orig_args[&#39;lta&#39;]
    stalta_thresh = orig_args[&#39;stalta_thresh&#39;]
    warmup_time = orig_args[&#39;warmup_time&#39;]
    cooldown_time = orig_args[&#39;cooldown_time&#39;]
    min_win_size = orig_args[&#39;min_win_size&#39;]
    remove_raw_noise = orig_args[&#39;remove_raw_noise&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nRemoving noisy data windows (remove_noise())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key==&#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))

    #Setup lists
    manualList = [&#39;manual&#39;, &#39;man&#39;, &#39;m&#39;, &#39;window&#39;, &#39;windows&#39;, &#39;w&#39;]
    autoList = [&#39;auto&#39;, &#39;automatic&#39;, &#39;all&#39;, &#39;a&#39;]
    antitrigger = [&#39;stalta&#39;, &#39;anti&#39;, &#39;antitrigger&#39;, &#39;trigger&#39;, &#39;at&#39;]
    saturationThresh = [&#39;saturation threshold&#39;, &#39;saturation&#39;, &#39;sat&#39;, &#39;s&#39;]
    noiseThresh = [&#39;noise threshold&#39;, &#39;noise&#39;, &#39;threshold&#39;, &#39;n&#39;]
    warmup_cooldown=[&#39;warmup&#39;, &#39;cooldown&#39;, &#39;warm&#39;, &#39;cool&#39;, &#39;buffer&#39;, &#39;warmup-cooldown&#39;, &#39;warmup_cooldown&#39;, &#39;wc&#39;, &#39;warm_cool&#39;, &#39;warm-cool&#39;]

    #Get Stream from hvsr_data
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        hvsr_out = {}
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] = hvsr_data[site_name] #Get what would normally be the &#34;hvsr_data&#34; variable for each site
            if hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
                try:
                   hvsr_out[site_name] = __remove_noise_batch(**args) #Call another function, that lets us run this function again
                except Exception as e:
                    hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;RemoveNoiseStatus&#39;]=False
                    hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]=False
                    if verbose:
                        print(e)
            else:
                hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;RemoveNoiseStatus&#39;]=False
                hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]=False
                hvsr_out = hvsr_data

        output = HVSRBatch(hvsr_out)
        return output
    elif isinstance(hvsr_data, (HVSRData, dict, obspy.Stream, obspy.Trace)):
        if isinstance(hvsr_data, (HVSRData, dict)):
            if remove_raw_noise:
                inStream = hvsr_data[&#39;input_stream&#39;].copy()
            else:
                inStream = hvsr_data[&#39;stream&#39;].copy()
            output = hvsr_data#.copy()
        else:
            inStream = hvsr_data.copy()
            output = inStream.copy()

        outStream = inStream
        
        if isinstance(remove_method, str):
            if &#39;,&#39; in remove_method:
                remove_method = remove_method.split(&#39;,&#39;)
            else:
                remove_method = [remove_method]
        elif isinstance(remove_method, (list, tuple)):
            pass
        elif not remove_method:
            remove_method=[None]
        else:
            warnings.warn(f&#34;Input value remove_method={remove_method} must be either string, list of strings, None, or False. No noise removal will be carried out. Please choose one of the following: &#39;manual&#39;, &#39;auto&#39;, &#39;antitrigger&#39;, &#39;noise threshold&#39;, &#39;warmup_cooldown&#39;.&#34;)
            return output
            
        #Reorder list so manual is always first
        if len(set(remove_method).intersection(manualList)) &gt; 0:
            manInd = list(set(remove_method).intersection(manualList))[0]
            remove_method.remove(manInd)
            remove_method.insert(0, manInd)
            
        #Go through each type of removal and remove
        for rem_kind in remove_method:
            if not rem_kind:
                break
            elif rem_kind.lower() in manualList:
                if isinstance(output, (HVSRData, dict)):
                    if &#39;xwindows_out&#39; in output.keys():
                        pass
                    else:
                        output = _select_windows(output)
                    window_list = output[&#39;xwindows_out&#39;]
                if isinstance(outStream, obspy.core.stream.Stream):
                    if window_list is not None:
                        output[&#39;stream&#39;] = __remove_windows(inStream, window_list, warmup_time)
                    else:
                        output = _select_windows(output)
                elif isinstance(output, (HVSRData, dict)):
                    pass
                else:
                    RuntimeError(&#34;Only obspy.core.stream.Stream data type is currently supported for manual noise removal method.&#34;)     
            elif rem_kind.lower() in autoList:
                outStream = __remove_noise_thresh(outStream, noise_percent=noise_percent, lta=lta, min_win_size=min_win_size)
                outStream = __remove_anti_stalta(outStream, sta=sta, lta=lta, thresh=stalta_thresh)
                outStream = __remove_noise_saturate(outStream, sat_percent=sat_percent, min_win_size=min_win_size)
                outStream = __remove_warmup_cooldown(stream=outStream, warmup_time=warmup_time, cooldown_time=cooldown_time)
            elif rem_kind.lower() in antitrigger:
                outStream = __remove_anti_stalta(outStream, sta=sta, lta=lta, thresh=stalta_thresh)
            elif rem_kind.lower() in saturationThresh:
                outStream = __remove_noise_saturate(outStream, sat_percent=sat_percent, min_win_size=min_win_size)
            elif rem_kind.lower() in noiseThresh:
                outStream = __remove_noise_thresh(outStream, noise_percent=noise_percent, lta=lta, min_win_size=min_win_size)
            elif rem_kind.lower() in warmup_cooldown:
                outStream = __remove_warmup_cooldown(stream=outStream, warmup_time=warmup_time, cooldown_time=cooldown_time)
            else:
                if len(remove_method)==1:
                    warnings.warn(f&#34;Input value remove_method={remove_method} is not recognized. No noise removal will be carried out. Please choose one of the following: &#39;manual&#39;, &#39;auto&#39;, &#39;antitrigger&#39;, &#39;noise threshold&#39;, &#39;warmup_cooldown&#39;.&#34;)
                    break
                warnings.warn(f&#34;Input value remove_method={remove_method} is not recognized. Continuing with other noise removal methods.&#34;)

        #Add output
        if isinstance(output, (HVSRData, dict)):
            if isinstance(outStream, (obspy.Stream, obspy.Trace)):
                output[&#39;stream&#39;] = outStream
            else:
                output[&#39;stream&#39;] = outStream[&#39;stream&#39;]
            output[&#39;input_stream&#39;] = hvsr_data[&#39;input_stream&#39;]
            
            if &#39;processing_parameters&#39; not in output.keys():
                output[&#39;processing_parameters&#39;] = {}
            output[&#39;processing_parameters&#39;][&#39;remove_noise&#39;] = {}
            for key, value in orig_args.items():
                output[&#39;processing_parameters&#39;][&#39;remove_noise&#39;][key] = value
            
            output[&#39;ProcessingStatus&#39;][&#39;RemoveNoiseStatus&#39;] = True
            output = _check_processing_status(output, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)

            if &#39;hvsr_df&#39; in output.keys() or (&#39;params&#39; in output.keys() and &#39;hvsr_df&#39; in output[&#39;params&#39;].keys())or (&#39;input_params&#39; in output.keys() and &#39;hvsr_df&#39; in output[&#39;input_params&#39;].keys()):
                hvsrDF = output[&#39;hvsr_df&#39;]
                
                outStream = output[&#39;stream&#39;].split()
                for i, trace in enumerate(outStream):
                    if i ==0:
                        trEndTime = trace.stats.endtime
                        comp_end = trace.stats.component
                        continue
                    trStartTime = trace.stats.starttime
                    comp_start = trace.stats.component
                    
                    if trEndTime &lt; trStartTime and comp_end==comp_start:
                        gap = [trEndTime,trStartTime]

                        output[&#39;hvsr_df&#39;][&#39;Use&#39;] = (hvsrDF[&#39;TimesProcessed_Obspy&#39;].gt(gap[0]) &amp; hvsrDF[&#39;TimesProcessed_Obspy&#39;].gt(gap[1]) )| \
                                        (hvsrDF[&#39;TimesProcessed_ObspyEnd&#39;].lt(gap[0]) &amp; hvsrDF[&#39;TimesProcessed_ObspyEnd&#39;].lt(gap[1]))# | \
                        output[&#39;hvsr_df&#39;][&#39;Use&#39;] = output[&#39;hvsr_df&#39;][&#39;Use&#39;].astype(bool)
                    
                    trEndTime = trace.stats.endtime
                
                outStream.merge()
                output[&#39;stream&#39;] = outStream
                    
        elif isinstance(hvsr_data, obspy.Stream) or isinstance(hvsr_data, obspy.Trace):
            output = outStream
        else:
            warnings.warn(f&#34;Output of type {type(output)} for this function will likely result in errors in other processing steps. Returning hvsr_data data.&#34;)
            return hvsr_data
        output = sprit_utils.make_it_classy(output)
        if &#39;xwindows_out&#39; not in output.keys():
            output[&#39;xwindows_out&#39;] = []
    else:
        RuntimeError(f&#34;Input of type type(hvsr_data)={type(hvsr_data)} cannot be used.&#34;)
    
    return output</code></pre>
</details>
</dd>
<dt id="sprit.remove_outlier_curves"><code class="name flex">
<span>def <span class="ident">remove_outlier_curves</span></span>(<span>hvsr_data, rmse_thresh=98, use_percentile=True, use_hv_curve=False, show_outlier_plot=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to remove outliers curves using Root Mean Square Error to calculate the error of each windowed
Probabilistic Power Spectral Density (PPSD) curve against the median PPSD value at each frequency step for all times.
It calculates the RMSE for the PPSD curves of each component individually. All curves are removed from analysis.</p>
<p>Some abberant curves often occur due to the remove_noise() function, so this should be run some time after remove_noise().
In general, the recommended workflow is to run this immediately following the generate_ppsds() function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Input dictionary containing all the values and parameters of interest</dd>
<dt><strong><code>rmse_thresh</code></strong> :&ensp;<code>float</code> or <code>int</code>, default=<code>98</code></dt>
<dd>The Root Mean Square Error value to use as a threshold for determining whether a curve is an outlier.
This averages over each individual entire curve so that curves with very abberant data (often occurs when using the remove_noise() method), can be identified.
Otherwise, specify a float or integer to use as the cutoff RMSE value (all curves with RMSE above will be removed)</dd>
<dt><strong><code>use_percentile</code></strong> :&ensp;<code> float</code>, default=<code>True</code></dt>
<dd>Whether rmse_thresh should be interepreted as a raw RMSE value or as a percentile of the RMSE values.</dd>
<dt><strong><code>use_hv_curve</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to use the calculated HV Curve or the individual components. This can only be True after process_hvsr() has been run.</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show a plot of the removed data</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print output of function to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Input dictionary with values modified based on work of function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_outlier_curves(hvsr_data, rmse_thresh=98, use_percentile=True, use_hv_curve=False, show_outlier_plot=False, verbose=False):
    &#34;&#34;&#34;Function used to remove outliers curves using Root Mean Square Error to calculate the error of each windowed
    Probabilistic Power Spectral Density (PPSD) curve against the median PPSD value at each frequency step for all times.
    It calculates the RMSE for the PPSD curves of each component individually. All curves are removed from analysis.
    
    Some abberant curves often occur due to the remove_noise() function, so this should be run some time after remove_noise(). 
    In general, the recommended workflow is to run this immediately following the generate_ppsds() function.

    Parameters
    ----------
    hvsr_data : dict
        Input dictionary containing all the values and parameters of interest
    rmse_thresh : float or int, default=98
        The Root Mean Square Error value to use as a threshold for determining whether a curve is an outlier. 
        This averages over each individual entire curve so that curves with very abberant data (often occurs when using the remove_noise() method), can be identified.
        Otherwise, specify a float or integer to use as the cutoff RMSE value (all curves with RMSE above will be removed)
    use_percentile :  float, default=True
        Whether rmse_thresh should be interepreted as a raw RMSE value or as a percentile of the RMSE values.
    use_hv_curve : bool, default=False
        Whether to use the calculated HV Curve or the individual components. This can only be True after process_hvsr() has been run.
    show_plot : bool, default=False
        Whether to show a plot of the removed data
    verbose : bool, default=False
        Whether to print output of function to terminal

    Returns
    -------
    hvsr_data : dict
        Input dictionary with values modified based on work of function.
    &#34;&#34;&#34;
    # Setup function
    #Get intput paramaters
    orig_args = locals().copy()
    start_time = datetime.datetime.now()
    
    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;remove_outlier_curves&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;remove_noise&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(remove_outlier_curves).args[1:], 
                                        inspect.getfullargspec(remove_outlier_curves).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    orig_args[k] = v

    # Reset parameters in case of manual override of imported parameters
    use_percentile = orig_args[&#39;use_percentile&#39;]
    rmse_thresh = orig_args[&#39;rmse_thresh&#39;]
    use_hv_curve = orig_args[&#39;use_hv_curve&#39;]
    show_outlier_plot = orig_args[&#39;show_outlier_plot&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    #Print if verbose, which changes depending on if batch data or not
    if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nRemoving outlier curves from further analysis (remove_outlier_curves())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key==&#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))
            print()
    
    #First, divide up for batch or not
    #Site is in the keys anytime it&#39;s not batch
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        hvsr_out = {}
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] = hvsr_data[site_name] #Get what would normally be the &#34;hvsr_data&#34; variable for each site
            if hvsr_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
                try:
                    hvsr_out[site_name] = __remove_outlier_curves(**args) #Call another function, that lets us run this function again
                except:
                    hvsr_out = hvsr_data
                    hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;RemoveOutlierCurves&#39;] = False
                    hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False                    
            else:
                hvsr_out = hvsr_data
                hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;RemoveOutlierCurves&#39;] = False
                hvsr_out[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False
        hvsr_out = HVSRBatch(hvsr_out)
    else:  
        #Create plot if designated        
        if not use_hv_curve:
            compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
            colNames = compNames
        else:
            compNames=[&#39;HV Curve&#39;]
            colNames = [&#39;HV_Curves&#39;]
        if show_outlier_plot:
            if use_hv_curve:
                spMosaic = [&#39;HV Curve&#39;]
            else:
                spMosaic = [[&#39;Z&#39;],
                            [&#39;E&#39;],
                            [&#39;N&#39;]]
            fig, ax=plt.subplot_mosaic(spMosaic, sharex=True)

        #Loop through each component, and determine which curves are outliers
        bad_rmse=[]
        for i, column in enumerate(colNames):
            if column in compNames:
                column = &#39;psd_values_&#39;+column
            # Retrieve data from dataframe (use all windows, just in case)
            curr_data = np.stack(hvsr_data[&#39;hvsr_df&#39;][column])
            
            # Calculate a median curve, and reshape so same size as original
            medCurve = np.nanmedian(curr_data, axis=0)
            medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))
            
            # Calculate RMSE
            rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])
            hvsr_data[&#39;hvsr_df&#39;][&#39;RMSE_&#39;+column] = rmse
            if use_percentile is True:
                rmse_threshold = np.percentile(rmse, rmse_thresh)
                if verbose:
                    print(f&#39;\tRMSE at {rmse_thresh}th percentile for {column} calculated at: {rmse_threshold:.2f}&#39;)
                else:
                    rmse_threshold = rmse_thresh
            
            # Retrieve index of those RMSE values that lie outside the threshold
            for j, curve in enumerate(curr_data):
                if rmse[j] &gt; rmse_threshold:
                    bad_rmse.append(j)

            # Show plot of removed/retained data
            if show_outlier_plot:
                # Intialize to only get unique labels
                rem_label_got = False
                keep_label_got = False
                
                # Iterate through each curve to determine if it&#39;s rmse is outside threshold, for plot
                for j, curve in enumerate(curr_data):
                    label=None
                    if rmse[j] &gt; rmse_threshold:
                        linestyle = &#39;dashed&#39;
                        linecolor=&#39;darkred&#39;
                        alpha = 1
                        linewidth = 1
                        if not rem_label_got:
                            label=&#39;Removed Curve&#39;
                            rem_label_got=True
                    else:
                        linestyle=&#39;solid&#39;
                        linecolor = &#39;rosybrown&#39;
                        alpha = 0.25
                        linewidth=0.5
                        if not keep_label_got:
                            keep_label_got=True
                            label=&#39;Retained Curve&#39;

                    # Plot each individual curve
                    ax[compNames[i]].plot(1/hvsr_data.ppsds[compNames[i]][&#39;period_bin_centers&#39;], curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)
                
                # Plot the median curve
                ax[compNames[i]].plot(1/hvsr_data.ppsds[compNames[i]][&#39;period_bin_centers&#39;],medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)
                
                # Format axis
                ax[compNames[i]].set_ylabel(f&#34;{compNames[i]}&#34;)
                ax[compNames[i]].legend(fontsize=10, labelspacing=0.1)
                ax[compNames[i]].semilogx()             
        if show_outlier_plot:
            plt.show()
                    
        # Get unique values of bad_rmse indices and set the &#34;Use&#34; column of the hvsr_df to False for that window
        bad_rmse = np.unique(bad_rmse)
        if len(bad_rmse) &gt; 0:
            
            hvsr_data[&#39;hvsr_df&#39;][&#39;Use&#39;] = hvsr_data[&#39;hvsr_df&#39;][&#39;Use&#39;] * (rmse_threshold &gt; hvsr_data[&#39;hvsr_df&#39;][&#39;RMSE_&#39;+column])
            #hvsr_data[&#39;hvsr_df&#39;].loc[bad_index, &#34;Use&#34;] = False   
        
        if verbose:
            if len(bad_rmse)&gt;0:
                print(f&#34;\tThe windows starting at the following times have been removed from further analysis ({len(bad_rmse)}/{hvsr_data[&#39;hvsr_df&#39;].shape[0]}):&#34;)
                for b in hvsr_data[&#39;hvsr_df&#39;].index[pd.Series(bad_rmse)]:
                    print(f&#34;\t\t{b}&#34;)
            else:
                print(&#39;\tNo outlier curves have been removed&#39;)
                    
        hvsr_out = hvsr_data

        if &#39;processing_parameters&#39; not in hvsr_out.keys():
            hvsr_out[&#39;processing_parameters&#39;] = {}
        hvsr_out[&#39;processing_parameters&#39;][&#39;remove_outlier_curves&#39;] = {}
        for key, value in orig_args.items():
            hvsr_out[&#39;processing_parameters&#39;][&#39;remove_outlier_curves&#39;][key] = value

        hvsr_data[&#39;ProcessingStatus&#39;][&#39;RemoveOutlierCurvesStatus&#39;] = True
    
    hvsr_out = _check_processing_status(hvsr_out, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)
    
    return hvsr_out</code></pre>
</details>
</dd>
<dt id="sprit.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>datapath, source='file', verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The sprit.run() is the main function that allows you to do all your HVSR processing in one simple step (sprit.run() is how you would call it in your code, but it may also be called using sprit.sprit_hvsr.run())</p>
<p>The datapath parameter of sprit.run() is the only required parameter. This can be either a single file, a list of files (one for each component, for example), a directory (in which case, all obspy-readable files will be added to an HVSRBatch instance), a Rasp. Shake raw data directory, or sample data.</p>
<pre><code>The sprit.run() function calls the following functions. This is the recommended order/set of functions to run to process HVSR using SpRIT. See the API documentation for these functions for more information:
- input_params(): The datapath parameter of input_params() is the only required variable, though others may also need to be called for your data to process correctly.
- fetch_data(): the source parameter of fetch_data() is the only explicit variable in the sprit.run() function aside from datapath and verbose. Everything else gets delivered to the correct function via the kwargs dictionary
- remove_noise(): by default, the kind of noise removal is remove_method='auto'. See the remove_noise() documentation for more information. If remove_method is set to anything other than one of the explicit options in remove_noise, noise removal will not be carried out.
- generate_ppsds(): generates ppsds for each component, which will be combined/used later. Any parameter of obspy.signal.spectral_estimation.PPSD() may also be read into this function.
- remove_outlier_curves(): removes any outlier ppsd curves so that the data quality for when curves are combined will be enhanced. See the remove_outlier_curves() documentation for more information.
- process_hvsr(): this is the main function processing the hvsr curve and statistics. See process_hvsr() documentation for more details. The hvsr_band parameter sets the frequency spectrum over which these calculations occur.
- check_peaks(): this is the main function that will find and 'score' peaks to get a best peak. The parameter peak_freq_range can be set to limit the frequencies within which peaks are checked and scored.
- get_report(): this is the main function that will print, plot, and/or save the results of the data. See the get_report() API documentation for more information.
- export_data(): this function exports the final data output as a pickle file (by default, this pickle object has a .hvsr extension). This can be used to read data back into SpRIT without having to reprocess data.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datapath</code></strong> :&ensp;<code>str</code> or <code>filepath object that can be read by obspy</code></dt>
<dd>Filepath to data to be processed. This may be a file or directory, depending on what kind of data is being processed (this can be specified with the source parameter).
For sample data, The following can be specified as the datapath parameter:
- Any integer 1-6 (inclusive), or the string (e.g., datapath="1" or datapath=1 will work)
- The word "sample" before any integer (e.g., datapath="sample1")
- The word "sample" will default to "sample1" if source='file'.
- If source='batch', datapath should be datapath='sample' or datapath='batch'. In this case, it will read and process all the sample files using the HVSRBatch class. Set verbose=True to see all the information in the sample batch csv file.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd><em>description</em>, by default 'file'</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>, by default False</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for the functions listed above. The keyword arguments are unique, so they will get parsed out and passed into the appropriate function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>If a single file/data point is being processed, a HVSRData object will be returned. Otherwise, it will be a HVSRBatch object. See their documention for more information.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the input parameter may not be read correctly. This is raised if the input_params() function fails. This raises an error since no other data processing or reading steps will be able to carried out correctly.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the data is not read/fetched correctly using fetch_data(), an error will be raised. This is raised if the fetch_data() function fails. This raises an error since no other data processing steps will be able to carried out correctly.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the data being processed is a single file, an error will be raised if generate_ppsds() does not work correctly. No errors are raised for remove_noise() errors (since that is an optional step) and the process_hvsr() step (since that is the last processing step) .</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(datapath, source=&#39;file&#39;, verbose=False, **kwargs):
    &#34;&#34;&#34;The sprit.run() is the main function that allows you to do all your HVSR processing in one simple step (sprit.run() is how you would call it in your code, but it may also be called using sprit.sprit_hvsr.run())
    
    The datapath parameter of sprit.run() is the only required parameter. This can be either a single file, a list of files (one for each component, for example), a directory (in which case, all obspy-readable files will be added to an HVSRBatch instance), a Rasp. Shake raw data directory, or sample data.
    
        The sprit.run() function calls the following functions. This is the recommended order/set of functions to run to process HVSR using SpRIT. See the API documentation for these functions for more information:
        - input_params(): The datapath parameter of input_params() is the only required variable, though others may also need to be called for your data to process correctly.
        - fetch_data(): the source parameter of fetch_data() is the only explicit variable in the sprit.run() function aside from datapath and verbose. Everything else gets delivered to the correct function via the kwargs dictionary
        - remove_noise(): by default, the kind of noise removal is remove_method=&#39;auto&#39;. See the remove_noise() documentation for more information. If remove_method is set to anything other than one of the explicit options in remove_noise, noise removal will not be carried out.
        - generate_ppsds(): generates ppsds for each component, which will be combined/used later. Any parameter of obspy.signal.spectral_estimation.PPSD() may also be read into this function.
        - remove_outlier_curves(): removes any outlier ppsd curves so that the data quality for when curves are combined will be enhanced. See the remove_outlier_curves() documentation for more information.
        - process_hvsr(): this is the main function processing the hvsr curve and statistics. See process_hvsr() documentation for more details. The hvsr_band parameter sets the frequency spectrum over which these calculations occur.
        - check_peaks(): this is the main function that will find and &#39;score&#39; peaks to get a best peak. The parameter peak_freq_range can be set to limit the frequencies within which peaks are checked and scored.
        - get_report(): this is the main function that will print, plot, and/or save the results of the data. See the get_report() API documentation for more information.
        - export_data(): this function exports the final data output as a pickle file (by default, this pickle object has a .hvsr extension). This can be used to read data back into SpRIT without having to reprocess data.

    Parameters
    ----------
    datapath : str or filepath object that can be read by obspy
        Filepath to data to be processed. This may be a file or directory, depending on what kind of data is being processed (this can be specified with the source parameter). 
        For sample data, The following can be specified as the datapath parameter:
            - Any integer 1-6 (inclusive), or the string (e.g., datapath=&#34;1&#34; or datapath=1 will work)
            - The word &#34;sample&#34; before any integer (e.g., datapath=&#34;sample1&#34;)
            - The word &#34;sample&#34; will default to &#34;sample1&#34; if source=&#39;file&#39;. 
            - If source=&#39;batch&#39;, datapath should be datapath=&#39;sample&#39; or datapath=&#39;batch&#39;. In this case, it will read and process all the sample files using the HVSRBatch class. Set verbose=True to see all the information in the sample batch csv file.
    source : str, optional
        _description_, by default &#39;file&#39;
    verbose : bool, optional
        _description_, by default False
    **kwargs
        Keyword arguments for the functions listed above. The keyword arguments are unique, so they will get parsed out and passed into the appropriate function.

    Returns
    -------
    hvsr_results : sprit.HVSRData or sprit.HVSRBatch object
        If a single file/data point is being processed, a HVSRData object will be returned. Otherwise, it will be a HVSRBatch object. See their documention for more information.

    Raises
    ------
    RuntimeError
        If the input parameter may not be read correctly. This is raised if the input_params() function fails. This raises an error since no other data processing or reading steps will be able to carried out correctly.
    RuntimeError
        If the data is not read/fetched correctly using fetch_data(), an error will be raised. This is raised if the fetch_data() function fails. This raises an error since no other data processing steps will be able to carried out correctly.
    RuntimeError
        If the data being processed is a single file, an error will be raised if generate_ppsds() does not work correctly. No errors are raised for remove_noise() errors (since that is an optional step) and the process_hvsr() step (since that is the last processing step) .
    &#34;&#34;&#34;
   
    if &#39;hvsr_band&#39; not in kwargs.keys():
        kwargs[&#39;hvsr_band&#39;] = inspect.signature(input_params).parameters[&#39;hvsr_band&#39;].default
    if &#39;peak_freq_range&#39; not in kwargs.keys():
        kwargs[&#39;peak_freq_range&#39;] = inspect.signature(input_params).parameters[&#39;peak_freq_range&#39;].default

    #Get the input parameters
    input_params_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(input_params).parameters.keys())}  
    try:
        params = input_params(datapath=datapath, verbose=verbose, **input_params_kwargs)
    except:
        #Even if batch, this is reading in data for all sites so we want to raise error, not just warn
        raise RuntimeError(&#39;Input parameters not read correctly, see sprit.input_params() function and parameters&#39;)
        #If input_params fails, initialize params as an HVSRDATA
        params = {&#39;ProcessingStatus&#39;:{&#39;InputParamsStatus&#39;:False, &#39;OverallStatus&#39;:False}}
        params.update(input_params_kwargs)
        params = sprit_utils.make_it_classy(params)

    #Fetch Data
    try:
        fetch_data_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(fetch_data).parameters.keys())}
        dataIN = fetch_data(params=params, source=source, verbose=verbose, **fetch_data_kwargs)    
    except:
        #Even if batch, this is reading in data for all sites so we want to raise error, not just warn
        raise RuntimeError(&#39;Data not read correctly, see sprit.fetch_data() function and parameters for more details.&#39;)
    
    # Remove Noise
    try:
        remove_noise_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(remove_noise).parameters.keys())}
        data_noiseRemoved = remove_noise(hvsr_data=dataIN, verbose=verbose,**remove_noise_kwargs)   
    except:
        data_noiseRemoved = dataIN
        
        #Reformat data so HVSRData and HVSRBatch data both work here
        if isinstance(data_noiseRemoved, HVSRData):
            data_noiseRemoved = {&#39;place_holder_sitename&#39;:data_noiseRemoved}
            dataIN = {&#39;place_holder_sitename&#39;:dataIN}
            
        for site_name in data_noiseRemoved.keys():
            data_noiseRemoved[site_name][&#39;ProcessingStatus&#39;][&#39;RemoveNoiseStatus&#39;]=False
            #Since noise removal is not required for data processing, check others first
            if dataIN[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;]:
                data_noiseRemoved[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = True        
            else:
                data_noiseRemoved[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False

            #If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            if not data_noiseRemoved[site_name][&#39;batch&#39;]:
                data_noiseRemoved = data_noiseRemoved[site_name]
    
    # Generate PPSDs
    try:
        generate_ppsds_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(generate_ppsds).parameters.keys())}
        PPSDkwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(PPSD).parameters.keys())}
        generate_ppsds_kwargs.update(PPSDkwargs)
        ppsd_data = generate_ppsds(hvsr_data=data_noiseRemoved, verbose=verbose,**generate_ppsds_kwargs)
    except Exception as e:
        if source == &#39;file&#39; or source==&#39;raw&#39;:
            if hasattr(e, &#39;message&#39;):
                errMsg = e.message
            else:
                errMsg = e
            raise RuntimeError(f&#34;generate_ppsds() error: {errMsg}&#34;)

        #Reformat data so HVSRData and HVSRBatch data both work here
        ppsd_data = data_noiseRemoved
        if isinstance(ppsd_data, HVSRData):
            ppsd_data = {&#39;place_holder_sitename&#39;:ppsd_data}
            
        for site_name in ppsd_data.keys(): #This should work more or less the same for batch and regular data now
            ppsd_data[site_name][&#39;ProcessingStatus&#39;][&#39;PPSDStatus&#39;]=False
            ppsd_data[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False
    
            #If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            if not ppsd_data[site_name][&#39;batch&#39;]:
                ppsd_data = ppsd_data[site_name]
    
    # Remove Outlier Curves
    try:
        remove_outlier_curve_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(remove_outlier_curves).parameters.keys())}
        data_curvesRemoved = remove_outlier_curves(hvsr_data=ppsd_data, verbose=verbose,**remove_outlier_curve_kwargs)   
    except Exception as e:
        traceback.print_exception(sys.exc_info()[1])
        exc_type, exc_obj, tb = sys.exc_info()
        f = tb.tb_frame
        lineno = tb.tb_lineno
        filename = f.f_code.co_filename
        errLineNo = str(traceback.extract_tb(sys.exc_info()[2])[-1].lineno)
        error_category = type(e).__name__.title().replace(&#39;error&#39;, &#39;Error&#39;)
        error_message = f&#34;{e} ({errLineNo})&#34;
        print(f&#34;{error_category} ({errLineNo}): {error_message}&#34;)
        print(lineno, filename, f)
        
        #Reformat data so HVSRData and HVSRBatch data both work here
        data_curvesRemoved = ppsd_data
        if isinstance(data_curvesRemoved, HVSRData):
            data_curvesRemoved = {&#39;place_holder_sitename&#39;:data_curvesRemoved}
            
        for site_name in data_curvesRemoved.keys(): #This should work more or less the same for batch and regular data now
            data_curvesRemoved[site_name][&#39;ProcessingStatus&#39;][&#39;RemoveOutlierCurvesStatus&#39;] = False
            data_curvesRemoved[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False
    
            #If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            if not data_curvesRemoved[site_name][&#39;batch&#39;]:
                data_curvesRemoved = data_curvesRemoved[site_name]
    
    # Process HVSR Curves
    try:
        process_hvsr_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(process_hvsr).parameters.keys())}
        hvsr_results = process_hvsr(hvsr_data=ppsd_data, verbose=verbose,**process_hvsr_kwargs)
    except Exception as e:
        traceback.print_exception(sys.exc_info()[1])
        exc_type, exc_obj, tb = sys.exc_info()
        f = tb.tb_frame
        lineno = tb.tb_lineno
        filename = f.f_code.co_filename
        errLineNo = str(traceback.extract_tb(sys.exc_info()[2])[-1].lineno)
        error_category = type(e).__name__.title().replace(&#39;error&#39;, &#39;Error&#39;)
        error_message = f&#34;{e} ({errLineNo})&#34;
        print(f&#34;{error_category} ({errLineNo}): {error_message}&#34;)
        print(lineno, filename, f)

        hvsr_results = ppsd_data
        if isinstance(hvsr_results, HVSRData):
            hvsr_results = {&#39;place_holder_sitename&#39;:hvsr_results}
            
        for site_name in hvsr_results.keys(): #This should work more or less the same for batch and regular data now
        
            hvsr_results[site_name][&#39;ProcessingStatus&#39;][&#39;HVStatus&#39;]=False
            hvsr_results[site_name][&#39;ProcessingStatus&#39;][&#39;OverallStatus&#39;] = False
            
            #If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            if not hvsr_results[site_name][&#39;batch&#39;]:
                hvsr_results = hvsr_results[site_name]            
            
    #Final post-processing/reporting

    # Check peaks
    check_peaks_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(check_peaks).parameters.keys())}
    hvsr_results = check_peaks(hvsr_data=hvsr_results, verbose=verbose, **check_peaks_kwargs)

    get_report_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in tuple(inspect.signature(get_report).parameters.keys())}
    get_report(hvsr_results=hvsr_results, verbose=verbose, **get_report_kwargs)

    if verbose:
        if &#39;report_format&#39; in get_report_kwargs.keys():
            #if report_format is &#39;print&#39;, we would have already printed it in previous step
            if get_report_kwargs[&#39;report_format&#39;]==&#39;print&#39; or &#39;print&#39; in get_report_kwargs[&#39;report_format&#39;] or isinstance(hvsr_results, HVSRBatch):
                #We do not need to print another report if already printed to terminal
                pass
            else:
                #We will just change the report_format kwarg to print, since we already got the originally intended report format above, 
                #   now need to print for verbose output
                get_report_kwargs[&#39;report_format&#39;]=&#39;print&#39;
                get_report(hvsr_results=hvsr_results, **get_report_kwargs)
                
            if get_report_kwargs[&#39;report_format&#39;]==&#39;plot&#39; or &#39;plot&#39; in get_report_kwargs[&#39;report_format&#39;]:
                #We do not need to plot another report if already plotted
                pass
            else:
                #hvplot_kwargs = {k: v for k, v in locals()[&#39;kwargs&#39;].items() if k in plot_hvsr.__code__.co_varnames}
                #hvsr_results[&#39;HV_Plot&#39;] = plot_hvsr(hvsr_results, return_fig=True, show=False, close_figs=True)
                pass
        else:
            pass
    
    #Export processed data if export_path(as pickle currently, default .hvsr extension)
    if &#39;export_path&#39; in kwargs.keys():
        if kwargs[&#39;export_path&#39;] is None:
            pass
        else:
            if &#39;ext&#39; in kwargs.keys():
                ext = kwargs[&#39;ext&#39;]
            else:
                ext = &#39;hvsr&#39;
            export_data(hvsr_data=hvsr_results, export_path=kwargs[&#39;export_path&#39;], ext=ext, verbose=verbose)        

    return hvsr_results</code></pre>
</details>
</dd>
<dt id="sprit.time_it"><code class="name flex">
<span>def <span class="ident">time_it</span></span>(<span>_t, proc_name='', verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes elapsed time since the last call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_it(_t, proc_name=&#39;&#39;, verbose=True):
    &#34;&#34;&#34;Computes elapsed time since the last call.&#34;&#34;&#34;
    t1 = datetime.datetime.now().time()
    dt = t1 - _t
    t = _t
    if dt &gt; 0.05:
        if verbose:
            print(f&#39;[ELAPSED TIME] {dt:0.1f} s&#39;, flush=True)
        t = t1
    return t</code></pre>
</details>
</dd>
<dt id="sprit.x_mark"><code class="name flex">
<span>def <span class="ident">x_mark</span></span>(<span>incolor=False, inTerminal=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The default Windows terminal is not able to display the check mark character correctly.
This function returns another displayable character if platform is Windows</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_mark(incolor=False, inTerminal=False):
    &#34;&#34;&#34;The default Windows terminal is not able to display the check mark character correctly.
       This function returns another displayable character if platform is Windows&#34;&#34;&#34;
    
    if incolor:
        try:
            xmark = get_char(u&#39;\u274C&#39;)
        except:
            xmark = get_char(u&#39;\u2718&#39;)
    else:
        xmark = get_char(u&#39;\u2718&#39;)
    return xmark</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sprit.HVSRBatch"><code class="flex name class">
<span>class <span class="ident">HVSRBatch</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>HVSRBatch is the data container used for batch processing. It contains several HVSRData objects (one for each site). These can be accessed using their site name, either square brackets (HVSRBatchVariable["SiteName"]) or the dot (HVSRBatchVariable.SiteName) accessor.</p>
<p>The dot accessor may not work if there is a space in the site name.</p>
<p>All of the
functions in the sprit.pacakge are designed to perform the bulk of their operations iteratively on the individual HVSRData objects contained in the HVSRBatch object, and do little with the HVSRBatch object itself, besides using it determine which sites are contained within it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HVSRBatch:
    &#34;&#34;&#34;HVSRBatch is the data container used for batch processing. It contains several HVSRData objects (one for each site). These can be accessed using their site name, either square brackets (HVSRBatchVariable[&#34;SiteName&#34;]) or the dot (HVSRBatchVariable.SiteName) accessor.
    
    The dot accessor may not work if there is a space in the site name.
    
    All of the  functions in the sprit.pacakge are designed to perform the bulk of their operations iteratively on the individual HVSRData objects contained in the HVSRBatch object, and do little with the HVSRBatch object itself, besides using it determine which sites are contained within it.
    
    &#34;&#34;&#34;
    @check_instance
    def __init__(self, batch_dict, azimuth=None):
        &#34;&#34;&#34;HVSR Batch initializer

        Parameters
        ----------
        batch_dict : dict
            Dictionary containing Key value pairs with either {sitename:HVSRData object} or {azimuth_angle_degrees:HVSRData object}
        azimuth : None or numeric, default=None
            If None, HVSRBatch object will be a batch of sites. If other value, it should be a list of numeric values of the azimuths (in degrees), by default None.
        &#34;&#34;&#34;
        self._batch_dict = batch_dict
        self.batch_dict = self._batch_dict
        self.batch = True
        self.batch_type = &#39;sites&#39;
        if azimuth is not None:
            self.batch_type = &#39;azimuths&#39;
        
        if self.batch_type==&#39;sites&#39;:
            for sitename, hvsrdata in batch_dict.items():
                setattr(self, sitename, hvsrdata)
                self[sitename][&#39;batch&#39;]=True  
            self.sites = list(self._batch_dict.keys())
            self.azimuths = azimuth # Should be None
        elif self.batch_tupe ==&#39;azimuths&#39;:
            self.azimuths = azimuth
            self.sites = []
            for az, hvsrdata in batch_dict.items():
                azkey = str(az).zfill(3)
                setattr(self, azkey, hvsrdata)
                self[azkey][&#39;batch&#39;]=True
                self.sites.append(hvsrdata[&#39;site&#39;])

    #METHODS
    def __to_json(self, filepath):
        &#34;&#34;&#34;Not yet implemented, but may allow import/export to json files in the future, rather than just .hvsr pickles

        Parameters
        ----------
        filepath : filepath object
            Location to save HVSRBatch object as json
        &#34;&#34;&#34;
        # open the file with the given filepath
        with open(filepath, &#39;w&#39;) as f:
            # dump the JSON string to the file
            json.dump(self, f, default=lambda o: o.__dict__, sort_keys=True, indent=4)

    def export(self, export_path=True, ext=&#39;hvsr&#39;):
        &#34;&#34;&#34;Method to export HVSRData objects in HVSRBatch container to indivdual .hvsr pickle files.

        Parameters
        ----------
        export_path : filepath, default=True
            Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). By default True. If True, it will first try to save each file to the same directory as datapath, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
        ext : str, optional
            The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
        &#34;&#34;&#34;
        export_data(hvsr_data=self, export_path=export_path, ext=ext)

    def keys(self):
        &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRBatch object. For HVSRBatch objects, these are the site names. Functions similar to dict.keys().

        Returns
        -------
        dict_keys
            A dict_keys object listing the site names of each of the HVSRData objects contained in the HVSRBatch object
        &#34;&#34;&#34;
        return self.batch_dict.keys()

    def items(self):
        &#34;&#34;&#34;Method to return both the site names and the HVSRData object as a set of dict_items tuples. Functions similar to dict.items().

        Returns
        -------
        _type_
            _description_
        &#34;&#34;&#34;
        return self.batch_dict.items()

    def copy(self, type=&#39;shallow&#39;):
        &#34;&#34;&#34;Make a copy of the HVSRBatch object. Uses python copy module.
        
        Parameters
        ----------
        type : str {&#39;shallow&#39;, &#39;deep&#39;}
            Based on input, creates either a shallow or deep copy of the HVSRBatch object. Shallow is equivalent of copy.copy(). Input of &#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.
    
        &#34;&#34;&#34;
        if type.lower()==&#39;deep&#39;:
            return HVSRBatch(copy.deepcopy(self._batch_dict))
        else:
            return HVSRBatch(copy.copy(self._batch_dict))

    #Method wrapper of sprit.plot_hvsr function
    def plot(self, **kwargs):
        &#34;&#34;&#34;Method to plot data, based on the sprit.plot_hvsr() function. All the same kwargs and default values apply as plot_hvsr(). For return_fig, returns it to the &#39;Plot_Report&#39; attribute of each HVSRData object

        Returns
        -------
        _type_
            _description_
        &#34;&#34;&#34;
        for sitename in self:
            if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
                self[sitename][&#39;Plot_Report&#39;] = plot_hvsr(self[sitename], **kwargs)
            else:
                plot_hvsr(self[sitename], **kwargs)

        return self
    
    def get_report(self, **kwargs):
        &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

        Returns
        -------
        Variable
            May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.
        &#34;&#34;&#34;
        if &#39;report_format&#39; in kwargs.keys():
            if &#39;csv&#39; == kwargs[&#39;report_format&#39;]:
                for sitename in self:
                    rowList = []
                    rowList.append(get_report(self[sitename], **kwargs))
                return pd.concat(rowList, ignore_index=True)
            elif &#39;plot&#39; == kwargs[&#39;report_format&#39;]:
                plotDict = {}
                for sitename in self:
                    if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
                        plotDict[sitename] = get_report(self[sitename], **kwargs)
                    else:
                        get_report(self[sitename], **kwargs)
                return plotDict
            
        #Only report_format left is print, doesn&#39;t return anything, so doesn&#39;t matter if defalut or not
        for sitename in self:
            get_report(self[sitename], **kwargs)
        return

    def report(self, **kwargs):
        &#34;&#34;&#34;Wrapper of get_report()&#34;&#34;&#34;
        return self.get_report(**kwargs)

    def export_settings(self, site_name=None, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
        &#34;&#34;&#34;Method to export settings from HVSRData object in HVSRBatch object. Simply calls sprit.export_settings() from specified HVSRData object in the HVSRBatch object. See sprit.export_settings() for more details.

        Parameters
        ----------
        site_name : str, default=None
            The name of the site whose settings should be exported. If None, will default to the first site, by default None.
        export_settings_path : str, optional
            Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
        export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
            They type of settings to save, by default &#39;all&#39;
        include_location : bool, optional
            Whether to include the location information in the instrument settings, if that settings type is selected, by default False
        verbose : bool, optional
            Whether to print output (filepath and settings) to terminal, by default True
        &#34;&#34;&#34;
        #If no site name selected, use first site
        if site_name is None:
            site_name = self.sites[0]
            
        export_settings(hvsr_data=self[site_name], 
                        export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)

    def __iter__(self):
        return iter(self._batch_dict.keys())

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, key):
        return getattr(self, key)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sprit.HVSRBatch.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, type='shallow')</span>
</code></dt>
<dd>
<div class="desc"><p>Make a copy of the HVSRBatch object. Uses python copy module.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str {'shallow', 'deep'}</code></dt>
<dd>Based on input, creates either a shallow or deep copy of the HVSRBatch object. Shallow is equivalent of copy.copy(). Input of 'deep' is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, type=&#39;shallow&#39;):
    &#34;&#34;&#34;Make a copy of the HVSRBatch object. Uses python copy module.
    
    Parameters
    ----------
    type : str {&#39;shallow&#39;, &#39;deep&#39;}
        Based on input, creates either a shallow or deep copy of the HVSRBatch object. Shallow is equivalent of copy.copy(). Input of &#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.

    &#34;&#34;&#34;
    if type.lower()==&#39;deep&#39;:
        return HVSRBatch(copy.deepcopy(self._batch_dict))
    else:
        return HVSRBatch(copy.copy(self._batch_dict))</code></pre>
</details>
</dd>
<dt id="sprit.HVSRBatch.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, export_path=True, ext='hvsr')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export HVSRData objects in HVSRBatch container to indivdual .hvsr pickle files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>export_path</code></strong> :&ensp;<code>filepath</code>, default=<code>True</code></dt>
<dd>Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). By default True. If True, it will first try to save each file to the same directory as datapath, then if that does not work, to the current working directory, then to the user's home directory, by default True</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension to use for the output, by default 'hvsr'. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, export_path=True, ext=&#39;hvsr&#39;):
    &#34;&#34;&#34;Method to export HVSRData objects in HVSRBatch container to indivdual .hvsr pickle files.

    Parameters
    ----------
    export_path : filepath, default=True
        Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). By default True. If True, it will first try to save each file to the same directory as datapath, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
    ext : str, optional
        The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
    &#34;&#34;&#34;
    export_data(hvsr_data=self, export_path=export_path, ext=ext)</code></pre>
</details>
</dd>
<dt id="sprit.HVSRBatch.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>self, site_name=None, export_settings_path='default', export_settings_type='all', include_location=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export settings from HVSRData object in HVSRBatch object. Simply calls sprit.export_settings() from specified HVSRData object in the HVSRBatch object. See sprit.export_settings() for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>site_name</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>The name of the site whose settings should be exported. If None, will default to the first site, by default None.</dd>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filepath to output file. If left as 'default', will save as the default value in the resources directory. If that is not possible, will save to home directory, by default 'default'</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code>, optional</dt>
<dd>They type of settings to save, by default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include the location information in the instrument settings, if that settings type is selected, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print output (filepath and settings) to terminal, by default True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_settings(self, site_name=None, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
    &#34;&#34;&#34;Method to export settings from HVSRData object in HVSRBatch object. Simply calls sprit.export_settings() from specified HVSRData object in the HVSRBatch object. See sprit.export_settings() for more details.

    Parameters
    ----------
    site_name : str, default=None
        The name of the site whose settings should be exported. If None, will default to the first site, by default None.
    export_settings_path : str, optional
        Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
    export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
        They type of settings to save, by default &#39;all&#39;
    include_location : bool, optional
        Whether to include the location information in the instrument settings, if that settings type is selected, by default False
    verbose : bool, optional
        Whether to print output (filepath and settings) to terminal, by default True
    &#34;&#34;&#34;
    #If no site name selected, use first site
    if site_name is None:
        site_name = self.sites[0]
        
    export_settings(hvsr_data=self[site_name], 
                    export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="sprit.HVSRBatch.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get report from processed data, in print, graphical, or tabular format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Variable</code></dt>
<dd>May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_report(self, **kwargs):
    &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

    Returns
    -------
    Variable
        May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.
    &#34;&#34;&#34;
    if &#39;report_format&#39; in kwargs.keys():
        if &#39;csv&#39; == kwargs[&#39;report_format&#39;]:
            for sitename in self:
                rowList = []
                rowList.append(get_report(self[sitename], **kwargs))
            return pd.concat(rowList, ignore_index=True)
        elif &#39;plot&#39; == kwargs[&#39;report_format&#39;]:
            plotDict = {}
            for sitename in self:
                if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
                    plotDict[sitename] = get_report(self[sitename], **kwargs)
                else:
                    get_report(self[sitename], **kwargs)
            return plotDict
        
    #Only report_format left is print, doesn&#39;t return anything, so doesn&#39;t matter if defalut or not
    for sitename in self:
        get_report(self[sitename], **kwargs)
    return</code></pre>
</details>
</dd>
<dt id="sprit.HVSRBatch.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return both the site names and the HVSRData object as a set of dict_items tuples. Functions similar to dict.items().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34;Method to return both the site names and the HVSRData object as a set of dict_items tuples. Functions similar to dict.items().

    Returns
    -------
    _type_
        _description_
    &#34;&#34;&#34;
    return self.batch_dict.items()</code></pre>
</details>
</dd>
<dt id="sprit.HVSRBatch.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return the "keys" of the HVSRBatch object. For HVSRBatch objects, these are the site names. Functions similar to dict.keys().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_keys</code></dt>
<dd>A dict_keys object listing the site names of each of the HVSRData objects contained in the HVSRBatch object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRBatch object. For HVSRBatch objects, these are the site names. Functions similar to dict.keys().

    Returns
    -------
    dict_keys
        A dict_keys object listing the site names of each of the HVSRData objects contained in the HVSRBatch object
    &#34;&#34;&#34;
    return self.batch_dict.keys()</code></pre>
</details>
</dd>
<dt id="sprit.HVSRBatch.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to plot data, based on the sprit.plot_hvsr() function. All the same kwargs and default values apply as plot_hvsr(). For return_fig, returns it to the 'Plot_Report' attribute of each HVSRData object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, **kwargs):
    &#34;&#34;&#34;Method to plot data, based on the sprit.plot_hvsr() function. All the same kwargs and default values apply as plot_hvsr(). For return_fig, returns it to the &#39;Plot_Report&#39; attribute of each HVSRData object

    Returns
    -------
    _type_
        _description_
    &#34;&#34;&#34;
    for sitename in self:
        if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
            self[sitename][&#39;Plot_Report&#39;] = plot_hvsr(self[sitename], **kwargs)
        else:
            plot_hvsr(self[sitename], **kwargs)

    return self</code></pre>
</details>
</dd>
<dt id="sprit.HVSRBatch.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper of get_report()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(self, **kwargs):
    &#34;&#34;&#34;Wrapper of get_report()&#34;&#34;&#34;
    return self.get_report(**kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sprit.HVSRData"><code class="flex name class">
<span>class <span class="ident">HVSRData</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>HVSRData is the basic data class of the sprit package. It contains all the processed data, input parameters, and reports.</p>
<p>These attributes and objects can be accessed using square brackets or the dot accessor. For example, to access the site name, HVSRData['site'] and HVSRData.site will both return the site name.</p>
<p>Some of the methods that work on the HVSRData object (e.g., .plot() and .get_report()) are essentially wrappers for some of the main sprit package functions (sprit.plot_hvsr() and sprit.get_report(), respectively)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HVSRData:
    &#34;&#34;&#34;HVSRData is the basic data class of the sprit package. It contains all the processed data, input parameters, and reports.
    
    These attributes and objects can be accessed using square brackets or the dot accessor. For example, to access the site name, HVSRData[&#39;site&#39;] and HVSRData.site will both return the site name.
    
    Some of the methods that work on the HVSRData object (e.g., .plot() and .get_report()) are essentially wrappers for some of the main sprit package functions (sprit.plot_hvsr() and sprit.get_report(), respectively)
    &#34;&#34;&#34;
    #Old way of using this
    #def __new__(cls, params):
    #    if isinstance(params, (cls, HVSRBatch)):
    #        return params
    #    return super().__new__(cls)

    @check_instance    
    def __init__(self, params):
        self.params = params
        #self.datastream = None
        self.batch = False
        #self.tsteps_used = []

        for key, value in params.items():
            setattr(self, key, value)
            if key==&#39;input_params&#39;:
                for k, v in params[key].items():
                    setattr(self, k, v)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, key):
        return getattr(self, key)

    def __to_json(self, filepath):
        &#34;&#34;&#34;Not yet supported, will export HVSRData object to json&#34;&#34;&#34;
        # open the file with the given filepath
        def unseriable_fun(o):
            if isinstance(o, np.ndarray):
                output = o.tolist()
            try:
                output = o.__dict__
            except:
                output = dir(o)
            return output

        with open(filepath, &#39;w&#39;) as f:
            # dump the JSON string to the file
            json.dump(self, f, default=unseriable_fun, sort_keys=True, indent=4)

    def export(self, export_path=None, ext=&#39;hvsr&#39;):
        &#34;&#34;&#34;Method to export HVSRData objects to .hvsr pickle files.

        Parameters
        ----------
        export_path : filepath, default=True
            Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). 
            By default True. 
            If True, it will first try to save each file to the same directory as datapath, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
        ext : str, optional
            The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
        &#34;&#34;&#34;
        export_data(hvsr_data=self, export_path=export_path, ext=ext)

    #METHODS (many reflect dictionary methods)
    def keys(self):
        &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRData object. For HVSRData objects, these are the attributes and parameters of the object. Functions similar to dict.keys().

        Returns
        -------
        dict_keys
            A dict_keys object of the HVSRData objects attributes, parameters, etc.
        &#34;&#34;&#34;        
        keyList = []
        for k in dir(self):
            if not k.startswith(&#39;_&#39;):
                keyList.append(k)
        return keyList

    def items(self):
        &#34;&#34;&#34;Method to return the &#34;items&#34; of the HVSRData object. For HVSRData objects, this is a dict_items object with the keys and values in tuples. Functions similar to dict.items().

        Returns
        -------
        dict_items
            A dict_items object of the HVSRData objects attributes, parameters, etc.
        &#34;&#34;&#34;                
        return self.params.items()

    def copy(self, type=&#39;shallow&#39;):
        &#34;&#34;&#34;Make a copy of the HVSRData object. Uses python copy module.
        
        Parameters
        ----------
        type : str {&#39;shallow&#39;, &#39;deep&#39;}
            Based on input, creates either a shallow or deep copy of the HVSRData object. Shallow is equivalent of copy.copy(). Input of type=&#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.
    
        &#34;&#34;&#34;
        if type.lower()==&#39;deep&#39;:
            return HVSRData(copy.deepcopy(self.params))
        else:
            return HVSRData(copy.copy(self.params))
        
    def plot(self, **kwargs):
        &#34;&#34;&#34;Method to plot data, wrapper of sprit.plot_hvsr()

        Returns
        -------
        matplotlib.Figure, matplotlib.Axis (if return_fig=True)
        &#34;&#34;&#34;
        if &#39;close_figs&#39; not in kwargs.keys():
            kwargs[&#39;close_figs&#39;]=True
        plot_return = plot_hvsr(self, **kwargs)
        plt.show()
        return plot_return
        
    def get_report(self, **kwargs):
        &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

        Returns
        -------
        Variable
            May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.
        &#34;&#34;&#34;
        report_return = get_report(self, **kwargs)
        return report_return

    def report(self, **kwargs):
        &#34;&#34;&#34;Wrapper of get_report()&#34;&#34;&#34;
        report_return = get_report(self, **kwargs)
        return report_return

    def export_settings(self, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
        &#34;&#34;&#34;Method to export settings from HVSRData object. Simply calls sprit.export_settings() from the HVSRData object. See sprit.export_settings() for more details.

        Parameters
        ----------
        export_settings_path : str, optional
            Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
        export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
            They type of settings to save, by default &#39;all&#39;
        include_location : bool, optional
            Whether to include the location information in the instrument settings, if that settings type is selected, by default False
        verbose : bool, optional
            Whether to print output (filepath and settings) to terminal, by default True
        &#34;&#34;&#34;
        export_settings(hvsr_data=self, 
                        export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)
    
    #ATTRIBUTES
    #params
    @property
    def params(self):
        &#34;&#34;&#34;Dictionary containing the parameters used to process the data

        Returns
        -------
        dict
            Dictionary containing the process parameters
        &#34;&#34;&#34;
        return self._params

    @params.setter
    def params(self, value):
        if not (isinstance(value, dict)):
            raise ValueError(&#34;params must be a dict type, currently passing {} type.&#34;.format(type(value)))
        self._params = value
    
    #datastream
    @property
    def datastream(self):
        &#34;&#34;&#34;A copy of the original obspy datastream read in. This helps to retain the original data even after processing is carried out.

        Returns
        -------
        obspy.core.Stream.stream
            Obspy stream
        &#34;&#34;&#34;
        return self._datastream

    @datastream.setter
    def datastream(self, value):
        if value is not None and (not isinstance(value, obspy.core.stream.Stream)):
            raise ValueError(&#34;datastream must be an obspy Stream.&#34;)
        self._datastream = value
        
    #batch
    @property
    def batch(self):
        &#34;&#34;&#34;Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.

        Returns
        -------
        bool
            True if HVSRData object is part of HVSRBatch object, otherwise, False
        &#34;&#34;&#34;
        return self._batch

    @batch.setter
    def batch(self, value):
        if value == 0:
            value = False
        elif value == 1:
            value = True
        else:
            value = None
        if not isinstance(value, bool):
            raise ValueError(&#34;batch must be boolean type&#34;)
        self._batch = value

    #PPSD object from obspy (static)
    @property
    def ppsds_obspy(self):
        &#34;&#34;&#34;The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.&#34;&#34;&#34;        
        return self._ppsds_obspy

    @ppsds_obspy.setter
    def ppsds_obspy(self, value):
        &#34;&#34;&#34;Checks whether the ppsd_obspy is of the proper type before saving as attribute&#34;&#34;&#34;
        if not isinstance(value, obspy.signal.spectral_estimation.PPSD):
            if not isinstance(value, dict):
                raise ValueError(&#34;ppsds_obspy must be obspy.PPSD or dict with osbpy.PPSDs&#34;)
            else:
                for key in value.keys():
                    if not isinstance(value[key], obspy.signal.spectral_estimation.PPSD):
                        raise ValueError(&#34;ppsds_obspy must be obspy.PPSD or dict with osbpy.PPSDs&#34;)
        self._ppsds_obspy=value
                        
    #PPSD dict, copied from obspy ppsds (dynamic)
    @property
    def ppsds(self):
        &#34;&#34;&#34;Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.

        Returns
        -------
        dict
            Dictionary copy of the PPSD information from generate_ppsds()
        &#34;&#34;&#34;
        return self._ppsds

    @ppsds.setter
    def ppsds(self, value):
        if not isinstance(value, dict):
            raise ValueError(&#34;ppsds dict with infomration from osbpy.PPSD (created by sprit.generate_ppsds())&#34;)                  
        self._ppsds=value</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="sprit.HVSRData.batch"><code class="name">var <span class="ident">batch</span></code></dt>
<dd>
<div class="desc"><p>Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if HVSRData object is part of HVSRBatch object, otherwise, False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def batch(self):
    &#34;&#34;&#34;Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.

    Returns
    -------
    bool
        True if HVSRData object is part of HVSRBatch object, otherwise, False
    &#34;&#34;&#34;
    return self._batch</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.datastream"><code class="name">var <span class="ident">datastream</span></code></dt>
<dd>
<div class="desc"><p>A copy of the original obspy datastream read in. This helps to retain the original data even after processing is carried out.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>obspy.core.Stream.stream</code></dt>
<dd>Obspy stream</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def datastream(self):
    &#34;&#34;&#34;A copy of the original obspy datastream read in. This helps to retain the original data even after processing is carried out.

    Returns
    -------
    obspy.core.Stream.stream
        Obspy stream
    &#34;&#34;&#34;
    return self._datastream</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"><p>Dictionary containing the parameters used to process the data</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the process parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params(self):
    &#34;&#34;&#34;Dictionary containing the parameters used to process the data

    Returns
    -------
    dict
        Dictionary containing the process parameters
    &#34;&#34;&#34;
    return self._params</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.ppsds"><code class="name">var <span class="ident">ppsds</span></code></dt>
<dd>
<div class="desc"><p>Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary copy of the PPSD information from generate_ppsds()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppsds(self):
    &#34;&#34;&#34;Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.

    Returns
    -------
    dict
        Dictionary copy of the PPSD information from generate_ppsds()
    &#34;&#34;&#34;
    return self._ppsds</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.ppsds_obspy"><code class="name">var <span class="ident">ppsds_obspy</span></code></dt>
<dd>
<div class="desc"><p>The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppsds_obspy(self):
    &#34;&#34;&#34;The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.&#34;&#34;&#34;        
    return self._ppsds_obspy</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sprit.HVSRData.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, type='shallow')</span>
</code></dt>
<dd>
<div class="desc"><p>Make a copy of the HVSRData object. Uses python copy module.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str {'shallow', 'deep'}</code></dt>
<dd>Based on input, creates either a shallow or deep copy of the HVSRData object. Shallow is equivalent of copy.copy(). Input of type='deep' is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, type=&#39;shallow&#39;):
    &#34;&#34;&#34;Make a copy of the HVSRData object. Uses python copy module.
    
    Parameters
    ----------
    type : str {&#39;shallow&#39;, &#39;deep&#39;}
        Based on input, creates either a shallow or deep copy of the HVSRData object. Shallow is equivalent of copy.copy(). Input of type=&#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.

    &#34;&#34;&#34;
    if type.lower()==&#39;deep&#39;:
        return HVSRData(copy.deepcopy(self.params))
    else:
        return HVSRData(copy.copy(self.params))</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, export_path=None, ext='hvsr')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export HVSRData objects to .hvsr pickle files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>export_path</code></strong> :&ensp;<code>filepath</code>, default=<code>True</code></dt>
<dd>Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes).
By default True.
If True, it will first try to save each file to the same directory as datapath, then if that does not work, to the current working directory, then to the user's home directory, by default True</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension to use for the output, by default 'hvsr'. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, export_path=None, ext=&#39;hvsr&#39;):
    &#34;&#34;&#34;Method to export HVSRData objects to .hvsr pickle files.

    Parameters
    ----------
    export_path : filepath, default=True
        Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). 
        By default True. 
        If True, it will first try to save each file to the same directory as datapath, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
    ext : str, optional
        The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
    &#34;&#34;&#34;
    export_data(hvsr_data=self, export_path=export_path, ext=ext)</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>self, export_settings_path='default', export_settings_type='all', include_location=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export settings from HVSRData object. Simply calls sprit.export_settings() from the HVSRData object. See sprit.export_settings() for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filepath to output file. If left as 'default', will save as the default value in the resources directory. If that is not possible, will save to home directory, by default 'default'</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code>, optional</dt>
<dd>They type of settings to save, by default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include the location information in the instrument settings, if that settings type is selected, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print output (filepath and settings) to terminal, by default True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_settings(self, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
    &#34;&#34;&#34;Method to export settings from HVSRData object. Simply calls sprit.export_settings() from the HVSRData object. See sprit.export_settings() for more details.

    Parameters
    ----------
    export_settings_path : str, optional
        Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
    export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
        They type of settings to save, by default &#39;all&#39;
    include_location : bool, optional
        Whether to include the location information in the instrument settings, if that settings type is selected, by default False
    verbose : bool, optional
        Whether to print output (filepath and settings) to terminal, by default True
    &#34;&#34;&#34;
    export_settings(hvsr_data=self, 
                    export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get report from processed data, in print, graphical, or tabular format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Variable</code></dt>
<dd>May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_report(self, **kwargs):
    &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

    Returns
    -------
    Variable
        May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.
    &#34;&#34;&#34;
    report_return = get_report(self, **kwargs)
    return report_return</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return the "items" of the HVSRData object. For HVSRData objects, this is a dict_items object with the keys and values in tuples. Functions similar to dict.items().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_items</code></dt>
<dd>A dict_items object of the HVSRData objects attributes, parameters, etc.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34;Method to return the &#34;items&#34; of the HVSRData object. For HVSRData objects, this is a dict_items object with the keys and values in tuples. Functions similar to dict.items().

    Returns
    -------
    dict_items
        A dict_items object of the HVSRData objects attributes, parameters, etc.
    &#34;&#34;&#34;                
    return self.params.items()</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return the "keys" of the HVSRData object. For HVSRData objects, these are the attributes and parameters of the object. Functions similar to dict.keys().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_keys</code></dt>
<dd>A dict_keys object of the HVSRData objects attributes, parameters, etc.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRData object. For HVSRData objects, these are the attributes and parameters of the object. Functions similar to dict.keys().

    Returns
    -------
    dict_keys
        A dict_keys object of the HVSRData objects attributes, parameters, etc.
    &#34;&#34;&#34;        
    keyList = []
    for k in dir(self):
        if not k.startswith(&#39;_&#39;):
            keyList.append(k)
    return keyList</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to plot data, wrapper of sprit.plot_hvsr()</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.Figure, matplotlib.Axis (if return_fig=True)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, **kwargs):
    &#34;&#34;&#34;Method to plot data, wrapper of sprit.plot_hvsr()

    Returns
    -------
    matplotlib.Figure, matplotlib.Axis (if return_fig=True)
    &#34;&#34;&#34;
    if &#39;close_figs&#39; not in kwargs.keys():
        kwargs[&#39;close_figs&#39;]=True
    plot_return = plot_hvsr(self, **kwargs)
    plt.show()
    return plot_return</code></pre>
</details>
</dd>
<dt id="sprit.HVSRData.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper of get_report()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(self, **kwargs):
    &#34;&#34;&#34;Wrapper of get_report()&#34;&#34;&#34;
    report_return = get_report(self, **kwargs)
    return report_return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="sprit.sprit_cli" href="sprit_cli.html">sprit.sprit_cli</a></code></li>
<li><code><a title="sprit.sprit_gui" href="sprit_gui.html">sprit.sprit_gui</a></code></li>
<li><code><a title="sprit.sprit_hvsr" href="sprit_hvsr.html">sprit.sprit_hvsr</a></code></li>
<li><code><a title="sprit.sprit_jupyter_UI" href="sprit_jupyter_UI.html">sprit.sprit_jupyter_UI</a></code></li>
<li><code><a title="sprit.sprit_utils" href="sprit_utils.html">sprit.sprit_utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sprit.azimuth" href="#sprit.azimuth">azimuth</a></code></li>
<li><code><a title="sprit.batch_data_read" href="#sprit.batch_data_read">batch_data_read</a></code></li>
<li><code><a title="sprit.catch_errors" href="#sprit.catch_errors">catch_errors</a></code></li>
<li><code><a title="sprit.check_gui_requirements" href="#sprit.check_gui_requirements">check_gui_requirements</a></code></li>
<li><code><a title="sprit.check_mark" href="#sprit.check_mark">check_mark</a></code></li>
<li><code><a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks</a></code></li>
<li><code><a title="sprit.check_tsteps" href="#sprit.check_tsteps">check_tsteps</a></code></li>
<li><code><a title="sprit.check_xvalues" href="#sprit.check_xvalues">check_xvalues</a></code></li>
<li><code><a title="sprit.checkifpath" href="#sprit.checkifpath">checkifpath</a></code></li>
<li><code><a title="sprit.create_jupyter_ui" href="#sprit.create_jupyter_ui">create_jupyter_ui</a></code></li>
<li><code><a title="sprit.export_data" href="#sprit.export_data">export_data</a></code></li>
<li><code><a title="sprit.export_settings" href="#sprit.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data</a></code></li>
<li><code><a title="sprit.format_time" href="#sprit.format_time">format_time</a></code></li>
<li><code><a title="sprit.generate_ppsds" href="#sprit.generate_ppsds">generate_ppsds</a></code></li>
<li><code><a title="sprit.get_char" href="#sprit.get_char">get_char</a></code></li>
<li><code><a title="sprit.get_metadata" href="#sprit.get_metadata">get_metadata</a></code></li>
<li><code><a title="sprit.get_report" href="#sprit.get_report">get_report</a></code></li>
<li><code><a title="sprit.gui" href="#sprit.gui">gui</a></code></li>
<li><code><a title="sprit.has_required_channels" href="#sprit.has_required_channels">has_required_channels</a></code></li>
<li><code><a title="sprit.import_data" href="#sprit.import_data">import_data</a></code></li>
<li><code><a title="sprit.import_settings" href="#sprit.import_settings">import_settings</a></code></li>
<li><code><a title="sprit.input_params" href="#sprit.input_params">input_params</a></code></li>
<li><code><a title="sprit.make_it_classy" href="#sprit.make_it_classy">make_it_classy</a></code></li>
<li><code><a title="sprit.plot_hvsr" href="#sprit.plot_hvsr">plot_hvsr</a></code></li>
<li><code><a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr</a></code></li>
<li><code><a title="sprit.read_from_RS" href="#sprit.read_from_RS">read_from_RS</a></code></li>
<li><code><a title="sprit.read_tromino_files" href="#sprit.read_tromino_files">read_tromino_files</a></code></li>
<li><code><a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise</a></code></li>
<li><code><a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves</a></code></li>
<li><code><a title="sprit.run" href="#sprit.run">run</a></code></li>
<li><code><a title="sprit.time_it" href="#sprit.time_it">time_it</a></code></li>
<li><code><a title="sprit.x_mark" href="#sprit.x_mark">x_mark</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code></h4>
<ul class="two-column">
<li><code><a title="sprit.HVSRBatch.copy" href="#sprit.HVSRBatch.copy">copy</a></code></li>
<li><code><a title="sprit.HVSRBatch.export" href="#sprit.HVSRBatch.export">export</a></code></li>
<li><code><a title="sprit.HVSRBatch.export_settings" href="#sprit.HVSRBatch.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.HVSRBatch.get_report" href="#sprit.HVSRBatch.get_report">get_report</a></code></li>
<li><code><a title="sprit.HVSRBatch.items" href="#sprit.HVSRBatch.items">items</a></code></li>
<li><code><a title="sprit.HVSRBatch.keys" href="#sprit.HVSRBatch.keys">keys</a></code></li>
<li><code><a title="sprit.HVSRBatch.plot" href="#sprit.HVSRBatch.plot">plot</a></code></li>
<li><code><a title="sprit.HVSRBatch.report" href="#sprit.HVSRBatch.report">report</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></h4>
<ul class="two-column">
<li><code><a title="sprit.HVSRData.batch" href="#sprit.HVSRData.batch">batch</a></code></li>
<li><code><a title="sprit.HVSRData.copy" href="#sprit.HVSRData.copy">copy</a></code></li>
<li><code><a title="sprit.HVSRData.datastream" href="#sprit.HVSRData.datastream">datastream</a></code></li>
<li><code><a title="sprit.HVSRData.export" href="#sprit.HVSRData.export">export</a></code></li>
<li><code><a title="sprit.HVSRData.export_settings" href="#sprit.HVSRData.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.HVSRData.get_report" href="#sprit.HVSRData.get_report">get_report</a></code></li>
<li><code><a title="sprit.HVSRData.items" href="#sprit.HVSRData.items">items</a></code></li>
<li><code><a title="sprit.HVSRData.keys" href="#sprit.HVSRData.keys">keys</a></code></li>
<li><code><a title="sprit.HVSRData.params" href="#sprit.HVSRData.params">params</a></code></li>
<li><code><a title="sprit.HVSRData.plot" href="#sprit.HVSRData.plot">plot</a></code></li>
<li><code><a title="sprit.HVSRData.ppsds" href="#sprit.HVSRData.ppsds">ppsds</a></code></li>
<li><code><a title="sprit.HVSRData.ppsds_obspy" href="#sprit.HVSRData.ppsds_obspy">ppsds_obspy</a></code></li>
<li><code><a title="sprit.HVSRData.report" href="#sprit.HVSRData.report">report</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>